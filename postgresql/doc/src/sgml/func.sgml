<!-- doc/src/sgml/func.sgml -->

 <chapter id="functions">
<!--==========================orignal english content==========================
  <title>Functions and Operators</title>
____________________________________________________________________________-->
  <title>函数和操作符</title>

<!--==========================orignal english content==========================
  <indexterm zone="functions">
   <primary>function</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="functions">
   <primary>function</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm zone="functions">
   <primary>operator</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="functions">
   <primary>operator</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   <productname>PostgreSQL</productname> provides a large number of
   functions and operators for the built-in data types.  This chapter
   describes most of them, although additional special-purpose functions
   appear in relevant sections of the manual.  Users can also
   define their own functions and operators, as described in
   <xref linkend="server-programming"/>.  The
   <application>psql</application> commands <command>\df</command> and
   <command>\do</command> can be used to list all
   available functions and operators, respectively.
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>为内建的数据类型提供了大量的函数和操作符。 
   本章描述了其中的大部分内容，不过在手册的相关章节中还显示了更多的特殊用途函数。
   用户也可以定义它们自己的函数和操作符， 如<xref linkend="server-programming"/>所述。
   <application>psql</application>命令<command>\df</command>和<command>\do</command>可以分别被用于显示所有可用的函数和操作符的列表。
  </para>

<!--==========================orignal english content==========================
  <para>
   The notation used throughout this chapter to describe the argument and
   result data types of a function or operator is like this:
<synopsis>
<function>repeat</function> ( <type>text</type>, <type>integer</type> ) <returnvalue>text</returnvalue>
</synopsis>
   which says that the function <function>repeat</function> takes one text and
   one integer argument and returns a result of type text.  The right arrow
   is also used to indicate the result of an example, thus:
<programlisting>
repeat('Pg', 4) <returnvalue>PgPgPgPg</returnvalue>
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   本章中用于描述函数或操作符的参数和结果数据类型的符号如下所示:
<synopsis>
<function>repeat</function> ( <type>text</type>, <type>integer</type> ) <returnvalue>text</returnvalue>
</synopsis>
   函数<function>repeat</function>接受一个文本和一个整型参数，并返回文本类型的结果。右箭头也用于指示举例的结果，因此:
<programlisting>
repeat('Pg', 4) <returnvalue>PgPgPgPg</returnvalue>
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   If you are concerned about portability then note that most of
   the functions and operators described in this chapter, with the
   exception of the most trivial arithmetic and comparison operators
   and some explicitly marked functions, are not specified by the
   <acronym>SQL</acronym> standard. Some of this extended functionality
   is present in other <acronym>SQL</acronym> database management
   systems, and in many cases this functionality is compatible and
   consistent between the various implementations.
  </para>
____________________________________________________________________________-->
  <para>
   如果你关心移植性，那么请注意，我们在本章描述的大多数函数和操作符， 除了最琐碎的算术和比较操作符以及一些做了明确标记的函数以外，都没有在<acronym>SQL</acronym>标准里声明。某些这种扩展的功能也出现在许多其它<acronym>SQL</acronym>数据库管理系统中，并且在很多情况下多个实现的这种功能是相互兼容的和一致的。
  </para>


  <sect1 id="functions-logical">
<!--==========================orignal english content==========================
   <title>Logical Operators</title>
____________________________________________________________________________-->
   <title>逻辑操作符</title>

<!--==========================orignal english content==========================
   <indexterm zone="functions-logical">
    <primary>operator</primary>
    <secondary>logical</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="functions-logical">
    <primary>operator</primary>
    <secondary>logical</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>Boolean</primary>
    <secondary>operators</secondary>
    <see>operators, logical</see>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>Boolean</primary>
    <secondary>operators</secondary>
    <see>operators, logical</see>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    The usual logical operators are available:

    <indexterm>
     <primary>AND (operator)</primary>
    </indexterm>

    <indexterm>
     <primary>OR (operator)</primary>
    </indexterm>

    <indexterm>
     <primary>NOT (operator)</primary>
    </indexterm>

    <indexterm>
     <primary>conjunction</primary>
    </indexterm>

    <indexterm>
     <primary>disjunction</primary>
    </indexterm>

    <indexterm>
     <primary>negation</primary>
    </indexterm>

<synopsis>
<type>boolean</type> <literal>AND</literal> <type>boolean</type> <returnvalue>boolean</returnvalue>
<type>boolean</type> <literal>OR</literal> <type>boolean</type> <returnvalue>boolean</returnvalue>
<literal>NOT</literal> <type>boolean</type> <returnvalue>boolean</returnvalue>
</synopsis>

    <acronym>SQL</acronym> uses a three-valued logic system with true,
    false, and <literal>null</literal>, which represents <quote>unknown</quote>.
    Observe the following truth tables:

    <informaltable>
     <tgroup cols="4">
      <thead>
       <row>
        <entry><replaceable>a</replaceable></entry>
        <entry><replaceable>b</replaceable></entry>
        <entry><replaceable>a</replaceable> AND <replaceable>b</replaceable></entry>
        <entry><replaceable>a</replaceable> OR <replaceable>b</replaceable></entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry>TRUE</entry>
        <entry>TRUE</entry>
        <entry>TRUE</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>TRUE</entry>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>TRUE</entry>
        <entry>NULL</entry>
        <entry>NULL</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
       </row>

       <row>
        <entry>FALSE</entry>
        <entry>NULL</entry>
        <entry>FALSE</entry>
        <entry>NULL</entry>
       </row>

       <row>
        <entry>NULL</entry>
        <entry>NULL</entry>
        <entry>NULL</entry>
        <entry>NULL</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>

    <informaltable>
     <tgroup cols="2">
      <thead>
       <row>
        <entry><replaceable>a</replaceable></entry>
        <entry>NOT <replaceable>a</replaceable></entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry>TRUE</entry>
        <entry>FALSE</entry>
       </row>

       <row>
        <entry>FALSE</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>NULL</entry>
        <entry>NULL</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>
____________________________________________________________________________-->
   <para>
    常用的逻辑操作符有：

    <indexterm>
     <primary>AND（操作符）</primary>
    </indexterm>

    <indexterm>
     <primary>OR（操作符）</primary>
    </indexterm>

    <indexterm>
     <primary>NOT（操作符）</primary>
    </indexterm>

    <indexterm>
     <primary>conjunction</primary>
    </indexterm>

    <indexterm>
     <primary>disjunction</primary>
    </indexterm>

    <indexterm>
     <primary>negation</primary>
    </indexterm>

<synopsis>
<type>boolean</type> <literal>AND</literal> <type>boolean</type> <returnvalue>boolean</returnvalue>
<type>boolean</type> <literal>OR</literal> <type>boolean</type> <returnvalue>boolean</returnvalue>
<literal>NOT</literal> <type>boolean</type> <returnvalue>boolean</returnvalue>
</synopsis>

    <acronym>SQL</acronym>使用三值的逻辑系统，包括真、假和<literal>null</literal>，<literal>null</literal>表示<quote>未知</quote>。观察下面的真值表：

    <informaltable>
     <tgroup cols="4">
      <thead>
       <row>
        <entry><replaceable>a</replaceable></entry>
        <entry><replaceable>b</replaceable></entry>
        <entry><replaceable>a</replaceable> AND <replaceable>b</replaceable></entry>
        <entry><replaceable>a</replaceable> OR <replaceable>b</replaceable></entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry>TRUE</entry>
        <entry>TRUE</entry>
        <entry>TRUE</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>TRUE</entry>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>TRUE</entry>
        <entry>NULL</entry>
        <entry>NULL</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
       </row>

       <row>
        <entry>FALSE</entry>
        <entry>NULL</entry>
        <entry>FALSE</entry>
        <entry>NULL</entry>
       </row>

       <row>
        <entry>NULL</entry>
        <entry>NULL</entry>
        <entry>NULL</entry>
        <entry>NULL</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>

    <informaltable>
     <tgroup cols="2">
      <thead>
       <row>
        <entry><replaceable>a</replaceable></entry>
        <entry>NOT <replaceable>a</replaceable></entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry>TRUE</entry>
        <entry>FALSE</entry>
       </row>

       <row>
        <entry>FALSE</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>NULL</entry>
        <entry>NULL</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>

<!--==========================orignal english content==========================
   <para>
    The operators <literal>AND</literal> and <literal>OR</literal> are
    commutative, that is, you can switch the left and right operands
    without affecting the result.  (However, it is not guaranteed that
    the left operand is evaluated before the right operand.  See <xref
    linkend="syntax-express-eval"/> for more information about the
    order of evaluation of subexpressions.)
   </para>
____________________________________________________________________________-->
   <para>
    操作符<literal>AND</literal>和<literal>OR</literal>是可交换的，也就是说，你可以交换左右操作数而不影响结果。
    （但是，不能保证左操作数在右操作数之前计算。参见<xref linkend="syntax-express-eval"/>获取有关子表达式计算顺序的更多信息。）
   </para>
  </sect1>

  <sect1 id="functions-comparison">
<!--==========================orignal english content==========================
   <title>Comparison Functions and Operators</title>
____________________________________________________________________________-->
   <title>比较函数和操作符</title>

<!--==========================orignal english content==========================
   <indexterm zone="functions-comparison">
    <primary>comparison</primary>
    <secondary>operators</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="functions-comparison">
    <primary>comparison</primary>
    <secondary>operators</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    The usual comparison operators are available, as shown in <xref
    linkend="functions-comparison-op-table"/>.
   </para>
____________________________________________________________________________-->
   <para>
    常见的比较操作符都可用，如<xref linkend="functions-comparison-op-table"/>所示。
   </para>

   <table id="functions-comparison-op-table">
<!--==========================orignal english content==========================
    <title>Comparison Operators</title>
____________________________________________________________________________-->
    <title>比较操作符</title>
    <tgroup cols="2">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Operator</entry>
       <entry>Description</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>操作符</entry>
       <entry>描述</entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>&lt;</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
       <entry>Less than</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>&lt;</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
       <entry>小于</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>&gt;</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
       <entry>Greater than</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>&gt;</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
       <entry>大于</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>&lt;=</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
       <entry>Less than or equal to</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>&lt;=</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
       <entry>小于等于</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>&gt;=</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
       <entry>Greater than or equal to</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>&gt;=</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
       <entry>大于等于</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>=</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
       <entry>Equal</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>=</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
       <entry>等于</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>&lt;&gt;</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
       <entry>Not equal</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>&lt;&gt;</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
       <entry>不等于</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>!=</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
       <entry>Not equal</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>!=</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
       <entry>不等于</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <note>
<!--==========================orignal english content==========================
    <para>
     <literal>&lt;&gt;</literal> is the standard SQL notation for <quote>not
     equal</quote>.  <literal>!=</literal> is an alias, which is converted
     to <literal>&lt;&gt;</literal> at a very early stage of parsing.
     Hence, it is not possible to implement <literal>!=</literal>
     and <literal>&lt;&gt;</literal> operators that do different things.
    </para>
____________________________________________________________________________-->
    <para>
     <literal>&lt;&gt;</literal> 表示 <quote>not equal</quote> 的标准的SQL符号。
     <literal>!=</literal> 是一个别名, 在解析的早期阶段被转换为 <literal>&lt;&gt;</literal> 。
     因此, 它不可能实现 <literal>!=</literal> 和 <literal>&lt;&gt;</literal> 操作符以做不同的事情。
    </para>
   </note>

<!--==========================orignal english content==========================
   <para>
    These comparison operators are available for all built-in data types
    that have a natural ordering, including numeric, string, and date/time
    types.  In addition, arrays, composite types, and ranges can be compared
    if their component data types are comparable.
   </para>
____________________________________________________________________________-->
   <para>
    这些比较操作符适用于所有具有自然排序的内置数据类型，包括数字、字符串、和日期/时间类型。 
    此外，如果它们的组件数据类型具有可比性，则可以比较阵列、复合类型和范围。
   </para>

<!--==========================orignal english content==========================
   <para>
    It is usually possible to compare values of related data
    types as well; for example <type>integer</type> <literal>&gt;</literal>
    <type>bigint</type> will work.  Some cases of this sort are implemented
    directly by <quote>cross-type</quote> comparison operators, but if no
    such operator is available, the parser will coerce the less-general type
    to the more-general type and apply the latter's comparison operator.
   </para>
____________________________________________________________________________-->
   <para>
    通常也可以比较相关数据类型的值；例如<type>integer</type> <literal>&gt;</literal> <type>bigint</type> 将起作用。
    这种排序的某些情况直接由<quote>cross-type</quote> 比较操作符实现，但是，如果没有这种操作符，解析器将把不太通用的类型强制为更通用的类型，并应用后者的比较操作符。
   </para>

<!--==========================orignal english content==========================
   <para>
    As shown above, all comparison operators are binary operators that
    return values of type <type>boolean</type>.  Thus, expressions like
    <literal>1 &lt; 2 &lt; 3</literal> are not valid (because there is
    no <literal>&lt;</literal> operator to compare a Boolean value with
    <literal>3</literal>).  Use the <literal>BETWEEN</literal> predicates
    shown below to perform range tests.
   </para>
____________________________________________________________________________-->
   <para>
    如上所示，所有比较操作符都是二元操作符，返回<type>boolean</type>类型的值。
    因此，类似<literal>1 &lt; 2 &lt; 3</literal>的表达式是无效的。因为没有<literal>&lt;</literal>操作符与 <literal>3</literal> 进行Boolean值比较）。
    使用下面显示的<literal>BETWEEN</literal>谓词执行范围测试。
   </para>

<!--==========================orignal english content==========================
   <para>
    There are also some comparison predicates, as shown in <xref
    linkend="functions-comparison-pred-table"/>.  These behave much like
    operators, but have special syntax mandated by the SQL standard.
   </para>
____________________________________________________________________________-->
   <para>
    如<xref linkend="functions-comparison-pred-table"/>所示，也有一些比较谓词。它们的行为和操作符很像，但是具有 SQL 标准所要求的特殊语法。
   </para>

   <table id="functions-comparison-pred-table">
<!--==========================orignal english content==========================
    <title>Comparison Predicates</title>
____________________________________________________________________________-->
    <title>比较谓词</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Predicate
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        谓词
       </para>
       <para>
        描述
       </para>
       <para>
        示例(s)
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>BETWEEN</literal> <replaceable>datatype</replaceable> <literal>AND</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Between (inclusive of the range endpoints).
       </para>
       <para>
        <literal>2 BETWEEN 1 AND 3</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>2 BETWEEN 3 AND 1</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>BETWEEN</literal> <replaceable>datatype</replaceable> <literal>AND</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        之间(包括范围端点)。
       </para>
       <para>
        <literal>2 BETWEEN 1 AND 3</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>2 BETWEEN 3 AND 1</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>NOT BETWEEN</literal> <replaceable>datatype</replaceable> <literal>AND</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Not between (the negation of <literal>BETWEEN</literal>).
       </para>
       <para>
        <literal>2 NOT BETWEEN 1 AND 3</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>NOT BETWEEN</literal> <replaceable>datatype</replaceable> <literal>AND</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        不在之间 (<literal>BETWEEN</literal>的否定).
       </para>
       <para>
        <literal>2 NOT BETWEEN 1 AND 3</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>BETWEEN SYMMETRIC</literal> <replaceable>datatype</replaceable> <literal>AND</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Between, after sorting the two endpoint values.
       </para>
       <para>
        <literal>2 BETWEEN SYMMETRIC 3 AND 1</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>BETWEEN SYMMETRIC</literal> <replaceable>datatype</replaceable> <literal>AND</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        之间, 在对两个端点值排序之后。
       </para>
       <para>
        <literal>2 BETWEEN SYMMETRIC 3 AND 1</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>NOT BETWEEN SYMMETRIC</literal> <replaceable>datatype</replaceable> <literal>AND</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Not between, after sorting the two endpoint values.
       </para>
       <para>
        <literal>2 NOT BETWEEN SYMMETRIC 3 AND 1</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>NOT BETWEEN SYMMETRIC</literal> <replaceable>datatype</replaceable> <literal>AND</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        不在之间, 在对两个端点值排序之后。
       </para>
       <para>
        <literal>2 NOT BETWEEN SYMMETRIC 3 AND 1</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>IS DISTINCT FROM</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Not equal, treating null as a comparable value.
       </para>
       <para>
        <literal>1 IS DISTINCT FROM NULL</literal>
        <returnvalue>t</returnvalue> (rather than <literal>NULL</literal>)
       </para>
       <para>
        <literal>NULL IS DISTINCT FROM NULL</literal>
        <returnvalue>f</returnvalue> (rather than <literal>NULL</literal>)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>IS DISTINCT FROM</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        不相等, 将空(null)视为可比值。
       </para>
       <para>
        <literal>1 IS DISTINCT FROM NULL</literal>
        <returnvalue>t</returnvalue> (而不是 <literal>NULL</literal>)
       </para>
       <para>
        <literal>NULL IS DISTINCT FROM NULL</literal>
        <returnvalue>f</returnvalue> (而不是 <literal>NULL</literal>)
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>IS NOT DISTINCT FROM</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Equal, treating null as a comparable value.
       </para>
       <para>
        <literal>1 IS NOT DISTINCT FROM NULL</literal>
        <returnvalue>f</returnvalue> (rather than <literal>NULL</literal>)
       </para>
       <para>
        <literal>NULL IS NOT DISTINCT FROM NULL</literal>
        <returnvalue>t</returnvalue> (rather than <literal>NULL</literal>)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>IS NOT DISTINCT FROM</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        相等, 将空(null)视为可比值。
       </para>
       <para>
        <literal>1 IS NOT DISTINCT FROM NULL</literal>
        <returnvalue>f</returnvalue> (而不是 <literal>NULL</literal>)
       </para>
       <para>
        <literal>NULL IS NOT DISTINCT FROM NULL</literal>
        <returnvalue>t</returnvalue> (而不是 <literal>NULL</literal>)
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>IS NULL</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Test whether value is null.
       </para>
       <para>
        <literal>1.5 IS NULL</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>IS NULL</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试值是否为空。
       </para>
       <para>
        <literal>1.5 IS NULL</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>IS NOT NULL</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Test whether value is not null.
       </para>
       <para>
        <literal>'null' IS NOT NULL</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>IS NOT NULL</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试值是否不为空。
       </para>
       <para>
        <literal>'null' IS NOT NULL</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>ISNULL</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Test whether value is null (nonstandard syntax).
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>ISNULL</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试值是否为空（非标准语法）。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>NOTNULL</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Test whether value is not null (nonstandard syntax).
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>NOTNULL</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试值是否不为空（非标准语法）。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS TRUE</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Test whether boolean expression yields true.
       </para>
       <para>
        <literal>true IS TRUE</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS TRUE</literal>
        <returnvalue>f</returnvalue> (rather than <literal>NULL</literal>)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS TRUE</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试布尔表达式是否为真。
       </para>
       <para>
        <literal>true IS TRUE</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS TRUE</literal>
        <returnvalue>f</returnvalue> (而不是 <literal>NULL</literal>)
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS NOT TRUE</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Test whether boolean expression yields false or unknown.
       </para>
       <para>
        <literal>true IS NOT TRUE</literal>
        <returnvalue>f</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS NOT TRUE</literal>
        <returnvalue>t</returnvalue> (rather than <literal>NULL</literal>)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS NOT TRUE</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试布尔表达式是否为假或未知。
       </para>
       <para>
        <literal>true IS NOT TRUE</literal>
        <returnvalue>f</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS NOT TRUE</literal>
        <returnvalue>t</returnvalue> (而不是 <literal>NULL</literal>)
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS FALSE</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Test whether boolean expression yields false.
       </para>
       <para>
        <literal>true IS FALSE</literal>
        <returnvalue>f</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS FALSE</literal>
        <returnvalue>f</returnvalue> (rather than <literal>NULL</literal>)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS FALSE</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试布尔表达式是否为假。
       </para>
       <para>
        <literal>true IS FALSE</literal>
        <returnvalue>f</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS FALSE</literal>
        <returnvalue>f</returnvalue> (而不是 <literal>NULL</literal>)
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS NOT FALSE</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Test whether boolean expression yields true or unknown.
       </para>
       <para>
        <literal>true IS NOT FALSE</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS NOT FALSE</literal>
        <returnvalue>t</returnvalue> (rather than <literal>NULL</literal>)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS NOT FALSE</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试布尔表达式是否为真或未知。
       </para>
       <para>
        <literal>true IS NOT FALSE</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS NOT FALSE</literal>
        <returnvalue>t</returnvalue> (而不是 <literal>NULL</literal>)
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS UNKNOWN</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Test whether boolean expression yields unknown.
       </para>
       <para>
        <literal>true IS UNKNOWN</literal>
        <returnvalue>f</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS UNKNOWN</literal>
        <returnvalue>t</returnvalue> (rather than <literal>NULL</literal>)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS UNKNOWN</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试布尔表达式是否为未知。
       </para>
       <para>
        <literal>true IS UNKNOWN</literal>
        <returnvalue>f</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS UNKNOWN</literal>
        <returnvalue>t</returnvalue> (而不是 <literal>NULL</literal>)
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS NOT UNKNOWN</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Test whether boolean expression yields true or false.
       </para>
       <para>
        <literal>true IS NOT UNKNOWN</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS NOT UNKNOWN</literal>
        <returnvalue>f</returnvalue> (rather than <literal>NULL</literal>)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS NOT UNKNOWN</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试布尔表达式是否为真或假。
       </para>
       <para>
        <literal>true IS NOT UNKNOWN</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS NOT UNKNOWN</literal>
        <returnvalue>f</returnvalue> (而不是 <literal>NULL</literal>)
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    <indexterm>
     <primary>BETWEEN</primary>
    </indexterm>
    <indexterm>
     <primary>BETWEEN SYMMETRIC</primary>
    </indexterm>
    The <token>BETWEEN</token> predicate simplifies range tests:
<synopsis>
<replaceable>a</replaceable> BETWEEN <replaceable>x</replaceable> AND <replaceable>y</replaceable>
</synopsis>
    is equivalent to
<synopsis>
<replaceable>a</replaceable> &gt;= <replaceable>x</replaceable> AND <replaceable>a</replaceable> &lt;= <replaceable>y</replaceable>
</synopsis>
    Notice that <token>BETWEEN</token> treats the endpoint values as included
    in the range.
    <literal>BETWEEN SYMMETRIC</literal> is like <literal>BETWEEN</literal>
    except there is no requirement that the argument to the left of
    <literal>AND</literal> be less than or equal to the argument on the right.
    If it is not, those two arguments are automatically swapped, so that
    a nonempty range is always implied.
   </para>
____________________________________________________________________________-->
   <para>
    <indexterm>
     <primary>BETWEEN</primary>
    </indexterm>
    <indexterm>
     <primary>BETWEEN SYMMETRIC</primary>
    </indexterm>
    <token>BETWEEN</token>谓词可以简化范围测试：
<synopsis>
<replaceable>a</replaceable> BETWEEN <replaceable>x</replaceable> AND <replaceable>y</replaceable>
</synopsis>
    等效于
<synopsis>
<replaceable>a</replaceable> &gt;= <replaceable>x</replaceable> AND <replaceable>a</replaceable> &lt;= <replaceable>y</replaceable>
</synopsis>
    注意<token>BETWEEN</token>认为终点值是包含在范围内的。
    <literal>BETWEEN SYMMETRIC</literal> 就像<literal>BETWEEN</literal>，除了没有要求<literal>AND</literal>的左边的参数小于或等于右边的参数。
    如果不是的话，这两个参数将自动交换，因此总是隐含一个非空范围。。
   </para>

<!--==========================orignal english content==========================
   <para>
    The various variants of <literal>BETWEEN</literal> are implemented in
    terms of the ordinary comparison operators, and therefore will work for
    any data type(s) that can be compared.
   </para>
____________________________________________________________________________-->
   <para>
    <literal>BETWEEN</literal>的各种变量都是以普通比较操作符的方式实现的，因此适用于任何可以比较的数据类型。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     The use of <literal>AND</literal> in the <literal>BETWEEN</literal>
     syntax creates an ambiguity with the use of <literal>AND</literal> as a
     logical operator.  To resolve this, only a limited set of expression
     types are allowed as the second argument of a <literal>BETWEEN</literal>
     clause.  If you need to write a more complex sub-expression
     in <literal>BETWEEN</literal>, write parentheses around the
     sub-expression.
    </para>
____________________________________________________________________________-->
    <para>
     在<literal>BETWEEN</literal>语法中使用<literal>AND</literal>会与使用<literal>AND</literal>作为逻辑操作符产生歧义。 
     为了解决这个问题，只允许有限的一组表达类型作为<literal>BETWEEN</literal>子句的第二个参数。 
     如果您需要在<literal>BETWEEN</literal>中写一个更复杂的子表达式，在子表达式两边写上圆括号。
    </para>
   </note>

<!--==========================orignal english content==========================
   <para>
    <indexterm>
     <primary>IS DISTINCT FROM</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT DISTINCT FROM</primary>
    </indexterm>
    Ordinary comparison operators yield null (signifying <quote>unknown</quote>),
    not true or false, when either input is null.  For example,
    <literal>7 = NULL</literal> yields null, as does <literal>7 &lt;&gt; NULL</literal>.  When
    this behavior is not suitable, use the
    <literal>IS <optional> NOT </optional> DISTINCT FROM</literal> predicates:
<synopsis>
<replaceable>a</replaceable> IS DISTINCT FROM <replaceable>b</replaceable>
<replaceable>a</replaceable> IS NOT DISTINCT FROM <replaceable>b</replaceable>
</synopsis>
    For non-null inputs, <literal>IS DISTINCT FROM</literal> is
    the same as the <literal>&lt;&gt;</literal> operator.  However, if both
    inputs are null it returns false, and if only one input is
    null it returns true.  Similarly, <literal>IS NOT DISTINCT
    FROM</literal> is identical to <literal>=</literal> for non-null
    inputs, but it returns true when both inputs are null, and false when only
    one input is null. Thus, these predicates effectively act as though null
    were a normal data value, rather than <quote>unknown</quote>.
   </para>
____________________________________________________________________________-->
   <para>
    <indexterm>
     <primary>IS DISTINCT FROM</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT DISTINCT FROM</primary>
    </indexterm>
    当有一个输入为空时，普通的比较操作符会得到空（表示<quote>未知</quote>），而不是真或假。例如，<literal>7 = NULL</literal>得到空，<literal>7 &lt;&gt; NULL</literal>也一样。如果这种行为不合适，可以使用<literal>IS <optional> NOT </optional> DISTINCT FROM</literal>谓词：
<synopsis>
<replaceable>a</replaceable> IS DISTINCT FROM <replaceable>b</replaceable>
<replaceable>a</replaceable> IS NOT DISTINCT FROM <replaceable>b</replaceable>
</synopsis>
    对于非空输入，<literal>IS DISTINCT FROM</literal>和<literal>&lt;&gt;</literal>操作符一样。不过，如果两个输入都为空，它会返回假。而如果只有一个输入为空，它会返回真。类似地，<literal>IS NOT DISTINCT FROM</literal>对于非空输入的行为与<literal>=</literal>相同，但是当两个输入都为空时它返回真，并且当只有一个输入为空时返回假。因此，这些谓词实际上把空值当作一种普通数据值而不是<quote>unknown</quote>。
   </para>

<!--==========================orignal english content==========================
   <para>
    <indexterm>
     <primary>IS NULL</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT NULL</primary>
    </indexterm>
    <indexterm>
     <primary>ISNULL</primary>
    </indexterm>
    <indexterm>
     <primary>NOTNULL</primary>
    </indexterm>
    To check whether a value is or is not null, use the predicates:
<synopsis>
<replaceable>expression</replaceable> IS NULL
<replaceable>expression</replaceable> IS NOT NULL
</synopsis>
    or the equivalent, but nonstandard, predicates:
<synopsis>
<replaceable>expression</replaceable> ISNULL
<replaceable>expression</replaceable> NOTNULL
</synopsis>
    <indexterm><primary>null value</primary><secondary>comparing</secondary></indexterm>
   </para>
____________________________________________________________________________-->
   <para>
    <indexterm>
     <primary>IS NULL</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT NULL</primary>
    </indexterm>
    <indexterm>
     <primary>ISNULL</primary>
    </indexterm>
    <indexterm>
     <primary>NOTNULL</primary>
    </indexterm>
    要检查一个值是否为空，使用下面的谓词：
<synopsis>
<replaceable>expression</replaceable> IS NULL
<replaceable>expression</replaceable> IS NOT NULL
</synopsis>
    或者等效，但并不标准的谓词：
<synopsis>
<replaceable>expression</replaceable> ISNULL
<replaceable>expression</replaceable> NOTNULL
</synopsis>
    <indexterm><primary>null value</primary><secondary>comparing</secondary></indexterm>
   </para>

<!--==========================orignal english content==========================
   <para>
    Do <emphasis>not</emphasis> write
    <literal><replaceable>expression</replaceable> = NULL</literal>
    because <literal>NULL</literal> is not <quote>equal to</quote>
    <literal>NULL</literal>.  (The null value represents an unknown value,
    and it is not known whether two unknown values are equal.)
   </para>
____________________________________________________________________________-->
   <para>
    <emphasis>不要</emphasis>写<literal><replaceable>expression</replaceable> = NULL</literal>，因为<literal>NULL</literal>是不<quote>等于</quote><literal>NULL</literal>的（控制代表一个未知的值，因此我们无法知道两个未知的数值是否相等）。
   </para>

  <tip>
<!--==========================orignal english content==========================
   <para>
    Some applications might expect that
    <literal><replaceable>expression</replaceable> = NULL</literal>
    returns true if <replaceable>expression</replaceable> evaluates to
    the null value.  It is highly recommended that these applications
    be modified to comply with the SQL standard. However, if that
    cannot be done the <xref linkend="guc-transform-null-equals"/>
    configuration variable is available. If it is enabled,
    <productname>PostgreSQL</productname> will convert <literal>x =
    NULL</literal> clauses to <literal>x IS NULL</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    有些应用可能要求表达式<literal><replaceable>expression</replaceable> = NULL</literal>在<replaceable>expression</replaceable>得出空值时返回真。我们强烈建议这样的应用修改成遵循 SQL 标准。但是，如果这样修改不可能完成，那么我们可以使用配置变量<xref linkend="guc-transform-null-equals"/>。如果打开它，<productname>PostgreSQL</productname>将把<literal>x = NULL</literal>子句转换成<literal>x IS NULL</literal>。
   </para>
  </tip>

<!--==========================orignal english content==========================
   <para>
    If the <replaceable>expression</replaceable> is row-valued, then
    <literal>IS NULL</literal> is true when the row expression itself is null
    or when all the row's fields are null, while
    <literal>IS NOT NULL</literal> is true when the row expression itself is non-null
    and all the row's fields are non-null.  Because of this behavior,
    <literal>IS NULL</literal> and <literal>IS NOT NULL</literal> do not always return
    inverse results for row-valued expressions; in particular, a row-valued
    expression that contains both null and non-null fields will return false
    for both tests.  In some cases, it may be preferable to
    write <replaceable>row</replaceable> <literal>IS DISTINCT FROM NULL</literal>
    or <replaceable>row</replaceable> <literal>IS NOT DISTINCT FROM NULL</literal>,
    which will simply check whether the overall row value is null without any
    additional tests on the row fields.
   </para>
____________________________________________________________________________-->
   <para>
    如果<replaceable>expression</replaceable>是行值，那么当行表达式本身为非空值或者行的所有域为非空时<literal>IS NULL</literal>为真。由于这种行为，<literal>IS NULL</literal>和<literal>IS NOT NULL</literal>并不总是为行值表达式返回反转的结果，特别是，一个同时包含 NULL 和非空值的域将会对两种测试都返回假。在某些情况下，写成<replaceable>row</replaceable> <literal>IS DISTINCT FROM NULL</literal>或者<replaceable>row</replaceable> <literal>IS NOT DISTINCT FROM NULL</literal>会更好，它们只会检查整个行值是否为空而不需要在行的域上做额外的测试。
   </para>

<!--==========================orignal english content==========================
   <para>
    <indexterm>
     <primary>IS TRUE</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT TRUE</primary>
    </indexterm>
    <indexterm>
     <primary>IS FALSE</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT FALSE</primary>
    </indexterm>
    <indexterm>
     <primary>IS UNKNOWN</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT UNKNOWN</primary>
    </indexterm>
    Boolean values can also be tested using the predicates
<synopsis>
<replaceable>boolean_expression</replaceable> IS TRUE
<replaceable>boolean_expression</replaceable> IS NOT TRUE
<replaceable>boolean_expression</replaceable> IS FALSE
<replaceable>boolean_expression</replaceable> IS NOT FALSE
<replaceable>boolean_expression</replaceable> IS UNKNOWN
<replaceable>boolean_expression</replaceable> IS NOT UNKNOWN
</synopsis>
    These will always return true or false, never a null value, even when the
    operand is null.
    A null input is treated as the logical value <quote>unknown</quote>.
    Notice that <literal>IS UNKNOWN</literal> and <literal>IS NOT UNKNOWN</literal> are
    effectively the same as <literal>IS NULL</literal> and
    <literal>IS NOT NULL</literal>, respectively, except that the input
    expression must be of Boolean type.
   </para>
____________________________________________________________________________-->
   <para>
    <indexterm>
     <primary>IS TRUE</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT TRUE</primary>
    </indexterm>
    <indexterm>
     <primary>IS FALSE</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT FALSE</primary>
    </indexterm>
    <indexterm>
     <primary>IS UNKNOWN</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT UNKNOWN</primary>
    </indexterm>
    布尔值也可以使用下列谓词进行测试：
<synopsis>
<replaceable>boolean_expression</replaceable> IS TRUE
<replaceable>boolean_expression</replaceable> IS NOT TRUE
<replaceable>boolean_expression</replaceable> IS FALSE
<replaceable>boolean_expression</replaceable> IS NOT FALSE
<replaceable>boolean_expression</replaceable> IS UNKNOWN
<replaceable>boolean_expression</replaceable> IS NOT UNKNOWN
</synopsis>
    这些谓词将总是返回真或假，从来不返回空值，即使操作数是空也如此。空值输入被当做逻辑值<quote>未知</quote>。 请注意实际上<literal>IS UNKNOWN</literal>和<literal>IS NOT UNKNOWN</literal>分别与<literal>IS NULL</literal>和<literal>IS NOT NULL</literal>相同， 只是输入表达式必须是布尔类型。
   </para>

<!-- IS OF does not conform to the ISO SQL behavior, so it is undocumented here
   <para>
    <indexterm>
     <primary>IS OF</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT OF</primary>
    </indexterm>
    It is possible to check the data type of an expression using the
    predicates
<synopsis>
<replaceable>expression</replaceable> IS OF (typename, ...)
<replaceable>expression</replaceable> IS NOT OF (typename, ...)
</synopsis>
    They return a boolean value based on whether the expression's data
    type is one of the listed data types.
   </para>
-->

<!--==========================orignal english content==========================
   <para>
    Some comparison-related functions are also available, as shown in <xref
    linkend="functions-comparison-func-table"/>.
   </para>
____________________________________________________________________________-->
   <para>
    如<xref linkend="functions-comparison-func-table"/>中所示，也有一些比较相关的函数可用。
   </para>

  <table id="functions-comparison-func-table">
<!--==========================orignal english content==========================
    <title>Comparison Functions</title>
____________________________________________________________________________-->
    <title>比较函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>num_nonnulls</primary>
        </indexterm>
        <function>num_nonnulls</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the number of non-null arguments.
       </para>
       <para>
        <literal>num_nonnulls(1, NULL, 2)</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>num_nonnulls</primary>
        </indexterm>
        <function>num_nonnulls</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回非空参数的数量。
       </para>
       <para>
        <literal>num_nonnulls(1, NULL, 2)</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>num_nulls</primary>
        </indexterm>
        <function>num_nulls</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the number of null arguments.
       </para>
       <para>
        <literal>num_nulls(1, NULL, 2)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>num_nulls</primary>
        </indexterm>
        <function>num_nulls</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回空参数的数量。
       </para>
       <para>
        <literal>num_nulls(1, NULL, 2)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  </sect1>

  <sect1 id="functions-math">
<!--==========================orignal english content==========================
   <title>Mathematical Functions and Operators</title>
____________________________________________________________________________-->
   <title>数学函数和操作符</title>

<!--==========================orignal english content==========================
   <para>
    Mathematical operators are provided for many
    <productname>PostgreSQL</productname> types. For types without
    standard mathematical conventions
    (e.g., date/time types) we
    describe the actual behavior in subsequent sections.
   </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>为很多类型提供了数学操作符。对于那些没有标准数学表达的类型（如日期/时间类型），我们将在后续小节中描述实际的行为。
   </para>

<!--==========================orignal english content==========================
   <para>
    <xref linkend="functions-math-op-table"/> shows the mathematical
    operators that are available for the standard numeric types.
    Unless otherwise noted, operators shown as
    accepting <replaceable>numeric_type</replaceable> are available for all
    the types <type>smallint</type>, <type>integer</type>,
    <type>bigint</type>, <type>numeric</type>, <type>real</type>,
    and <type>double precision</type>.
    Operators shown as accepting <replaceable>integral_type</replaceable>
    are available for the types <type>smallint</type>, <type>integer</type>,
    and <type>bigint</type>.
    Except where noted, each form of an operator returns the same data type
    as its argument(s).  Calls involving multiple argument data types, such
    as <type>integer</type> <literal>+</literal> <type>numeric</type>,
    are resolved by using the type appearing later in these lists.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-math-op-table"/> 显示了可用于标准数字类型的数学操作符。.
    除非另有说明, 显示为可接受 <replaceable>numeric_type</replaceable> 的操作符对所有的 <type>smallint</type>、<type>integer</type>、<type>bigint</type>、<type>numeric</type>、<type>real</type> 和 <type>double precision</type>类型都可用。
    显示为可接受 <replaceable>integral_type</replaceable> 的操作符对 <type>smallint</type>、<type>integer</type> 和 <type>bigint</type>类型是可用的。
    除了特别说明之处，操作符的每种形式都返回与其参数相同的数据类型。
    涉及多个参数数据类型的调用， 例如 <type>integer</type> <literal>+</literal> <type>numeric</type>，可通过使用这些列表中稍后出现的类型来解析。
   </para>

   <table id="functions-math-op-table">
<!--==========================orignal english content==========================
    <title>Mathematical Operators</title>
____________________________________________________________________________-->
    <title>数学操作符</title>

    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Operator
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        操作符
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>numeric_type</replaceable> <literal>+</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        Addition
       </para>
       <para>
        <literal>2 + 3</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>numeric_type</replaceable> <literal>+</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        加
       </para>
       <para>
        <literal>2 + 3</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>+</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        Unary plus (no operation)
       </para>
       <para>
        <literal>+ 3.5</literal>
        <returnvalue>3.5</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>+</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        一元加(无操作)
       </para>
       <para>
        <literal>+ 3.5</literal>
        <returnvalue>3.5</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>numeric_type</replaceable> <literal>-</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        Subtraction
       </para>
       <para>
        <literal>2 - 3</literal>
        <returnvalue>-1</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>numeric_type</replaceable> <literal>-</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        减
       </para>
       <para>
        <literal>2 - 3</literal>
        <returnvalue>-1</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>-</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        Negation
       </para>
       <para>
        <literal>- (-4)</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>-</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        否定
       </para>
       <para>
        <literal>- (-4)</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>numeric_type</replaceable> <literal>*</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        Multiplication
       </para>
       <para>
        <literal>2 * 3</literal>
        <returnvalue>6</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>numeric_type</replaceable> <literal>*</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        乘
       </para>
       <para>
        <literal>2 * 3</literal>
        <returnvalue>6</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>numeric_type</replaceable> <literal>/</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        Division (for integral types, division truncates the result towards
        zero)
       </para>
       <para>
        <literal>5.0 / 2</literal>
        <returnvalue>2.5000000000000000</returnvalue>
       </para>
       <para>
        <literal>5 / 2</literal>
        <returnvalue>2</returnvalue>
       </para>
       <para>
        <literal>(-5) / 2</literal>
        <returnvalue>-2</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>numeric_type</replaceable> <literal>/</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        除(对于整型，除法将结果截断为零)
       </para>
       <para>
        <literal>5.0 / 2</literal>
        <returnvalue>2.5000000000000000</returnvalue>
       </para>
       <para>
        <literal>5 / 2</literal>
        <returnvalue>2</returnvalue>
       </para>
       <para>
        <literal>(-5) / 2</literal>
        <returnvalue>-2</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>numeric_type</replaceable> <literal>%</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        Modulo (remainder); available for <type>smallint</type>,
        <type>integer</type>, <type>bigint</type>, and <type>numeric</type>
       </para>
       <para>
        <literal>5 % 4</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>numeric_type</replaceable> <literal>%</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        模（取余）; 适用于 <type>smallint</type>，<type>integer</type>，<type>bigint</type> 和 <type>numeric</type>
       </para>
       <para>
        <literal>5 % 4</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>numeric</type> <literal>^</literal> <type>numeric</type>
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <type>double precision</type> <literal>^</literal> <type>double precision</type>
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Exponentiation (unlike typical mathematical practice, multiple uses of
        <literal>^</literal> will associate left to right)
       </para>
       <para>
        <literal>2 ^ 3</literal>
        <returnvalue>8</returnvalue>
       </para>
       <para>
        <literal>2 ^ 3 ^ 3</literal>
        <returnvalue>512</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>numeric</type> <literal>^</literal> <type>numeric</type>
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <type>double precision</type> <literal>^</literal> <type>double precision</type>
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        指数 (不像典型的数学实践, 多次使用 <literal>^</literal> 将会从左到有关联)
       </para>
       <para>
        <literal>2 ^ 3</literal>
        <returnvalue>8</returnvalue>
       </para>
       <para>
        <literal>2 ^ 3 ^ 3</literal>
        <returnvalue>512</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>|/</literal> <type>double precision</type>
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Square root
       </para>
       <para>
        <literal>|/ 25.0</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>|/</literal> <type>double precision</type>
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        平方根
       </para>
       <para>
        <literal>|/ 25.0</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>||/</literal> <type>double precision</type>
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Cube root
       </para>
       <para>
        <literal>||/ 64.0</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>||/</literal> <type>double precision</type>
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        立方根
       </para>
       <para>
        <literal>||/ 64.0</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bigint</type> <literal>!</literal>
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        Factorial
        (deprecated, use <link linkend="function-factorial"><function>factorial()</function></link> instead)
       </para>
       <para>
        <literal>5 !</literal>
        <returnvalue>120</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bigint</type> <literal>!</literal>
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        阶乘(已弃用, 使用 <link linkend="function-factorial"><function>factorial()</function></link> 代替)
       </para>
       <para>
        <literal>5 !</literal>
        <returnvalue>120</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>!!</literal> <type>bigint</type>
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        Factorial as a prefix operator
        (deprecated, use <link linkend="function-factorial"><function>factorial()</function></link> instead)
       </para>
       <para>
        <literal>!! 5</literal>
        <returnvalue>120</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>!!</literal> <type>bigint</type>
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        阶乘作为前缀操作符(已弃用, 使用 <link linkend="function-factorial"><function>factorial()</function></link> 代替)
       </para>
       <para>
        <literal>!! 5</literal>
        <returnvalue>120</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>@</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        Absolute value
       </para>
       <para>
        <literal>@ -5.0</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>@</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        绝对值
       </para>
       <para>
        <literal>@ -5.0</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>integral_type</replaceable> <literal>&amp;</literal> <replaceable>integral_type</replaceable>
        <returnvalue><replaceable>integral_type</replaceable></returnvalue>
       </para>
       <para>
        Bitwise AND
       </para>
       <para>
        <literal>91 &amp; 15</literal>
        <returnvalue>11</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>integral_type</replaceable> <literal>&amp;</literal> <replaceable>integral_type</replaceable>
        <returnvalue><replaceable>integral_type</replaceable></returnvalue>
       </para>
       <para>
        按位与(AND)
       </para>
       <para>
        <literal>91 &amp; 15</literal>
        <returnvalue>11</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>integral_type</replaceable> <literal>|</literal> <replaceable>integral_type</replaceable>
        <returnvalue><replaceable>integral_type</replaceable></returnvalue>
       </para>
       <para>
        Bitwise OR
       </para>
       <para>
        <literal>32 | 3</literal>
        <returnvalue>35</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>integral_type</replaceable> <literal>|</literal> <replaceable>integral_type</replaceable>
        <returnvalue><replaceable>integral_type</replaceable></returnvalue>
       </para>
       <para>
        按位或(OR)
       </para>
       <para>
        <literal>32 | 3</literal>
        <returnvalue>35</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>integral_type</replaceable> <literal>#</literal> <replaceable>integral_type</replaceable>
        <returnvalue><replaceable>integral_type</replaceable></returnvalue>
       </para>
       <para>
        Bitwise exclusive OR
       </para>
       <para>
        <literal>17 # 5</literal>
        <returnvalue>20</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>integral_type</replaceable> <literal>#</literal> <replaceable>integral_type</replaceable>
        <returnvalue><replaceable>integral_type</replaceable></returnvalue>
       </para>
       <para>
        按位异或(exclusive OR)
       </para>
       <para>
        <literal>17 # 5</literal>
        <returnvalue>20</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>~</literal> <replaceable>integral_type</replaceable>
        <returnvalue><replaceable>integral_type</replaceable></returnvalue>
       </para>
       <para>
        Bitwise NOT
       </para>
       <para>
        <literal>~1</literal>
        <returnvalue>-2</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>~</literal> <replaceable>integral_type</replaceable>
        <returnvalue><replaceable>integral_type</replaceable></returnvalue>
       </para>
       <para>
        按位求反(NOT)
       </para>
       <para>
        <literal>~1</literal>
        <returnvalue>-2</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>integral_type</replaceable> <literal>&lt;&lt;</literal> <type>integer</type>
        <returnvalue><replaceable>integral_type</replaceable></returnvalue>
       </para>
       <para>
        Bitwise shift left
       </para>
       <para>
        <literal>1 &lt;&lt; 4</literal>
        <returnvalue>16</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>integral_type</replaceable> <literal>&lt;&lt;</literal> <type>integer</type>
        <returnvalue><replaceable>integral_type</replaceable></returnvalue>
       </para>
       <para>
        按位左移
       </para>
       <para>
        <literal>1 &lt;&lt; 4</literal>
        <returnvalue>16</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>integral_type</replaceable> <literal>&gt;&gt;</literal> <type>integer</type>
        <returnvalue><replaceable>integral_type</replaceable></returnvalue>
       </para>
       <para>
        Bitwise shift right
       </para>
       <para>
        <literal>8 &gt;&gt; 2</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>integral_type</replaceable> <literal>&gt;&gt;</literal> <type>integer</type>
        <returnvalue><replaceable>integral_type</replaceable></returnvalue>
       </para>
       <para>
        按位右移
       </para>
       <para>
        <literal>8 &gt;&gt; 2</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="functions-math-func-table"/> shows the available
   mathematical functions.
   Many of these functions are provided in multiple forms with different
   argument types.
   Except where noted, any given form of a function returns the same
   data type as its argument(s); cross-type cases are resolved in the
   same way as explained above for operators.
   The functions working with <type>double precision</type> data are mostly
   implemented on top of the host system's C library; accuracy and behavior in
   boundary cases can therefore vary depending on the host system.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="functions-math-func-table"/> 显示了可用的数学函数。
   许多这样的函数以多种具有不同的参数类型的形式提供。
   除非注明，任何给定形式的函数都返回与其参数相同的数据类型;跨类型情况的解决方法与上述对操作符的解释相同。
   使用<type>double precision</type>数据的函数大多是在主机系统的C库上实现的;
   因此，边界情况下的准确性和行为会因主机系统的区别而不同。
  </para>

   <table id="functions-math-func-table">
<!--==========================orignal english content==========================
    <title>Mathematical Functions</title>
____________________________________________________________________________-->
    <title>数学函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>abs</primary>
        </indexterm>
        <function>abs</function> ( <replaceable>numeric_type</replaceable> )
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        Absolute value
       </para>
       <para>
        <literal>abs(-17.4)</literal>
        <returnvalue>17.4</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>abs</primary>
        </indexterm>
        <function>abs</function> ( <replaceable>numeric_type</replaceable> )
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        绝对值
       </para>
       <para>
        <literal>abs(-17.4)</literal>
        <returnvalue>17.4</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cbrt</primary>
        </indexterm>
        <function>cbrt</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Cube root
       </para>
       <para>
        <literal>cbrt(64.0)</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cbrt</primary>
        </indexterm>
        <function>cbrt</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        立方根
       </para>
       <para>
        <literal>cbrt(64.0)</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ceil</primary>
        </indexterm>
        <function>ceil</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>ceil</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Nearest integer greater than or equal to argument
       </para>
       <para>
        <literal>ceil(42.2)</literal>
        <returnvalue>43</returnvalue>
       </para>
       <para>
        <literal>ceil(-42.8)</literal>
        <returnvalue>-42</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ceil</primary>
        </indexterm>
        <function>ceil</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>ceil</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        大于或等于参数的最接近的整数
       </para>
       <para>
        <literal>ceil(42.2)</literal>
        <returnvalue>43</returnvalue>
       </para>
       <para>
        <literal>ceil(-42.8)</literal>
        <returnvalue>-42</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ceiling</primary>
        </indexterm>
        <function>ceiling</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>ceiling</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Nearest integer greater than or equal to argument (same
        as <function>ceil</function>)
       </para>
       <para>
        <literal>ceiling(95.3)</literal>
        <returnvalue>96</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ceiling</primary>
        </indexterm>
        <function>ceiling</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>ceiling</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        大于或等于参数的最接近的整数 (与 <function>ceil</function> 相同)
       </para>
       <para>
        <literal>ceiling(95.3)</literal>
        <returnvalue>96</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>degrees</primary>
        </indexterm>
        <function>degrees</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Converts radians to degrees
       </para>
       <para>
        <literal>degrees(0.5)</literal>
        <returnvalue>28.64788975654116</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>degrees</primary>
        </indexterm>
        <function>degrees</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        将弧度转换为角度
       </para>
       <para>
        <literal>degrees(0.5)</literal>
        <returnvalue>28.64788975654116</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>div</primary>
        </indexterm>
        <function>div</function> ( <parameter>y</parameter> <type>numeric</type>,
        <parameter>x</parameter> <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        Integer quotient of <parameter>y</parameter>/<parameter>x</parameter>
        (truncates towards zero)
       </para>
       <para>
        <literal>div(9,4)</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>div</primary>
        </indexterm>
        <function>div</function> ( <parameter>y</parameter> <type>numeric</type>,
        <parameter>x</parameter> <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        <parameter>y</parameter>/<parameter>x</parameter> 的整数商（截断为零位）
       </para>
       <para>
        <literal>div(9,4)</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>exp</primary>
        </indexterm>
        <function>exp</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>exp</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Exponential (<literal>e</literal> raised to the given power)
       </para>
       <para>
        <literal>exp(1.0)</literal>
        <returnvalue>2.7182818284590452</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>exp</primary>
        </indexterm>
        <function>exp</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>exp</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        指数 (<literal>e</literal> 的给定次方)
       </para>
       <para>
        <literal>exp(1.0)</literal>
        <returnvalue>2.7182818284590452</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm id="function-factorial">
         <primary>factorial</primary>
        </indexterm>
        <function>factorial</function> ( <type>bigint</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        Factorial
       </para>
       <para>
        <literal>factorial(5)</literal>
        <returnvalue>120</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm id="function-factorial">
         <primary>factorial</primary>
        </indexterm>
        <function>factorial</function> ( <type>bigint</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        阶乘
       </para>
       <para>
        <literal>factorial(5)</literal>
        <returnvalue>120</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>floor</primary>
        </indexterm>
        <function>floor</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>floor</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Nearest integer less than or equal to argument
       </para>
       <para>
        <literal>floor(42.8)</literal>
        <returnvalue>42</returnvalue>
       </para>
       <para>
        <literal>floor(-42.8)</literal>
        <returnvalue>-43</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>floor</primary>
        </indexterm>
        <function>floor</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>floor</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        小于或等于参数的最接近整数
       </para>
       <para>
        <literal>floor(42.8)</literal>
        <returnvalue>42</returnvalue>
       </para>
       <para>
        <literal>floor(-42.8)</literal>
        <returnvalue>-43</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>gcd</primary>
        </indexterm>
        <function>gcd</function> ( <replaceable>numeric_type</replaceable>, <replaceable>numeric_type</replaceable> )
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        Greatest common divisor (the largest positive number that divides both
        inputs with no remainder); returns <literal>0</literal> if both inputs
        are zero; available for <type>integer</type>, <type>bigint</type>,
        and <type>numeric</type>
       </para>
       <para>
        <literal>gcd(1071, 462)</literal>
        <returnvalue>21</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>gcd</primary>
        </indexterm>
        <function>gcd</function> ( <replaceable>numeric_type</replaceable>, <replaceable>numeric_type</replaceable> )
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        最大公约数 (能将两个输入数整除而无余数的最大正数); 如果两个输入为零则返回 <literal>0</literal> ; 适用于 <type>integer</type>, <type>bigint</type>,和 <type>numeric</type>
       </para>
       <para>
        <literal>gcd(1071, 462)</literal>
        <returnvalue>21</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lcm</primary>
        </indexterm>
        <function>lcm</function> ( <replaceable>numeric_type</replaceable>, <replaceable>numeric_type</replaceable> )
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        Least common multiple (the smallest strictly positive number that is
        an integral multiple of both inputs); returns <literal>0</literal> if
        either input is zero; available for <type>integer</type>,
        <type>bigint</type>, and <type>numeric</type>
       </para>
       <para>
        <literal>lcm(1071, 462)</literal>
        <returnvalue>23562</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lcm</primary>
        </indexterm>
        <function>lcm</function> ( <replaceable>numeric_type</replaceable>, <replaceable>numeric_type</replaceable> )
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        最小公倍数(两个输入的整数倍的最小的严格正数)；如果任意一个输入值为零则返回<literal>0</literal>；适用于<type>integer</type>，<type>bigint</type>，和 <type>numeric</type>
       </para>
       <para>
        <literal>lcm(1071, 462)</literal>
        <returnvalue>23562</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ln</primary>
        </indexterm>
        <function>ln</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>ln</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Natural logarithm
       </para>
       <para>
        <literal>ln(2.0)</literal>
        <returnvalue>0.6931471805599453</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ln</primary>
        </indexterm>
        <function>ln</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>ln</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        自然对数
       </para>
       <para>
        <literal>ln(2.0)</literal>
        <returnvalue>0.6931471805599453</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>log</primary>
        </indexterm>
        <function>log</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>log</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Base 10 logarithm
       </para>
       <para>
        <literal>log(100)</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>log</primary>
        </indexterm>
        <function>log</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>log</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        以10为底的对数
       </para>
       <para>
        <literal>log(100)</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>log10</primary>
        </indexterm>
        <function>log10</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>log10</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Base 10 logarithm (same as <function>log</function>)
       </para>
       <para>
        <literal>log10(1000)</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>log10</primary>
        </indexterm>
        <function>log10</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>log10</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        以10为底的对数 (与 <function>log</function> 相同)
       </para>
       <para>
        <literal>log10(1000)</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>log</function> ( <parameter>b</parameter> <type>numeric</type>,
        <parameter>x</parameter> <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        Logarithm of <parameter>x</parameter> to base <parameter>b</parameter>
       </para>
       <para>
       <literal>log(2.0, 64.0)</literal>
       <returnvalue>6.0000000000</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>log</function> ( <parameter>b</parameter> <type>numeric</type>,
        <parameter>x</parameter> <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        以 <parameter>b</parameter> 为底的 <parameter>x</parameter>的对数
       </para>
       <para>
       <literal>log(2.0, 64.0)</literal>
       <returnvalue>6.0000000000</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>min_scale</primary>
        </indexterm>
        <function>min_scale</function> ( <type>numeric</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Minimum scale (number of fractional decimal digits) needed
        to represent the supplied value precisely
       </para>
       <para>
        <literal>min_scale(8.4100)</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>min_scale</primary>
        </indexterm>
        <function>min_scale</function> ( <type>numeric</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        精确表示所提供值所需的最小刻度（小数位数）
       </para>
       <para>
        <literal>min_scale(8.4100)</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>mod</primary>
        </indexterm>
        <function>mod</function> ( <parameter>y</parameter> <replaceable>numeric_type</replaceable>,
        <parameter>x</parameter> <replaceable>numeric_type</replaceable> )
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        Remainder of <parameter>y</parameter>/<parameter>x</parameter>;
        available for <type>smallint</type>, <type>integer</type>,
        <type>bigint</type>, and <type>numeric</type>
       </para>
       <para>
        <literal>mod(9,4)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>mod</primary>
        </indexterm>
        <function>mod</function> ( <parameter>y</parameter> <replaceable>numeric_type</replaceable>,
        <parameter>x</parameter> <replaceable>numeric_type</replaceable> )
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
        <parameter>y</parameter>/<parameter>x</parameter>的余数；
        适用于<type>smallint</type>、<type>integer</type>、<type>bigint</type>、和 <type>numeric</type>
       </para>
       <para>
        <literal>mod(9,4)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pi</primary>
        </indexterm>
        <function>pi</function> (  )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Approximate value of <phrase role="symbol_font">&pi;</phrase>
       </para>
       <para>
        <literal>pi()</literal>
        <returnvalue>3.141592653589793</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pi</primary>
        </indexterm>
        <function>pi</function> (  )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        <phrase role="symbol_font">&pi;</phrase>的近似值
       </para>
       <para>
        <literal>pi()</literal>
        <returnvalue>3.141592653589793</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>power</primary>
        </indexterm>
        <function>power</function> ( <parameter>a</parameter> <type>numeric</type>,
        <parameter>b</parameter> <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>power</function> ( <parameter>a</parameter> <type>double precision</type>,
        <parameter>b</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        <parameter>a</parameter> raised to the power of <parameter>b</parameter>
       </para>
       <para>
        <literal>power(9, 3)</literal>
        <returnvalue>729</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>power</primary>
        </indexterm>
        <function>power</function> ( <parameter>a</parameter> <type>numeric</type>,
        <parameter>b</parameter> <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>power</function> ( <parameter>a</parameter> <type>double precision</type>,
        <parameter>b</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        <parameter>a</parameter>的<parameter>b</parameter>次幂
       </para>
       <para>
        <literal>power(9, 3)</literal>
        <returnvalue>729</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>radians</primary>
        </indexterm>
        <function>radians</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Converts degrees to radians
       </para>
       <para>
        <literal>radians(45.0)</literal>
        <returnvalue>0.7853981633974483</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>radians</primary>
        </indexterm>
        <function>radians</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        将角度转换为弧度
       </para>
       <para>
        <literal>radians(45.0)</literal>
        <returnvalue>0.7853981633974483</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>round</primary>
        </indexterm>
        <function>round</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>round</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Rounds to nearest integer
       </para>
       <para>
        <literal>round(42.4)</literal>
        <returnvalue>42</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>round</primary>
        </indexterm>
        <function>round</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>round</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        四舍五入到最近的整数
       </para>
       <para>
        <literal>round(42.4)</literal>
        <returnvalue>42</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>round</function> ( <parameter>v</parameter> <type>numeric</type>, <parameter>s</parameter> <type>integer</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        Rounds <parameter>v</parameter> to <parameter>s</parameter> decimal
        places
       </para>
       <para>
        <literal>round(42.4382, 2)</literal>
        <returnvalue>42.44</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>round</function> ( <parameter>v</parameter> <type>numeric</type>, <parameter>s</parameter> <type>integer</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        把 <parameter>v</parameter> 四舍五入到 <parameter>s</parameter> 位小数
       </para>
       <para>
        <literal>round(42.4382, 2)</literal>
        <returnvalue>42.44</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>scale</primary>
        </indexterm>
        <function>scale</function> ( <type>numeric</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Scale of the argument (the number of decimal digits in the fractional part)
       </para>
       <para>
        <literal>scale(8.4100)</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>scale</primary>
        </indexterm>
        <function>scale</function> ( <type>numeric</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        参数的刻度（小数点后的位数）
       </para>
       <para>
        <literal>scale(8.4100)</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sign</primary>
        </indexterm>
        <function>sign</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>sign</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Sign of the argument (-1, 0, or +1)
       </para>
       <para>
        <literal>sign(-8.4)</literal>
        <returnvalue>-1</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sign</primary>
        </indexterm>
        <function>sign</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>sign</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        参数的符号 (-1, 0, 或 +1)
       </para>
       <para>
        <literal>sign(-8.4)</literal>
        <returnvalue>-1</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sqrt</primary>
        </indexterm>
         <function>sqrt</function> ( <type>numeric</type> )
         <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
         <function>sqrt</function> ( <type>double precision</type> )
         <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Square root
       </para>
       <para>
        <literal>sqrt(2)</literal>
        <returnvalue>1.4142135623730951</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sqrt</primary>
        </indexterm>
         <function>sqrt</function> ( <type>numeric</type> )
         <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
         <function>sqrt</function> ( <type>double precision</type> )
         <returnvalue>double precision</returnvalue>
       </para>
       <para>
        平方根
       </para>
       <para>
        <literal>sqrt(2)</literal>
        <returnvalue>1.4142135623730951</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>trim_scale</primary>
        </indexterm>
        <function>trim_scale</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        Reduces the value's scale (number of fractional decimal digits) by
        removing trailing zeroes
       </para>
       <para>
        <literal>trim_scale(8.4100)</literal>
        <returnvalue>8.41</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>trim_scale</primary>
        </indexterm>
        <function>trim_scale</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        通过删除尾数部分的零来降低值的刻度(小数位数)
       </para>
       <para>
        <literal>trim_scale(8.4100)</literal>
        <returnvalue>8.41</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>trunc</primary>
        </indexterm>
        <function>trunc</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>trunc</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Truncates to integer (towards zero)
       </para>
       <para>
        <literal>trunc(42.8)</literal>
        <returnvalue>42</returnvalue>
       </para>
       <para>
        <literal>trunc(-42.8)</literal>
        <returnvalue>-42</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>trunc</primary>
        </indexterm>
        <function>trunc</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>trunc</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        截断整数 (向零靠近)
       </para>
       <para>
        <literal>trunc(42.8)</literal>
        <returnvalue>42</returnvalue>
       </para>
       <para>
        <literal>trunc(-42.8)</literal>
        <returnvalue>-42</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>trunc</function> ( <parameter>v</parameter> <type>numeric</type>, <parameter>s</parameter> <type>integer</type> )
       <returnvalue>numeric</returnvalue>
       </para>
       <para>
        Truncates <parameter>v</parameter> to <parameter>s</parameter>
        decimal places
       </para>
       <para>
        <literal>trunc(42.4382, 2)</literal>
        <returnvalue>42.43</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>trunc</function> ( <parameter>v</parameter> <type>numeric</type>, <parameter>s</parameter> <type>integer</type> )
       <returnvalue>numeric</returnvalue>
       </para>
       <para>
        截断 <parameter>v</parameter> 到 <parameter>s</parameter> 位小数位置的数字
       </para>
       <para>
        <literal>trunc(42.4382, 2)</literal>
        <returnvalue>42.43</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>width_bucket</primary>
        </indexterm>
        <function>width_bucket</function> ( <parameter>operand</parameter> <type>numeric</type>, <parameter>low</parameter> <type>numeric</type>, <parameter>high</parameter> <type>numeric</type>, <parameter>count</parameter> <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para role="func_signature">
        <function>width_bucket</function> ( <parameter>operand</parameter> <type>double precision</type>, <parameter>low</parameter> <type>double precision</type>, <parameter>high</parameter> <type>double precision</type>, <parameter>count</parameter> <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the number of the bucket in
        which <parameter>operand</parameter> falls in a histogram
        having <parameter>count</parameter> equal-width buckets spanning the
        range <parameter>low</parameter> to <parameter>high</parameter>.
        Returns <literal>0</literal>
        or <literal><parameter>count</parameter>+1</literal> for an input
        outside that range.
       </para>
       <para>
        <literal>width_bucket(5.35, 0.024, 10.06, 5)</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>width_bucket</primary>
        </indexterm>
        <function>width_bucket</function> ( <parameter>operand</parameter> <type>numeric</type>, <parameter>low</parameter> <type>numeric</type>, <parameter>high</parameter> <type>numeric</type>, <parameter>count</parameter> <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para role="func_signature">
        <function>width_bucket</function> ( <parameter>operand</parameter> <type>double precision</type>, <parameter>low</parameter> <type>double precision</type>, <parameter>high</parameter> <type>double precision</type>, <parameter>count</parameter> <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回包含<parameter>count</parameter>等宽柱的柱状图中<parameter>operand</parameter>所在的柱的编号，范围从<parameter>low</parameter>到<parameter>high</parameter>。
        超出该范围的输入则返回<literal>0</literal>或<literal><parameter>计数</parameter>+1</literal>。
       </para>
       <para>
        <literal>width_bucket(5.35, 0.024, 10.06, 5)</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>width_bucket</function> ( <parameter>operand</parameter> <type>anyelement</type>, <parameter>thresholds</parameter> <type>anyarray</type> )
       <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the number of the bucket in
        which <parameter>operand</parameter> falls given an array listing the
        lower bounds of the buckets.  Returns <literal>0</literal> for an
        input less than the first lower
        bound.  <parameter>operand</parameter> and the array elements can be
        of any type having standard comparison operators.
        The <parameter>thresholds</parameter> array <emphasis>must be
        sorted</emphasis>, smallest first, or unexpected results will be
        obtained.
       </para>
       <para>
        <literal>width_bucket(now(), array['yesterday', 'today', 'tomorrow']::timestamptz[])</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>width_bucket</function> ( <parameter>operand</parameter> <type>anyelement</type>, <parameter>thresholds</parameter> <type>anyarray</type> )
       <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回一个柱号，这个柱是在给定数组中<parameter>operand</parameter>将被分配的柱。
        对于一个低于第一个下界的输入返回<literal>0</literal>。
        <parameter>operand</parameter>和数组元素可以是具有标准比较操作符的任何类型。
        <parameter>thresholds</parameter>数组<emphasis>必须被排好序</emphasis>，最小的排在最前面，否则将会得到意想不到的结果。
       </para>
       <para>
        <literal>width_bucket(now(), array['yesterday', 'today', 'tomorrow']::timestamptz[])</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
  <para>
    <xref linkend="functions-math-random-table"/> shows functions for
    generating random numbers.
  </para>
____________________________________________________________________________-->
  <para>
    <xref linkend="functions-math-random-table"/>展示了用于产生随机数的函数。
  </para>

   <table id="functions-math-random-table">
<!--==========================orignal english content==========================
    <title>Random Functions</title>
____________________________________________________________________________-->
    <title>随机函数</title>

    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>random</primary>
        </indexterm>
        <function>random</function> ( )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Returns a random value in the range 0.0 &lt;= x &lt; 1.0
       </para>
       <para>
        <literal>random()</literal>
        <returnvalue>0.897124072839091</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>random</primary>
        </indexterm>
        <function>random</function> ( )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        返回一个范围 0.0 &lt;= x &lt; 1.0 中的随机值
       </para>
       <para>
        <literal>random()</literal>
        <returnvalue>0.897124072839091</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>setseed</primary>
        </indexterm>
        <function>setseed</function> ( <type>double precision</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Sets the seed for subsequent <literal>random()</literal> calls;
        argument must be between -1.0 and 1.0, inclusive
       </para>
       <para>
        <literal>setseed(0.12345)</literal>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>setseed</primary>
        </indexterm>
        <function>setseed</function> ( <type>double precision</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        为后续的<literal>random()</literal>调用设置种子；参数必须在-1.0和1.0之间，包括边界值
       </para>
       <para>
        <literal>setseed(0.12345)</literal>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
  <para>
   The <function>random()</function> function uses a simple linear
   congruential algorithm.  It is fast but not suitable for cryptographic
   applications; see the <xref linkend="pgcrypto"/> module for a more
   secure alternative.
   If <function>setseed()</function> is called, the series of results of
   subsequent <function>random()</function> calls in the current session
   can be repeated by re-issuing <function>setseed()</function> with the same
   argument.
  </para>
____________________________________________________________________________-->
  <para>
   <function>random()</function>函数使用了一个简单的线性共轭算法。 
   它的速度很快，但不适合于密码学应用；关于更安全的替代方案，请参阅 <xref linkend="pgcrypto"/>模块。 
   如果<function>setseed()</function>被调用，那么当前会话中的一系列后续<function>random()</function>调用的结果能够通过使用相同的参数重新发布<function>setseed()</function>来重复。
   </para>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="functions-math-trig-table"/> shows the
   available trigonometric functions.  Each of these functions comes in
   two variants, one that measures angles in radians and one that
   measures angles in degrees.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="functions-math-trig-table"/>显示了可用的三角函数。
   每一种这样的函数都有两个变体，一个以弧度度量角，另一个以角度度量角。
  </para>

   <table id="functions-math-trig-table">
<!--==========================orignal english content==========================
    <title>Trigonometric Functions</title>
____________________________________________________________________________-->
    <title>三角函数</title>

    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>acos</primary>
        </indexterm>
        <function>acos</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Inverse cosine, result in radians
       </para>
       <para>
        <literal>acos(1)</literal>
        <returnvalue>0</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>acos</primary>
        </indexterm>
        <function>acos</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        反余弦，结果为弧度
       </para>
       <para>
        <literal>acos(1)</literal>
        <returnvalue>0</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>acosd</primary>
        </indexterm>
        <function>acosd</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Inverse cosine, result in degrees
       </para>
       <para>
        <literal>acosd(0.5)</literal>
        <returnvalue>60</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>acosd</primary>
        </indexterm>
        <function>acosd</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        反余弦，结果为度数
       </para>
       <para>
        <literal>acosd(0.5)</literal>
        <returnvalue>60</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>asin</primary>
        </indexterm>
        <function>asin</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Inverse sine, result in radians
       </para>
       <para>
        <literal>asin(1)</literal>
        <returnvalue>1.5707963267948966</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>asin</primary>
        </indexterm>
        <function>asin</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        反正弦，结果为弧度
       </para>
       <para>
        <literal>asin(1)</literal>
        <returnvalue>1.5707963267948966</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>asind</primary>
        </indexterm>
        <function>asind</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Inverse sine, result in degrees
       </para>
       <para>
        <literal>asind(0.5)</literal>
        <returnvalue>30</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>asind</primary>
        </indexterm>
        <function>asind</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        反正弦，结果为度数
       </para>
       <para>
        <literal>asind(0.5)</literal>
        <returnvalue>30</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>atan</primary>
        </indexterm>
        <function>atan</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Inverse tangent, result in radians
       </para>
       <para>
        <literal>atan(1)</literal>
        <returnvalue>0.7853981633974483</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>atan</primary>
        </indexterm>
        <function>atan</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        反正切，结果为弧度
       </para>
       <para>
        <literal>atan(1)</literal>
        <returnvalue>0.7853981633974483</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>atand</primary>
        </indexterm>
        <function>atand</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Inverse tangent, result in degrees
       </para>
       <para>
        <literal>atand(1)</literal>
        <returnvalue>45</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>atand</primary>
        </indexterm>
        <function>atand</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        反正切，结果为度数
       </para>
       <para>
        <literal>atand(1)</literal>
        <returnvalue>45</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>atan2</primary>
        </indexterm>
        <function>atan2</function> ( <parameter>y</parameter> <type>double precision</type>,
        <parameter>x</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Inverse tangent of
        <parameter>y</parameter>/<parameter>x</parameter>,
        result in radians
       </para>
       <para>
        <literal>atan2(1,0)</literal>
        <returnvalue>1.5707963267948966</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>atan2</primary>
        </indexterm>
        <function>atan2</function> ( <parameter>y</parameter> <type>double precision</type>,
        <parameter>x</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        <parameter>y</parameter>/<parameter>x</parameter>的反正切，结果为弧度
       </para>
       <para>
        <literal>atan2(1,0)</literal>
        <returnvalue>1.5707963267948966</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>atan2d</primary>
        </indexterm>
        <function>atan2d</function> ( <parameter>y</parameter> <type>double precision</type>,
        <parameter>x</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Inverse tangent of
        <parameter>y</parameter>/<parameter>x</parameter>,
        result in degrees
       </para>
       <para>
        <literal>atan2d(1,0)</literal>
        <returnvalue>90</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>atan2d</primary>
        </indexterm>
        <function>atan2d</function> ( <parameter>y</parameter> <type>double precision</type>,
        <parameter>x</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        <parameter>y</parameter>/<parameter>x</parameter>的反正切，结果为度数
       </para>
       <para>
        <literal>atan2d(1,0)</literal>
        <returnvalue>90</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cos</primary>
        </indexterm>
        <function>cos</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Cosine, argument in radians
       </para>
       <para>
        <literal>cos(0)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cos</primary>
        </indexterm>
        <function>cos</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        余弦，参数为弧度
       </para>
       <para>
        <literal>cos(0)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cosd</primary>
        </indexterm>
        <function>cosd</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Cosine, argument in degrees
       </para>
       <para>
        <literal>cosd(60)</literal>
        <returnvalue>0.5</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cosd</primary>
        </indexterm>
        <function>cosd</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        余弦，参数为度数
       </para>
       <para>
        <literal>cosd(60)</literal>
        <returnvalue>0.5</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cot</primary>
        </indexterm>
        <function>cot</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Cotangent, argument in radians
       </para>
       <para>
        <literal>cot(0.5)</literal>
        <returnvalue>1.830487721712452</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cot</primary>
        </indexterm>
        <function>cot</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        余切，参数为弧度
       </para>
       <para>
        <literal>cot(0.5)</literal>
        <returnvalue>1.830487721712452</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cotd</primary>
        </indexterm>
        <function>cotd</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Cotangent, argument in degrees
       </para>
       <para>
        <literal>cotd(45)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cotd</primary>
        </indexterm>
        <function>cotd</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        余切，参数为度数
       </para>
       <para>
        <literal>cotd(45)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sin</primary>
        </indexterm>
        <function>sin</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Sine, argument in radians
       </para>
       <para>
        <literal>sin(1)</literal>
        <returnvalue>0.8414709848078965</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sin</primary>
        </indexterm>
        <function>sin</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        正弦，参数为弧度
       </para>
       <para>
        <literal>sin(1)</literal>
        <returnvalue>0.8414709848078965</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sind</primary>
        </indexterm>
        <function>sind</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Sine, argument in degrees
       </para>
       <para>
        <literal>sind(30)</literal>
        <returnvalue>0.5</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sind</primary>
        </indexterm>
        <function>sind</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        正弦，参数为度数
       </para>
       <para>
        <literal>sind(30)</literal>
        <returnvalue>0.5</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>tan</primary>
        </indexterm>
        <function>tan</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Tangent, argument in radians
       </para>
       <para>
        <literal>tan(1)</literal>
        <returnvalue>1.5574077246549023</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>tan</primary>
        </indexterm>
        <function>tan</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        正切，参数为弧度
       </para>
       <para>
        <literal>tan(1)</literal>
        <returnvalue>1.5574077246549023</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>tand</primary>
        </indexterm>
        <function>tand</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Tangent, argument in degrees
       </para>
       <para>
        <literal>tand(45)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>tand</primary>
        </indexterm>
        <function>tand</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        正切，参数为度数
       </para>
       <para>
        <literal>tand(45)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <note>
<!--==========================orignal english content==========================
   <para>
    Another way to work with angles measured in degrees is to use the unit
    transformation functions <literal><function>radians()</function></literal>
    and <literal><function>degrees()</function></literal> shown earlier.
    However, using the degree-based trigonometric functions is preferred,
    as that way avoids round-off error for special cases such
    as <literal>sind(30)</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    另一种使用以角度度量的角的方法是使用早前展示的单位转换函数<literal><function>radians()</function></literal>和<literal><function>degrees()</function></literal>。不过，使用基于角度的三角函数更好，因为这类方法能避免<literal>sind(30)</literal>等特殊情况下的舍入偏差。
   </para>
  </note>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="functions-math-hyp-table"/> shows the
   available hyperbolic functions.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="functions-math-hyp-table"/>显示的是可用的双曲函数。
  </para>

  <table id="functions-math-hyp-table">
<!--==========================orignal english content==========================
    <title>Hyperbolic Functions</title>
____________________________________________________________________________-->
    <title>双曲函数</title>

    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sinh</primary>
        </indexterm>
        <function>sinh</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Hyperbolic sine
       </para>
       <para>
        <literal>sinh(1)</literal>
        <returnvalue>1.1752011936438014</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sinh</primary>
        </indexterm>
        <function>sinh</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        双曲正弦
       </para>
       <para>
        <literal>sinh(1)</literal>
        <returnvalue>1.1752011936438014</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cosh</primary>
        </indexterm>
        <function>cosh</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Hyperbolic cosine
       </para>
       <para>
        <literal>cosh(0)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cosh</primary>
        </indexterm>
        <function>cosh</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        双曲余弦
       </para>
       <para>
        <literal>cosh(0)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>tanh</primary>
        </indexterm>
        <function>tanh</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Hyperbolic tangent
       </para>
       <para>
        <literal>tanh(1)</literal>
        <returnvalue>0.7615941559557649</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>tanh</primary>
        </indexterm>
        <function>tanh</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        双曲切线
       </para>
       <para>
        <literal>tanh(1)</literal>
        <returnvalue>0.7615941559557649</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>asinh</primary>
        </indexterm>
        <function>asinh</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Inverse hyperbolic sine
       </para>
       <para>
        <literal>asinh(1)</literal>
        <returnvalue>0.881373587019543</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>asinh</primary>
        </indexterm>
        <function>asinh</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        反双曲正弦
       </para>
       <para>
        <literal>asinh(1)</literal>
        <returnvalue>0.881373587019543</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>acosh</primary>
        </indexterm>
        <function>acosh</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Inverse hyperbolic cosine
       </para>
       <para>
        <literal>acosh(1)</literal>
        <returnvalue>0</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>acosh</primary>
        </indexterm>
        <function>acosh</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        反双曲余弦
       </para>
       <para>
        <literal>acosh(1)</literal>
        <returnvalue>0</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>atanh</primary>
        </indexterm>
        <function>atanh</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Inverse hyperbolic tangent
       </para>
       <para>
        <literal>atanh(0.5)</literal>
        <returnvalue>0.5493061443340548</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>atanh</primary>
        </indexterm>
        <function>atanh</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        反双曲切线
       </para>
       <para>
        <literal>atanh(0.5)</literal>
        <returnvalue>0.5493061443340548</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  </sect1>


  <sect1 id="functions-string">
<!--==========================orignal english content==========================
   <title>String Functions and Operators</title>
____________________________________________________________________________-->
   <title>字符串函数和操作符</title>

<!--==========================orignal english content==========================
   <para>
    This section describes functions and operators for examining and
    manipulating string values.  Strings in this context include values
    of the types <type>character</type>, <type>character varying</type>,
    and <type>text</type>.  Except where noted, these functions and operators
    are declared to accept and return type <type>text</type>.  They will
    interchangeably accept <type>character varying</type> arguments.
    Values of type <type>character</type> will be converted
    to <type>text</type> before the function or operator is applied, resulting
    in stripping any trailing spaces in the <type>character</type> value.
   </para>
____________________________________________________________________________-->
   <para>
    本节描述了用于检查和操作字符串值的函数和操作符。
    在这个环境中的串包括所有类型<type>character</type>、<type>character varying</type>和<type>text</type>的值。
    除非特别说明，这些函数和操作符声明为接受并返回<type>text</type>类型。
    他们将互换接受<type>character varying</type>参数。
    在应用函数或操作符之前<type>character</type>类型的值将被转换为<type>text</type>，结果删除<type>character</type>值中的任何末尾空格。
   </para>

<!--==========================orignal english content==========================
   <para>
    <acronym>SQL</acronym> defines some string functions that use
    key words, rather than commas, to separate
    arguments.  Details are in
    <xref linkend="functions-string-sql"/>.
    <productname>PostgreSQL</productname> also provides versions of these functions
    that use the regular function invocation syntax
    (see <xref linkend="functions-string-other"/>).
   </para>
____________________________________________________________________________-->
   <para>
    <acronym>SQL</acronym>定义了一些字符串函数，它们使用关键字，而不是逗号来分隔参数。详情请见<xref linkend="functions-string-sql"/>，<productname>PostgreSQL</productname>也提供了这些函数使用正常函数调用语法的版本（见<xref linkend="functions-string-other"/>）。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     Before <productname>PostgreSQL</productname> 8.3, these functions would
     silently accept values of several non-string data types as well, due to
     the presence of implicit coercions from those data types to
     <type>text</type>.  Those coercions have been removed because they frequently
     caused surprising behaviors.  However, the string concatenation operator
     (<literal>||</literal>) still accepts non-string input, so long as at least one
     input is of a string type, as shown in <xref
     linkend="functions-string-sql"/>.  For other cases, insert an explicit
     coercion to <type>text</type> if you need to duplicate the previous behavior.
    </para>
____________________________________________________________________________-->
    <para>
     由于存在从那些数据类型到<type>text</type>的隐式强制措施，在<productname>PostgreSQL</productname> 8.3之前，这些函数也可以接受多种非字符串数据类型。这些强制措施在目前的版本中已经被删除，因为它们常常导致令人惊讶的行为。不过，字符串串接操作符（<literal>||</literal>）仍然接受非字符串输入，只要至少一个输入是一种字符串类型，如<xref linkend="functions-string-sql"/>所示。对于其他情况，如果你需要复制之前的行为，可以为<type>text</type>插入一个显式强制措施。
    </para>
   </note>

   <table id="functions-string-sql">
<!--==========================orignal english content==========================
    <title><acronym>SQL</acronym> String Functions and Operators</title>
____________________________________________________________________________-->
    <title><acronym>SQL</acronym>字符串函数和操作符</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function/Operator
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数/操作符
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>character string</primary>
         <secondary>concatenation</secondary>
        </indexterm>
        <type>text</type> <literal>||</literal> <type>text</type>
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Concatenates the two strings.
       </para>
       <para>
        <literal>'Post' || 'greSQL'</literal>
        <returnvalue>PostgreSQL</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>character string</primary>
         <secondary>concatenation</secondary>
        </indexterm>
        <type>text</type> <literal>||</literal> <type>text</type>
        <returnvalue>text</returnvalue>
       </para>
       <para>
        连接两个字符串。
       </para>
       <para>
        <literal>'Post' || 'greSQL'</literal>
        <returnvalue>PostgreSQL</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>||</literal> <type>anynonarray</type>
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <type>anynonarray</type> <literal>||</literal> <type>text</type>
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts the non-string input to text, then concatenates the two
        strings.  (The non-string input cannot be of an array type, because
        that would create ambiguity with the array <literal>||</literal>
        operators.  If you want to concatenate an array's text equivalent,
        cast it to <type>text</type> explicitly.)
       </para>
       <para>
        <literal>'Value: ' || 42</literal>
        <returnvalue>Value: 42</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>||</literal> <type>anynonarray</type>
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <type>anynonarray</type> <literal>||</literal> <type>text</type>
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将非字符串输入转换为文本，然后将两个字符串串联在一起。
        （非字符串输入不能为数组类型，因为这将在<literal>||</literal>操作符的数组中造成歧义。如果你想连接一个数组的文本相等的，请显式地将其转换为<type>text</type> 。）
       </para>
       <para>
        <literal>'Value: ' || 42</literal>
        <returnvalue>Value: 42</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>normalized</primary>
        </indexterm>
        <indexterm>
         <primary>Unicode normalization</primary>
        </indexterm>
         <type>text</type> <literal>IS</literal> <optional><literal>NOT</literal></optional> <optional><parameter>form</parameter></optional> <literal>NORMALIZED</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Checks whether the string is in the specified Unicode normalization
        form.  The optional <parameter>form</parameter> key word specifies the
        form: <literal>NFC</literal> (the default), <literal>NFD</literal>,
        <literal>NFKC</literal>, or <literal>NFKD</literal>.  This expression can
        only be used when the server encoding is <literal>UTF8</literal>.  Note
        that checking for normalization using this expression is often faster
        than normalizing possibly already normalized strings.
       </para>
       <para>
        <literal>U&amp;'\0061\0308bc' IS NFD NORMALIZED</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>normalized</primary>
        </indexterm>
        <indexterm>
         <primary>Unicode normalization</primary>
        </indexterm>
         <type>text</type> <literal>IS</literal> <optional><literal>NOT</literal></optional> <optional><parameter>form</parameter></optional> <literal>NORMALIZED</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        检查字符串是否在指定的 Unicode 规范化表单中。
        可选的<parameter>form</parameter>关键词指定表单：<literal>NFC</literal> (默认的), <literal>NFD</literal>, <literal>NFKC</literal>, 或 <literal>NFKD</literal>。 
        只有在服务器编码为<literal>UTF8</literal>时，才能使用此表达式。
        请注意，使用这个表达式检查规范化通常比规范化可能已经规范化的字符串要快。
       </para>
       <para>
        <literal>U&amp;'\0061\0308bc' IS NFD NORMALIZED</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bit_length</primary>
        </indexterm>
        <function>bit_length</function> ( <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns number of bits in the string (8
        times the <function>octet_length</function>).
       </para>
       <para>
        <literal>bit_length('jose')</literal>
        <returnvalue>32</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bit_length</primary>
        </indexterm>
        <function>bit_length</function> ( <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回字符串中的位数(8倍于<function>octet_length</function>)。
       </para>
       <para>
        <literal>bit_length('jose')</literal>
        <returnvalue>32</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>char_length</primary>
        </indexterm>
        <indexterm>
         <primary>character string</primary>
         <secondary>length</secondary>
        </indexterm>
        <indexterm>
         <primary>length</primary>
         <secondary sortas="character string">of a character string</secondary>
         <see>character string, length</see>
        </indexterm>
        <function>char_length</function> ( <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>character_length</primary>
        </indexterm>
        <function>character_length</function> ( <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns number of characters in the string.
       </para>
       <para>
        <literal>char_length('jos&eacute;')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>char_length</primary>
        </indexterm>
        <indexterm>
         <primary>character string</primary>
         <secondary>length</secondary>
        </indexterm>
        <indexterm>
         <primary>length</primary>
         <secondary sortas="character string">of a character string</secondary>
         <see>character string, length</see>
        </indexterm>
        <function>char_length</function> ( <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>character_length</primary>
        </indexterm>
        <function>character_length</function> ( <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回字符串中的字符数。
       </para>
       <para>
        <literal>char_length('jos&eacute;')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lower</primary>
        </indexterm>
        <function>lower</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts the string to all lower case, according to the rules of the
        database's locale.
       </para>
       <para>
        <literal>lower('TOM')</literal>
        <returnvalue>tom</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lower</primary>
        </indexterm>
        <function>lower</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        根据数据库的语言环境规则，将字符串转换为全部小写。
       </para>
       <para>
        <literal>lower('TOM')</literal>
        <returnvalue>tom</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>normalize</primary>
        </indexterm>
        <indexterm>
         <primary>Unicode normalization</primary>
        </indexterm>
        <function>normalize</function> ( <type>text</type>
        <optional>, <parameter>form</parameter> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts the string to the specified Unicode
        normalization form.  The optional <parameter>form</parameter> key word
        specifies the form: <literal>NFC</literal> (the default),
        <literal>NFD</literal>, <literal>NFKC</literal>, or
        <literal>NFKD</literal>.  This function can only be used when the
        server encoding is <literal>UTF8</literal>.
       </para>
       <para>
        <literal>normalize(U&amp;'\0061\0308bc', NFC)</literal>
        <returnvalue>U&amp;'\00E4bc'</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>normalize</primary>
        </indexterm>
        <indexterm>
         <primary>Unicode normalization</primary>
        </indexterm>
        <function>normalize</function> ( <type>text</type>
        <optional>, <parameter>form</parameter> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将字符串转换为指定的Unicode规范化形式。
        可选的<parameter>form</parameter>关键字指定了如下形式:<literal>NFC</literal> (the default)，<literal>NFD</literal>， <literal>NFKC</literal>，或<literal>NFKD</literal>。
        该函数只能在服务器编码为<literal>UTF8</literal>时使用。
       </para>
       <para>
        <literal>normalize(U&amp;'\0061\0308bc', NFC)</literal>
        <returnvalue>U&amp;'\00E4bc'</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>octet_length</primary>
        </indexterm>
        <function>octet_length</function> ( <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns number of bytes in the string.
       </para>
       <para>
        <literal>octet_length('jos&eacute;')</literal>
        <returnvalue>5</returnvalue> (if server encoding is UTF8)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>octet_length</primary>
        </indexterm>
        <function>octet_length</function> ( <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回字符串的字节数。
       </para>
       <para>
        <literal>octet_length('jos&eacute;')</literal>
        <returnvalue>5</returnvalue> (if server encoding is UTF8)
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>octet_length</primary>
        </indexterm>
        <function>octet_length</function> ( <type>character</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns number of bytes in the string.  Since this version of the
        function accepts type <type>character</type> directly, it will not
        strip trailing spaces.
       </para>
       <para>
        <literal>octet_length('abc '::character(4))</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>octet_length</primary>
        </indexterm>
        <function>octet_length</function> ( <type>character</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回字符串中的字节数。 由于此版本的函数直接接受<type>character</type>类型，它不会剥离尾随空格。
       </para>
       <para>
        <literal>octet_length('abc '::character(4))</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>overlay</primary>
        </indexterm>
        <function>overlay</function> ( <parameter>string</parameter> <type>text</type> <literal>PLACING</literal> <parameter>newsubstring</parameter> <type>text</type> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Replaces the substring of <parameter>string</parameter> that starts at
        the <parameter>start</parameter>'th character and extends
        for <parameter>count</parameter> characters
        with <parameter>newsubstring</parameter>.
        If <parameter>count</parameter> is omitted, it defaults to the length
        of <parameter>newsubstring</parameter>.
       </para>
       <para>
        <literal>overlay('Txxxxas' placing 'hom' from 2 for 4)</literal>
        <returnvalue>Thomas</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>overlay</primary>
        </indexterm>
        <function>overlay</function> ( <parameter>string</parameter> <type>text</type> <literal>PLACING</literal> <parameter>newsubstring</parameter> <type>text</type> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        替换<parameter>string</parameter>从<parameter>start</parameter>字符开始的子串，并用<parameter>newsubstring</parameter>扩展到<parameter>count</parameter>字符。
        如果省略了<parameter>count</parameter>，则默认为<parameter>newsubstring</parameter>的长度。
       </para>
       <para>
        <literal>overlay('Txxxxas' placing 'hom' from 2 for 4)</literal>
        <returnvalue>Thomas</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>position</primary>
        </indexterm>
        <function>position</function> ( <parameter>substring</parameter> <type>text</type> <literal>IN</literal> <parameter>string</parameter> <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns starting index of specified <parameter>substring</parameter>
        within <parameter>string</parameter>, or zero if it's not present.
       </para>
       <para>
        <literal>position('om' in 'Thomas')</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>position</primary>
        </indexterm>
        <function>position</function> ( <parameter>substring</parameter> <type>text</type> <literal>IN</literal> <parameter>string</parameter> <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回指定的<parameter>substring</parameter>在<parameter>string</parameter>起始索引，如果不存在则返回零，。
       </para>
       <para>
        <literal>position('om' in 'Thomas')</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>substring</primary>
        </indexterm>
        <function>substring</function> ( <parameter>string</parameter> <type>text</type> <optional> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> </optional> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Extracts the substring of <parameter>string</parameter> starting at
        the <parameter>start</parameter>'th character if that is specified,
        and stopping after <parameter>count</parameter> characters if that is
        specified.  Provide at least one of <parameter>start</parameter>
        and <parameter>count</parameter>.
       </para>
       <para>
        <literal>substring('Thomas' from 2 for 3)</literal>
        <returnvalue>hom</returnvalue>
       </para>
       <para>
        <literal>substring('Thomas' from 3)</literal>
        <returnvalue>omas</returnvalue>
       </para>
       <para>
        <literal>substring('Thomas' for 2)</literal>
        <returnvalue>Th</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>substring</primary>
        </indexterm>
        <function>substring</function> ( <parameter>string</parameter> <type>text</type> <optional> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> </optional> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        如果已指定，提取<parameter>string</parameter>从<parameter>start</parameter>字符开始的子串，
        并且在<parameter>count</parameter>字符后停止。如果已指定的话。 
        提供至少一个<parameter>start</parameter>和<parameter>count</parameter>中的至少一个。
       </para>
       <para>
        <literal>substring('Thomas' from 2 for 3)</literal>
        <returnvalue>hom</returnvalue>
       </para>
       <para>
        <literal>substring('Thomas' from 3)</literal>
        <returnvalue>omas</returnvalue>
       </para>
       <para>
        <literal>substring('Thomas' for 2)</literal>
        <returnvalue>Th</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>substring</function> ( <parameter>string</parameter> <type>text</type> <literal>FROM</literal> <parameter>pattern</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Extracts substring matching POSIX regular expression; see
        <xref linkend="functions-posix-regexp"/>.
       </para>
       <para>
        <literal>substring('Thomas' from '...$')</literal>
        <returnvalue>mas</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>substring</function> ( <parameter>string</parameter> <type>text</type> <literal>FROM</literal> <parameter>pattern</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        提取匹配POSIX正则表达式的子字符串; 参见 <xref linkend="functions-posix-regexp"/>。
       </para>
       <para>
        <literal>substring('Thomas' from '...$')</literal>
        <returnvalue>mas</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>substring</function> ( <parameter>string</parameter> <type>text</type> <literal>FROM</literal> <parameter>pattern</parameter> <type>text</type> <literal>FOR</literal> <parameter>escape</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Extracts substring matching <acronym>SQL</acronym> regular expression;
        see <xref linkend="functions-similarto-regexp"/>.
       </para>
       <para>
        <literal>substring('Thomas' from '%#"o_a#"_' for '#')</literal>
        <returnvalue>oma</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>substring</function> ( <parameter>string</parameter> <type>text</type> <literal>FROM</literal> <parameter>pattern</parameter> <type>text</type> <literal>FOR</literal> <parameter>escape</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        提取匹配 <acronym>SQL</acronym> 正则表达式的字串；参见 <xref linkend="functions-similarto-regexp"/>。
       </para>
       <para>
        <literal>substring('Thomas' from '%#"o_a#"_' for '#')</literal>
        <returnvalue>oma</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>trim</primary>
        </indexterm>
        <function>trim</function> ( <optional> <literal>LEADING</literal> | <literal>TRAILING</literal> | <literal>BOTH</literal> </optional>
        <optional> <parameter>characters</parameter> <type>text</type> </optional> <literal>FROM</literal>
        <parameter>string</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Removes the longest string containing only characters in
        <parameter>characters</parameter> (a space by default) from the
        start, end, or both ends (<literal>BOTH</literal> is the default)
        of <parameter>string</parameter>.
       </para>
       <para>
        <literal>trim(both 'xyz' from 'yxTomxx')</literal>
        <returnvalue>Tom</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>trim</primary>
        </indexterm>
        <function>trim</function> ( <optional> <literal>LEADING</literal> | <literal>TRAILING</literal> | <literal>BOTH</literal> </optional>
        <optional> <parameter>characters</parameter> <type>text</type> </optional> <literal>FROM</literal>
        <parameter>string</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        从<parameter>string</parameter>的开始、末端或两端(默认为<literal>BOTH</literal> )移除仅包含<parameter>characters</parameter>(默认为空格)字符的最长字符串。
       </para>
       <para>
        <literal>trim(both 'xyz' from 'yxTomxx')</literal>
        <returnvalue>Tom</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>trim</function> ( <optional> <literal>LEADING</literal> | <literal>TRAILING</literal> | <literal>BOTH</literal> </optional> <optional> <literal>FROM</literal> </optional>
        <parameter>string</parameter> <type>text</type> <optional>,
        <parameter>characters</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        This is a non-standard syntax for <function>trim()</function>.
       </para>
       <para>
        <literal>trim(both from 'yxTomxx', 'xyz')</literal>
        <returnvalue>Tom</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>trim</function> ( <optional> <literal>LEADING</literal> | <literal>TRAILING</literal> | <literal>BOTH</literal> </optional> <optional> <literal>FROM</literal> </optional>
        <parameter>string</parameter> <type>text</type> <optional>,
        <parameter>characters</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        这是一个非标准的<function>trim()</function>语法。
       </para>
       <para>
        <literal>trim(both from 'yxTomxx', 'xyz')</literal>
        <returnvalue>Tom</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>upper</primary>
        </indexterm>
        <function>upper</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts the string to all upper case, according to the rules of the
        database's locale.
       </para>
       <para>
        <literal>upper('tom')</literal>
        <returnvalue>TOM</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>upper</primary>
        </indexterm>
        <function>upper</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        根据数据库的定位规则，将字符串转换为所有大写。
       </para>
       <para>
        <literal>upper('tom')</literal>
        <returnvalue>TOM</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    Additional string manipulation functions are available and are
    listed in <xref linkend="functions-string-other"/>.  Some of them are used internally to implement the
    <acronym>SQL</acronym>-standard string functions listed in <xref linkend="functions-string-sql"/>.
   </para>
____________________________________________________________________________-->
   <para>
    还有额外的串操作函数可以用，它们在<xref linkend="functions-string-other"/>中列出。它们有些在内部用于实现<xref linkend="functions-string-sql"/>列出的<acronym>SQL</acronym>标准字符串函数。
   </para>

   <table id="functions-string-other">
<!--==========================orignal english content==========================
    <title>Other String Functions</title>
____________________________________________________________________________-->
    <title>其他字符串函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ascii</primary>
        </indexterm>
        <function>ascii</function> ( <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the numeric code of the first character of the argument.
        In <acronym>UTF8</acronym> encoding, returns the Unicode code point
        of the character.  In other multibyte encodings, the argument must
        be an <acronym>ASCII</acronym> character.
       </para>
       <para>
        <literal>ascii('x')</literal>
        <returnvalue>120</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ascii</primary>
        </indexterm>
        <function>ascii</function> ( <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回参数的第一个字符的数字代码。在<acronym>UTF8</acronym>编码中，返回该字符的Unicode代码点。
        在其他多字节编码中，该参数必须是一个<acronym>ASCII</acronym>字符。
       </para>
       <para>
        <literal>ascii('x')</literal>
        <returnvalue>120</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>btrim</primary>
        </indexterm>
        <function>btrim</function> ( <parameter>string</parameter> <type>text</type>
        <optional>, <parameter>characters</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Removes the longest string containing only characters
        in <parameter>characters</parameter> (a space by default)
        from the start and end of <parameter>string</parameter>.
       </para>
       <para>
        <literal>btrim('xyxtrimyyx', 'xyz')</literal>
        <returnvalue>trim</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>btrim</primary>
        </indexterm>
        <function>btrim</function> ( <parameter>string</parameter> <type>text</type>
        <optional>, <parameter>characters</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        从<parameter>string</parameter>的开头或结尾删除最长的只包含<parameter>characters</parameter>（默认是一个空格）的字符串
       </para>
       <para>
        <literal>btrim('xyxtrimyyx', 'xyz')</literal>
        <returnvalue>trim</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>chr</primary>
        </indexterm>
        <function>chr</function> ( <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the character with the given code. In <acronym>UTF8</acronym>
        encoding the argument is treated as a Unicode code point. In other
        multibyte encodings the argument must designate
        an <acronym>ASCII</acronym> character.  <literal>chr(0)</literal> is
        disallowed because text data types cannot store that character.
      </para>
      <para>
        <literal>chr(65)</literal>
        <returnvalue>A</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>chr</primary>
        </indexterm>
        <function>chr</function> ( <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回给定代码的字符。在<acronym>UTF8</acronym>编码中该参数被视作一个Unicode代码点。
        在其他多字节编码中该参数必须指定一个<acronym>ASCII</acronym>字符。
        <literal>chr(0)</literal> 字符不被允许，因为文本数据类型不能存储这种字符。
      </para>
      <para>
        <literal>chr(65)</literal>
        <returnvalue>A</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>concat</primary>
        </indexterm>
        <function>concat</function> ( <parameter>val1</parameter> <type>"any"</type>
         [, <parameter>val2</parameter> <type>"any"</type> [, ...] ] )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Concatenates the text representations of all the arguments.
        NULL arguments are ignored.
       </para>
       <para>
        <literal>concat('abcde', 2, NULL, 22)</literal>
        <returnvalue>abcde222</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>concat</primary>
        </indexterm>
        <function>concat</function> ( <parameter>val1</parameter> <type>"any"</type>
         [, <parameter>val2</parameter> <type>"any"</type> [, ...] ] )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        连接所有参数的文本表示。空参数被忽略。
       </para>
       <para>
        <literal>concat('abcde', 2, NULL, 22)</literal>
        <returnvalue>abcde222</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>concat_ws</primary>
        </indexterm>
        <function>concat_ws</function> ( <parameter>sep</parameter> <type>text</type>,
        <parameter>val1</parameter> <type>"any"</type>
        [, <parameter>val2</parameter> <type>"any"</type> [, ...] ] )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Concatenates all but the first argument, with separators. The first
        argument is used as the separator string, and should not be NULL.
        Other NULL arguments are ignored.
       </para>
       <para>
        <literal>concat_ws(',', 'abcde', 2, NULL, 22)</literal>
        <returnvalue>abcde,2,22</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>concat_ws</primary>
        </indexterm>
        <function>concat_ws</function> ( <parameter>sep</parameter> <type>text</type>,
        <parameter>val1</parameter> <type>"any"</type>
        [, <parameter>val2</parameter> <type>"any"</type> [, ...] ] )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        用分隔符连接除第一个参数外的所有参数。第一个参数用作分隔符字符串，不应为NULL。其他NULL参数将被忽略。
       </para>
       <para>
        <literal>concat_ws(',', 'abcde', 2, NULL, 22)</literal>
        <returnvalue>abcde,2,22</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>format</primary>
        </indexterm>
        <function>format</function> ( <parameter>formatstr</parameter> <type>text</type>
        [, <parameter>formatarg</parameter> <type>"any"</type> [, ...] ] )
        <returnvalue>text</returnvalue>
       </para>
       <para>
         Formats arguments according to a format string;
         see <xref linkend="functions-string-format"/>.
         This function is similar to the C function <function>sprintf</function>.
       </para>
       <para>
        <literal>format('Hello %s, %1$s', 'World')</literal>
        <returnvalue>Hello World, World</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>format</primary>
        </indexterm>
        <function>format</function> ( <parameter>formatstr</parameter> <type>text</type>
        [, <parameter>formatarg</parameter> <type>"any"</type> [, ...] ] )
        <returnvalue>text</returnvalue>
       </para>
       <para>
         根据格式字符串对参数进行格式化；参见 <xref linkend="functions-string-format"/>。
         这个函数类似于C函数 <function>sprintf</function>。
       </para>
       <para>
        <literal>format('Hello %s, %1$s', 'World')</literal>
        <returnvalue>Hello World, World</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>initcap</primary>
        </indexterm>
        <function>initcap</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts the first letter of each word to upper case and the
        rest to lower case. Words are sequences of alphanumeric
        characters separated by non-alphanumeric characters.
       </para>
       <para>
        <literal>initcap('hi THOMAS')</literal>
        <returnvalue>Hi Thomas</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>initcap</primary>
        </indexterm>
        <function>initcap</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将每个单词的第一个字母转换为大写，其余字母转换为小写。单词是由非字母数字字符分隔的字母数字字符序列。
       </para>
       <para>
        <literal>initcap('hi THOMAS')</literal>
        <returnvalue>Hi Thomas</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>left</primary>
        </indexterm>
        <function>left</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>n</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns first <parameter>n</parameter> characters in the
        string, or when <parameter>n</parameter> is negative, returns
        all but last |<parameter>n</parameter>| characters.
       </para>
       <para>
        <literal>left('abcde', 2)</literal>
        <returnvalue>ab</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>left</primary>
        </indexterm>
        <function>left</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>n</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        以字符串返回第一个 <parameter>n</parameter> 字符，或在 <parameter>n</parameter> 为负时, 返回最后 |<parameter>n</parameter>| 个字符之外的全部字符。
       </para>
       <para>
        <literal>left('abcde', 2)</literal>
        <returnvalue>ab</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>length</primary>
        </indexterm>
        <function>length</function> ( <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the number of characters in the string.
       </para>
       <para>
        <literal>length('jose')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>length</primary>
        </indexterm>
        <function>length</function> ( <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回字符串中的字符数。
       </para>
       <para>
        <literal>length('jose')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lpad</primary>
        </indexterm>
        <function>lpad</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>length</parameter> <type>integer</type>
        <optional>, <parameter>fill</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Extends the <parameter>string</parameter> to length
        <parameter>length</parameter> by prepending the characters
        <parameter>fill</parameter> (a space by default).  If the
        <parameter>string</parameter> is already longer than
        <parameter>length</parameter> then it is truncated (on the right).
       </para>
       <para>
        <literal>lpad('hi', 5, 'xy')</literal>
        <returnvalue>xyxhi</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lpad</primary>
        </indexterm>
        <function>lpad</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>length</parameter> <type>integer</type>
        <optional>, <parameter>fill</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将<parameter>string</parameter>扩展为长度<parameter>length</parameter>，通过前置字符<parameter>fill</parameter>（默认空格）。 
        如果<parameter>string</parameter>已经超过<parameter>length</parameter>那么它将被截断（在右侧）。
       </para>
       <para>
        <literal>lpad('hi', 5, 'xy')</literal>
        <returnvalue>xyxhi</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ltrim</primary>
        </indexterm>
        <function>ltrim</function> ( <parameter>string</parameter> <type>text</type>
        <optional>, <parameter>characters</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Removes the longest string containing only characters in
        <parameter>characters</parameter> (a space by default) from the start of
        <parameter>string</parameter>.
       </para>
       <para>
        <literal>ltrim('zzzytest', 'xyz')</literal>
        <returnvalue>test</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ltrim</primary>
        </indexterm>
        <function>ltrim</function> ( <parameter>string</parameter> <type>text</type>
        <optional>, <parameter>characters</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        从<parameter>string</parameter>开始删除包含<parameter>characters</parameter>（默认空格）中仅包含字符的最长字符串。
       </para>
       <para>
        <literal>ltrim('zzzytest', 'xyz')</literal>
        <returnvalue>test</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>md5</primary>
        </indexterm>
        <function>md5</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Computes the MD5 <link linkend="functions-hash-note">hash</link> of
        the argument, with the result written in hexadecimal.
       </para>
       <para>
        <literal>md5('abc')</literal>
        <returnvalue>900150983cd24fb0&zwsp;d6963f7d28e17f72</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>md5</primary>
        </indexterm>
        <function>md5</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        计算参数的 MD5 <link linkend="functions-hash-note">hash</link> ，结果以十六进制形式写入。
       </para>
       <para>
        <literal>md5('abc')</literal>
        <returnvalue>900150983cd24fb0&zwsp;d6963f7d28e17f72</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>parse_ident</primary>
        </indexterm>
        <function>parse_ident</function> ( <parameter>qualified_identifier</parameter> <type>text</type>
        [, <parameter>strict_mode</parameter> <type>boolean</type> <literal>DEFAULT</literal> <literal>true</literal> ] )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
        Splits <parameter>qualified_identifier</parameter> into an array of
        identifiers, removing any quoting of individual identifiers.  By
        default, extra characters after the last identifier are considered an
        error; but if the second parameter is <literal>false</literal>, then such
        extra characters are ignored. (This behavior is useful for parsing
        names for objects like functions.) Note that this function does not
        truncate over-length identifiers. If you want truncation you can cast
        the result to <type>name[]</type>.
       </para>
       <para>
        <literal>parse_ident('"SomeSchema".someTable')</literal>
        <returnvalue>{SomeSchema,sometable}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>parse_ident</primary>
        </indexterm>
        <function>parse_ident</function> ( <parameter>qualified_identifier</parameter> <type>text</type>
        [, <parameter>strict_mode</parameter> <type>boolean</type> <literal>DEFAULT</literal> <literal>true</literal> ] )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
        将<parameter>qualified_identifier</parameter>拆分为一个标识符数组，删除单个标识符的任何引用。 
        默认情况下，最后一个标识符之后的额外字符被视为错误；但是，如果第二个参数为<literal>false</literal>，则忽略这些额外的字符。
        （这种行为对于解析类似函数的对象的名称有作用。）
        请注意，此函数不会截断超长标识符。如果你想截断，你可以把结果给到<type>name[]</type>。
       </para>
       <para>
        <literal>parse_ident('"SomeSchema".someTable')</literal>
        <returnvalue>{SomeSchema,sometable}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_client_encoding</primary>
        </indexterm>
        <function>pg_client_encoding</function> ( )
        <returnvalue>name</returnvalue>
       </para>
       <para>
        Returns current client encoding name.
       </para>
       <para>
        <literal>pg_client_encoding()</literal>
        <returnvalue>UTF8</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_client_encoding</primary>
        </indexterm>
        <function>pg_client_encoding</function> ( )
        <returnvalue>name</returnvalue>
       </para>
       <para>
        返回当前客户端编码名称。
       </para>
       <para>
        <literal>pg_client_encoding()</literal>
        <returnvalue>UTF8</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>quote_ident</primary>
        </indexterm>
        <function>quote_ident</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the given string suitably quoted to be used as an identifier
        in an <acronym>SQL</acronym> statement string.
        Quotes are added only if necessary (i.e., if the string contains
        non-identifier characters or would be case-folded).
        Embedded quotes are properly doubled.
        See also <xref linkend="plpgsql-quote-literal-example"/>.
       </para>
       <para>
        <literal>quote_ident('Foo bar')</literal>
        <returnvalue>"Foo bar"</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>quote_ident</primary>
        </indexterm>
        <function>quote_ident</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回适合引用的给定字符串，作为<acronym>SQL</acronym>语句字符串中的标识符。
        只有在必要的情况下才添加引号(例如，如果字符串包含非标识符字符或将被大小写折叠)。
        嵌入的引号被适当地加双引号。参见<xref linkend="plpgsql-quote-literal-example"/>。
       </para>
       <para>
        <literal>quote_ident('Foo bar')</literal>
        <returnvalue>"Foo bar"</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>quote_literal</primary>
        </indexterm>
        <function>quote_literal</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the given string suitably quoted to be used as a string literal
        in an <acronym>SQL</acronym> statement string.
        Embedded single-quotes and backslashes are properly doubled.
        Note that <function>quote_literal</function> returns null on null
        input; if the argument might be null,
        <function>quote_nullable</function> is often more suitable.
        See also <xref linkend="plpgsql-quote-literal-example"/>.
       </para>
       <para>
        <literal>quote_literal(E'O\'Reilly')</literal>
        <returnvalue>'O''Reilly'</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>quote_literal</primary>
        </indexterm>
        <function>quote_literal</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回在<acronym>SQL</acronym>语句字符串中适当引用的给定字符串，用作字符串文字使用。
        嵌入式单引号和反斜线适当的翻倍(转双引号或双斜线)。
        请注意，<function>quote_literal</function>返回无效输入；如果这个参数可能为空，<function>quote_nullable</function>通常更合适。另请参阅<xref linkend="plpgsql-quote-literal-example"/>。
       </para>
       <para>
        <literal>quote_literal(E'O\'Reilly')</literal>
        <returnvalue>'O''Reilly'</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>quote_literal</function> ( <type>anyelement</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts the given value to text and then quotes it as a literal.
        Embedded single-quotes and backslashes are properly doubled.
       </para>
       <para>
        <literal>quote_literal(42.5)</literal>
        <returnvalue>'42.5'</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>quote_literal</function> ( <type>anyelement</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将给定的值转换为文本，然后将其作为字面量引用。
        内嵌的单引号和反斜杠被适当地翻倍。
       </para>
       <para>
        <literal>quote_literal(42.5)</literal>
        <returnvalue>'42.5'</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>quote_nullable</primary>
        </indexterm>
        <function>quote_nullable</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the given string suitably quoted to be used as a string literal
        in an <acronym>SQL</acronym> statement string; or, if the argument
        is null, returns <literal>NULL</literal>.
        Embedded single-quotes and backslashes are properly doubled.
        See also <xref linkend="plpgsql-quote-literal-example"/>.
       </para>
       <para>
        <literal>quote_nullable(NULL)</literal>
        <returnvalue>NULL</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>quote_nullable</primary>
        </indexterm>
        <function>quote_nullable</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回在<acronym>SQL</acronym>语句字符串中适当引用的给定字符串文字;或者，如果参数为null，则返回<literal>NULL</literal>。
        内嵌的单引号和反斜杠被适当地翻倍。参见<xref linkend="plpgsql-quote-literal-example"/>。
       </para>
       <para>
        <literal>quote_nullable(NULL)</literal>
        <returnvalue>NULL</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>quote_nullable</function> ( <type>anyelement</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts the given value to text and then quotes it as a literal;
        or, if the argument is null, returns <literal>NULL</literal>.
        Embedded single-quotes and backslashes are properly doubled.
       </para>
       <para>
        <literal>quote_nullable(42.5)</literal>
        <returnvalue>'42.5'</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>quote_nullable</function> ( <type>anyelement</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将给定值转换为文本，然后将其作为字面量引用；或者，如果参数为null，则返回<literal>NULL</literal>。
        内嵌的单引号和反斜杠被适当地翻倍。
       </para>
       <para>
        <literal>quote_nullable(42.5)</literal>
        <returnvalue>'42.5'</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_match</primary>
        </indexterm>
        <function>regexp_match</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type> ] )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
        Returns captured substring(s) resulting from the first match of a POSIX
        regular expression to the <parameter>string</parameter>; see
        <xref linkend="functions-posix-regexp"/>.
       </para>
       <para>
        <literal>regexp_match('foobarbequebaz', '(bar)(beque)')</literal>
        <returnvalue>{bar,beque}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_match</primary>
        </indexterm>
        <function>regexp_match</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type> ] )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
        返回从POSIX正则表达式到<parameter>string</parameter>的第一个匹配中捕获的子字符串;参见<xref linkend="functions-posix-regexp"/>。
       </para>
       <para>
        <literal>regexp_match('foobarbequebaz', '(bar)(beque)')</literal>
        <returnvalue>{bar,beque}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_matches</primary>
        </indexterm>
        <function>regexp_matches</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type> ] )
        <returnvalue>setof text[]</returnvalue>
       </para>
       <para>
        Returns captured substring(s) resulting from matching a POSIX regular
        expression to the <parameter>string</parameter>; see
        <xref linkend="functions-posix-regexp"/>.
       </para>
       <para>
        <literal>regexp_matches('foobarbequebaz', 'ba.', 'g')</literal>
        <returnvalue></returnvalue>
<programlisting>
 {bar}
 {baz}
</programlisting>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_matches</primary>
        </indexterm>
        <function>regexp_matches</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type> ] )
        <returnvalue>setof text[]</returnvalue>
       </para>
       <para>
        返回通过将POSIX正则表达式与<parameter>string</parameter>匹配而捕获的子字符串；参见<xref linkend="functions-posix-regexp"/>。
       </para>
       <para>
        <literal>regexp_matches('foobarbequebaz', 'ba.', 'g')</literal>
        <returnvalue></returnvalue>
<programlisting>
 {bar}
 {baz}
</programlisting>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_replace</primary>
        </indexterm>
        <function>regexp_replace</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type>, <parameter>replacement</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type> ] )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Replaces substring(s) matching a POSIX regular expression; see
        <xref linkend="functions-posix-regexp"/>.
       </para>
       <para>
        <literal>regexp_replace('Thomas', '.[mN]a.', 'M')</literal>
        <returnvalue>ThM</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_replace</primary>
        </indexterm>
        <function>regexp_replace</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type>, <parameter>replacement</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type> ] )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        替换匹配POSIX正则表达式的子字符串；参见 <xref linkend="functions-posix-regexp"/>。
       </para>
       <para>
        <literal>regexp_replace('Thomas', '.[mN]a.', 'M')</literal>
        <returnvalue>ThM</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_split_to_array</primary>
        </indexterm>
        <function>regexp_split_to_array</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type> ] )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
        Splits <parameter>string</parameter> using a POSIX regular
        expression as the delimiter; see
        <xref linkend="functions-posix-regexp"/>.
       </para>
       <para>
        <literal>regexp_split_to_array('hello world', '\s+')</literal>
        <returnvalue>{hello,world}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_split_to_array</primary>
        </indexterm>
        <function>regexp_split_to_array</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type> ] )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
        使用POSIX正则表达式作为分隔符拆分<parameter>string</parameter>； 参见 <xref linkend="functions-posix-regexp"/>。
       </para>
       <para>
        <literal>regexp_split_to_array('hello world', '\s+')</literal>
        <returnvalue>{hello,world}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_split_to_table</primary>
        </indexterm>
        <function>regexp_split_to_table</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type> ] )
        <returnvalue>setof text</returnvalue>
       </para>
       <para>
        Splits <parameter>string</parameter> using a POSIX regular
        expression as the delimiter; see
        <xref linkend="functions-posix-regexp"/>.
       </para>
       <para>
        <literal>regexp_split_to_table('hello world', '\s+')</literal>
        <returnvalue></returnvalue>
<programlisting>
 hello
 world
</programlisting>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_split_to_table</primary>
        </indexterm>
        <function>regexp_split_to_table</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type> ] )
        <returnvalue>setof text</returnvalue>
       </para>
       <para>
        使用POSIX正则表达式作为分隔符拆分<parameter>string</parameter>；参见 <xref linkend="functions-posix-regexp"/>。
       </para>
       <para>
        <literal>regexp_split_to_table('hello world', '\s+')</literal>
        <returnvalue></returnvalue>
<programlisting>
 hello
 world
</programlisting>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>repeat</primary>
        </indexterm>
        <function>repeat</function> ( <parameter>string</parameter> <type>text</type>, <parameter>number</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Repeats <parameter>string</parameter> the specified
        <parameter>number</parameter> of times.
       </para>
       <para>
        <literal>repeat('Pg', 4)</literal>
        <returnvalue>PgPgPgPg</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>repeat</primary>
        </indexterm>
        <function>repeat</function> ( <parameter>string</parameter> <type>text</type>, <parameter>number</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        重复<parameter>string</parameter>指定<parameter>number</parameter>的次数。
       </para>
       <para>
        <literal>repeat('Pg', 4)</literal>
        <returnvalue>PgPgPgPg</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>replace</primary>
        </indexterm>
        <function>replace</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>from</parameter> <type>text</type>,
        <parameter>to</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Replaces all occurrences in <parameter>string</parameter> of
        substring <parameter>from</parameter> with
        substring <parameter>to</parameter>.
       </para>
       <para>
        <literal>replace('abcdefabcdef', 'cd', 'XX')</literal>
        <returnvalue>abXXefabXXef</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>replace</primary>
        </indexterm>
        <function>replace</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>from</parameter> <type>text</type>,
        <parameter>to</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将<parameter>string</parameter> 中当前的子串<parameter>from</parameter>替换为子串<parameter>to</parameter>。
       </para>
       <para>
        <literal>replace('abcdefabcdef', 'cd', 'XX')</literal>
        <returnvalue>abXXefabXXef</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>reverse</primary>
        </indexterm>
        <function>reverse</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Reverses the order of the characters in the string.
       </para>
       <para>
        <literal>reverse('abcde')</literal>
        <returnvalue>edcba</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>reverse</primary>
        </indexterm>
        <function>reverse</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        颠倒字符串中字符的顺序。
       </para>
       <para>
        <literal>reverse('abcde')</literal>
        <returnvalue>edcba</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>right</primary>
        </indexterm>
        <function>right</function> ( <parameter>string</parameter> <type>text</type>,
         <parameter>n</parameter> <type>integer</type> )
<type></type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns last <parameter>n</parameter> characters in the string,
        or when <parameter>n</parameter> is negative, returns all but
        first |<parameter>n</parameter>| characters.
       </para>
       <para>
        <literal>right('abcde', 2)</literal>
        <returnvalue>de</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>right</primary>
        </indexterm>
        <function>right</function> ( <parameter>string</parameter> <type>text</type>,
         <parameter>n</parameter> <type>integer</type> )
<type></type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回字符串中的最后<parameter>n</parameter>个字符，或者在<parameter>n</parameter>>为负时，返回除了前面的|<parameter>n</parameter>|字符之外的所有字符。
       </para>
       <para>
        <literal>right('abcde', 2)</literal>
        <returnvalue>de</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>rpad</primary>
        </indexterm>
        <function>rpad</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>length</parameter> <type>integer</type>
        <optional>, <parameter>fill</parameter> <type>text</type> </optional> )
<type></type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Extends the <parameter>string</parameter> to length
        <parameter>length</parameter> by appending the characters
        <parameter>fill</parameter> (a space by default).  If the
        <parameter>string</parameter> is already longer than
        <parameter>length</parameter> then it is truncated.
       </para>
       <para>
        <literal>rpad('hi', 5, 'xy')</literal>
        <returnvalue>hixyx</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>rpad</primary>
        </indexterm>
        <function>rpad</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>length</parameter> <type>integer</type>
        <optional>, <parameter>fill</parameter> <type>text</type> </optional> )
<type></type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        扩展 <parameter>string</parameter> 到长度 <parameter>length</parameter>，通过追加<parameter>fill</parameter> 字符(默认为空格).  
        如果<parameter>string</parameter> 已经比 <parameter>length</parameter> 长，则截断它。
       </para>
       <para>
        <literal>rpad('hi', 5, 'xy')</literal>
        <returnvalue>hixyx</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>rtrim</primary>
        </indexterm>
        <function>rtrim</function> ( <parameter>string</parameter> <type>text</type>
         <optional>, <parameter>characters</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Removes the longest string containing only characters in
        <parameter>characters</parameter> (a space by default) from the end of
        <parameter>string</parameter>.
       </para>
       <para>
        <literal>rtrim('testxxzx', 'xyz')</literal>
        <returnvalue>test</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>rtrim</primary>
        </indexterm>
        <function>rtrim</function> ( <parameter>string</parameter> <type>text</type>
         <optional>, <parameter>characters</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        从<parameter>string</parameter>末尾删除包含<parameter>characters</parameter>（默认为空格）中仅包含字符的最长字符串。
       </para>
       <para>
        <literal>rtrim('testxxzx', 'xyz')</literal>
        <returnvalue>test</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>split_part</primary>
        </indexterm>
        <function>split_part</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>delimiter</parameter> <type>text</type>,
        <parameter>n</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Splits <parameter>string</parameter> at occurrences
        of <parameter>delimiter</parameter> and returns
        the <parameter>n</parameter>'th field (counting from one).
       </para>
       <para>
        <literal>split_part('abc~@~def~@~ghi', '~@~', 2)</literal>
        <returnvalue>def</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>split_part</primary>
        </indexterm>
        <function>split_part</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>delimiter</parameter> <type>text</type>,
        <parameter>n</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        在<parameter>delimiter</parameter>出现时拆分<parameter>string</parameter>，并且返回第<parameter>n</parameter>个字段(从一计数)。
       </para>
       <para>
        <literal>split_part('abc~@~def~@~ghi', '~@~', 2)</literal>
        <returnvalue>def</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>strpos</primary>
        </indexterm>
        <function>strpos</function> ( <parameter>string</parameter> <type>text</type>, <parameter>substring</parameter> <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns starting index of specified <parameter>substring</parameter>
        within <parameter>string</parameter>, or zero if it's not present.
        (Same as <literal>position(<parameter>substring</parameter> in
        <parameter>string</parameter>)</literal>, but note the reversed
        argument order.)
       </para>
       <para>
        <literal>strpos('high', 'ig')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>strpos</primary>
        </indexterm>
        <function>strpos</function> ( <parameter>string</parameter> <type>text</type>, <parameter>substring</parameter> <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回在<parameter>string</parameter>中指定的<parameter>substring</parameter>的起始索引,如果不存在则为零。
        （与<literal>(<parameter>substring</parameter> 在 <parameter>string</parameter>中的)位置</literal>相同，但是请注意反转的参数顺序）
       </para>
       <para>
        <literal>strpos('high', 'ig')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>substr</primary>
        </indexterm>
        <function>substr</function> ( <parameter>string</parameter> <type>text</type>, <parameter>start</parameter> <type>integer</type> <optional>, <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Extracts the substring of <parameter>string</parameter> starting at
        the <parameter>start</parameter>'th character,
        and extending for <parameter>count</parameter> characters if that is
        specified.  (Same
        as <literal>substring(<parameter>string</parameter>
        from <parameter>start</parameter>
        for <parameter>count</parameter>)</literal>.)
       </para>
       <para>
        <literal>substr('alphabet', 3)</literal>
        <returnvalue>phabet</returnvalue>
       </para>
       <para>
        <literal>substr('alphabet', 3, 2)</literal>
        <returnvalue>ph</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>substr</primary>
        </indexterm>
        <function>substr</function> ( <parameter>string</parameter> <type>text</type>, <parameter>start</parameter> <type>integer</type> <optional>, <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        提取<parameter>string</parameter>从<parameter>start</parameter>字符开始的子字符串，并扩展<parameter>count</parameter>字符，如果指定了的话。
        (与 <literal>子字符串(<parameter>string</parameter> 从 <parameter>start</parameter> 开始计数 <parameter>count</parameter>)</literal>相同。)
       </para>
       <para>
        <literal>substr('alphabet', 3)</literal>
        <returnvalue>phabet</returnvalue>
       </para>
       <para>
        <literal>substr('alphabet', 3, 2)</literal>
        <returnvalue>ph</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>starts_with</primary>
        </indexterm>
        <function>starts_with</function> ( <parameter>string</parameter> <type>text</type>, <parameter>prefix</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Returns true if <parameter>string</parameter> starts
        with <parameter>prefix</parameter>.
       </para>
       <para>
        <literal>starts_with('alphabet', 'alph')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>starts_with</primary>
        </indexterm>
        <function>starts_with</function> ( <parameter>string</parameter> <type>text</type>, <parameter>prefix</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        如果 <parameter>string</parameter> 以 <parameter>prefix</parameter>开始就返回真。
       </para>
       <para>
        <literal>starts_with('alphabet', 'alph')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_ascii</primary>
        </indexterm>
        <function>to_ascii</function> ( <parameter>string</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>to_ascii</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>encoding</parameter> <type>name</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>to_ascii</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>encoding</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts <parameter>string</parameter> to <acronym>ASCII</acronym>
        from another encoding, which may be identified by name or number.
        If <parameter>encoding</parameter> is omitted the database encoding
        is assumed (which in practice is the only useful case).
        The conversion consists primarily of dropping accents.
        Conversion is only supported
        from <literal>LATIN1</literal>, <literal>LATIN2</literal>,
        <literal>LATIN9</literal>, and <literal>WIN1250</literal> encodings.
        (See the <xref linkend="unaccent"/> module for another, more flexible
        solution.)
       </para>
       <para>
        <literal>to_ascii('Kar&eacute;l')</literal>
        <returnvalue>Karel</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_ascii</primary>
        </indexterm>
        <function>to_ascii</function> ( <parameter>string</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>to_ascii</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>encoding</parameter> <type>name</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>to_ascii</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>encoding</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将<parameter>string</parameter>从另一个编码中转换为<acronym>ASCII</acronym>，该编码可按名称或编号标识。
        如果<parameter>encoding</parameter>被省略，则假定数据库编码（这在实践中是唯一有用的案例）。转换主要包括降音。
        转换仅支持来自 <literal>LATIN1</literal>、<literal>LATIN2</literal>、<literal>LATIN9</literal>、 和 <literal>WIN1250</literal> 的编码.
        (其他请参见 <xref linkend="unaccent"/> 模块, 更灵活的解决方案。)
       </para>
       <para>
        <literal>to_ascii('Kar&eacute;l')</literal>
        <returnvalue>Karel</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_hex</primary>
        </indexterm>
        <function>to_hex</function> ( <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>to_hex</function> ( <type>bigint</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts the number to its equivalent hexadecimal representation.
       </para>
       <para>
        <literal>to_hex(2147483647)</literal>
        <returnvalue>7fffffff</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_hex</primary>
        </indexterm>
        <function>to_hex</function> ( <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>to_hex</function> ( <type>bigint</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将数字转换为其相应的十六进制表示形式。
       </para>
       <para>
        <literal>to_hex(2147483647)</literal>
        <returnvalue>7fffffff</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>translate</primary>
        </indexterm>
        <function>translate</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>from</parameter> <type>text</type>,
        <parameter>to</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Replaces each character in <parameter>string</parameter> that
        matches a character in the <parameter>from</parameter> set with the
        corresponding character in the <parameter>to</parameter>
        set. If <parameter>from</parameter> is longer than
        <parameter>to</parameter>, occurrences of the extra characters in
        <parameter>from</parameter> are deleted.
       </para>
       <para>
        <literal>translate('12345', '143', 'ax')</literal>
        <returnvalue>a2x5</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>translate</primary>
        </indexterm>
        <function>translate</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>from</parameter> <type>text</type>,
        <parameter>to</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将<parameter>string</parameter>中与<parameter>from</parameter>集合中匹配的每个字符替换为<parameter>to</parameter>集合中相应的字符。
        如果<parameter>from</parameter>长于<parameter>to</parameter>，<parameter>from</parameter>中出现的额外字符被删除。
       </para>
       <para>
        <literal>translate('12345', '143', 'ax')</literal>
        <returnvalue>a2x5</returnvalue>
       </para></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    The <function>concat</function>, <function>concat_ws</function> and
    <function>format</function> functions are variadic, so it is possible to
    pass the values to be concatenated or formatted as an array marked with
    the <literal>VARIADIC</literal> keyword (see <xref
    linkend="xfunc-sql-variadic-functions"/>).  The array's elements are
    treated as if they were separate ordinary arguments to the function.
    If the variadic array argument is NULL, <function>concat</function>
    and <function>concat_ws</function> return NULL, but
    <function>format</function> treats a NULL as a zero-element array.
   </para>
____________________________________________________________________________-->
   <para>
    <function>concat</function>、<function>concat_ws</function>和<function>format</function>函数是可变的，因此可以把要串接或格式化的值作为一个标记了<literal>VARIADIC</literal>关键字的数组进行传递（见<xref linkend="xfunc-sql-variadic-functions"/>）。
    数组的元素被当作函数的独立普通参数一样处理。如果可变数组参数为 NULL，<function>concat</function>和<function>concat_ws</function>返回 NULL，但<function>format</function>把 NULL 当作一个零元素数组。
   </para>

<!--==========================orignal english content==========================
   <para>
    See also the aggregate function <function>string_agg</function> in
    <xref linkend="functions-aggregate"/>, and the functions for
    converting between strings and the <type>bytea</type> type in
    <xref linkend="functions-binarystring-conversions"/>.
   </para>
____________________________________________________________________________-->
   <para>
	还可以参阅<xref linkend="functions-aggregate"/>中的<function>string_agg</function>，以及<xref linkend="functions-binarystring-conversions"/>中的字符串和<type>bytea</type>类型之间转换的功能。
   </para>

   <sect2 id="functions-string-format">
<!--==========================orignal english content==========================
    <title><function>format</function></title>
____________________________________________________________________________-->
    <title><function>format</function></title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>format</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>format</primary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     The function <function>format</function> produces output formatted according to
     a format string, in a style similar to the C function
     <function>sprintf</function>.
    </para>
____________________________________________________________________________-->
    <para>
     函数<function>format</function>根据一个格式字符串产生格式化的输出，其形式类似于 C 函数<function>sprintf</function>。
    </para>

<!--==========================orignal english content==========================
    <para>
<synopsis>
<function>format</function>(<parameter>formatstr</parameter> <type>text</type> [, <parameter>formatarg</parameter> <type>"any"</type> [, ...] ])
</synopsis>
     <parameter>formatstr</parameter> is a format string that specifies how the
     result should be formatted.  Text in the format string is copied
     directly to the result, except where <firstterm>format specifiers</firstterm> are
     used.  Format specifiers act as placeholders in the string, defining how
     subsequent function arguments should be formatted and inserted into the
     result.  Each <parameter>formatarg</parameter> argument is converted to text
     according to the usual output rules for its data type, and then formatted
     and inserted into the result string according to the format specifier(s).
    </para>
____________________________________________________________________________-->
    <para>
<synopsis>
<function>format</function>(<parameter>formatstr</parameter> <type>text</type> [, <parameter>formatarg</parameter> <type>"any"</type> [, ...] ])
</synopsis>
     <parameter>formatstr</parameter>是一个格式字符串，它指定了结果应该如何被格式化。格式字符串中的文本被直接复制到结果中，除了使用<firstterm>格式说明符</firstterm>的地方。格式说明符在字符串中扮演着占位符的角色，它定义后续的函数参数如何被格式化及插入到结果中。每一个<parameter>formatarg</parameter>参数会被根据其数据类型的常规输出规则转换为文本，并接着根据格式说明符被格式化和插入到结果字符串中。
    </para>

<!--==========================orignal english content==========================
    <para>
     Format specifiers are introduced by a <literal>%</literal> character and have
     the form
<synopsis>
%[<parameter>position</parameter>][<parameter>flags</parameter>][<parameter>width</parameter>]<parameter>type</parameter>
</synopsis>
     where the component fields are:

     <variablelist>
      <varlistentry>
       <term><parameter>position</parameter> (optional)</term>
       <listitem>
        <para>
         A string of the form <literal><parameter>n</parameter>$</literal> where
         <parameter>n</parameter> is the index of the argument to print.
         Index 1 means the first argument after
         <parameter>formatstr</parameter>.  If the <parameter>position</parameter> is
         omitted, the default is to use the next argument in sequence.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><parameter>flags</parameter> (optional)</term>
       <listitem>
        <para>
         Additional options controlling how the format specifier's output is
         formatted.  Currently the only supported flag is a minus sign
         (<literal>-</literal>) which will cause the format specifier's output to be
         left-justified.  This has no effect unless the <parameter>width</parameter>
         field is also specified.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><parameter>width</parameter> (optional)</term>
       <listitem>
        <para>
         Specifies the <emphasis>minimum</emphasis> number of characters to use to
         display the format specifier's output.  The output is padded on the
         left or right (depending on the <literal>-</literal> flag) with spaces as
         needed to fill the width.  A too-small width does not cause
         truncation of the output, but is simply ignored.  The width may be
         specified using any of the following: a positive integer; an
         asterisk (<literal>*</literal>) to use the next function argument as the
         width; or a string of the form <literal>*<parameter>n</parameter>$</literal> to
         use the <parameter>n</parameter>th function argument as the width.
        </para>

        <para>
         If the width comes from a function argument, that argument is
         consumed before the argument that is used for the format specifier's
         value.  If the width argument is negative, the result is left
         aligned (as if the <literal>-</literal> flag had been specified) within a
         field of length <function>abs</function>(<parameter>width</parameter>).
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><parameter>type</parameter> (required)</term>
       <listitem>
        <para>
         The type of format conversion to use to produce the format
         specifier's output.  The following types are supported:
         <itemizedlist>
          <listitem>
           <para>
            <literal>s</literal> formats the argument value as a simple
            string.  A null value is treated as an empty string.
           </para>
          </listitem>
          <listitem>
           <para>
            <literal>I</literal> treats the argument value as an SQL
            identifier, double-quoting it if necessary.
            It is an error for the value to be null (equivalent to
            <function>quote_ident</function>).
           </para>
          </listitem>
          <listitem>
           <para>
            <literal>L</literal> quotes the argument value as an SQL literal.
            A null value is displayed as the string <literal>NULL</literal>, without
            quotes (equivalent to <function>quote_nullable</function>).
           </para>
          </listitem>
         </itemizedlist>
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
____________________________________________________________________________-->
    <para>
     格式说明符由一个<literal>%</literal>字符开始并且有这样的形式
<synopsis>
%[<parameter>position</parameter>][<parameter>flags</parameter>][<parameter>width</parameter>]<parameter>type</parameter>
</synopsis>
     其中的各组件域是：

     <variablelist>
      <varlistentry>
       <term><parameter>position</parameter>（可选）</term>
       <listitem>
        <para>
         一个形式为<literal><parameter>n</parameter>$</literal>的字符串，其中<parameter>n</parameter>是要打印的参数的索引。索引 1 表示<parameter>formatstr</parameter>之后的第一个参数。如果<parameter>position</parameter>被忽略，默认会使用序列中的下一个参数。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><parameter>flags</parameter>（可选）</term>
       <listitem>
        <para>
         控制格式说明符的输出如何被格式化的附加选项。当前唯一支持的标志是一个负号（<literal>-</literal>），它将导致格式说明符的输出会被左对齐（left-justified）。除非<parameter>width</parameter>域也被指定，否者这个域不会产生任何效果。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><parameter>width</parameter>（可选）</term>
       <listitem>
        <para>
         指定用于显示格式说明符输出的<emphasis>最小</emphasis>字符数。输出将被在左部或右部（取决于<literal>-</literal>标志）用空格填充以保证充满该宽度。太小的宽度设置不会导致输出被截断，但是会被简单地忽略。宽度可以使用下列形式之一指定：一个正整数；一个星号（<literal>*</literal>）表示使用下一个函数参数作为宽度；或者一个形式为<literal>*<parameter>n</parameter>$</literal>的字符串表示使用第<parameter>n</parameter>个函数参数作为宽度。
        </para>

        <para>
         如果宽度来自于一个函数参数，则参数在被格式说明符的值使用之前就被消耗掉了。如果宽度参数是负值，结果会在长度为<function>abs</function>(<parameter>width</parameter>)的域中被左对齐（如果<literal>-</literal>标志被指定）。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><parameter>type</parameter>（必需）</term>
       <listitem>
        <para>
         格式转换的类型，用于产生格式说明符的输出。支持下面的类型：
         <itemizedlist>
          <listitem>
           <para>
            <literal>s</literal>将参数值格式化为一个简单字符串。一个控制被视为一个空字符串。
           </para>
          </listitem>
          <listitem>
           <para>
            <literal>I</literal>将参数值视作 SQL 标识符，并在必要时用双写引号包围它。如果参数为空，将会是一个错误（等效于<function>quote_ident</function>）。
           </para>
          </listitem>
          <listitem>
           <para>
            <literal>L</literal>将参数值引用为 SQL 文字。一个空值将被显示为不带引号的字符串<literal>NULL</literal>（等效于<function>quote_nullable</function>）。
           </para>
          </listitem>
         </itemizedlist>
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>

<!--==========================orignal english content==========================
    <para>
     In addition to the format specifiers described above, the special sequence
     <literal>%%</literal> may be used to output a literal <literal>%</literal> character.
    </para>
____________________________________________________________________________-->
    <para>
     除了以上所述的格式说明符之外，要输出一个文字形式的<literal>%</literal>字符，可以使用特殊序列<literal>%%</literal>。
    </para>

<!--==========================orignal english content==========================
    <para>
     Here are some examples of the basic format conversions:

<screen>
SELECT format('Hello %s', 'World');
<lineannotation>Result: </lineannotation><computeroutput>Hello World</computeroutput>

SELECT format('Testing %s, %s, %s, %%', 'one', 'two', 'three');
<lineannotation>Result: </lineannotation><computeroutput>Testing one, two, three, %</computeroutput>

SELECT format('INSERT INTO %I VALUES(%L)', 'Foo bar', E'O\'Reilly');
<lineannotation>Result: </lineannotation><computeroutput>INSERT INTO "Foo bar" VALUES('O''Reilly')</computeroutput>

SELECT format('INSERT INTO %I VALUES(%L)', 'locations', 'C:\Program Files');
<lineannotation>Result: </lineannotation><computeroutput>INSERT INTO locations VALUES('C:\Program Files')</computeroutput>
</screen>
    </para>
____________________________________________________________________________-->
    <para>
     下面有一些基本的格式转换的例子：

<screen>
SELECT format('Hello %s', 'World');
<lineannotation>结果：</lineannotation><computeroutput>Hello World</computeroutput>

SELECT format('Testing %s, %s, %s, %%', 'one', 'two', 'three');
<lineannotation>结果：</lineannotation><computeroutput>Testing one, two, three, %</computeroutput>

SELECT format('INSERT INTO %I VALUES(%L)', 'Foo bar', E'O\'Reilly');
<lineannotation>结果：</lineannotation><computeroutput>INSERT INTO "Foo bar" VALUES('O''Reilly')</computeroutput>

SELECT format('INSERT INTO %I VALUES(%L)', 'locations', 'C:\Program Files');
<lineannotation>结果：</lineannotation><computeroutput>INSERT INTO locations VALUES(E'C:\\Program Files')</computeroutput>
</screen>
    </para>

<!--==========================orignal english content==========================
    <para>
     Here are examples using <parameter>width</parameter> fields
     and the <literal>-</literal> flag:

<screen>
SELECT format('|%10s|', 'foo');
<lineannotation>Result: </lineannotation><computeroutput>|       foo|</computeroutput>

SELECT format('|%-10s|', 'foo');
<lineannotation>Result: </lineannotation><computeroutput>|foo       |</computeroutput>

SELECT format('|%*s|', 10, 'foo');
<lineannotation>Result: </lineannotation><computeroutput>|       foo|</computeroutput>

SELECT format('|%*s|', -10, 'foo');
<lineannotation>Result: </lineannotation><computeroutput>|foo       |</computeroutput>

SELECT format('|%-*s|', 10, 'foo');
<lineannotation>Result: </lineannotation><computeroutput>|foo       |</computeroutput>

SELECT format('|%-*s|', -10, 'foo');
<lineannotation>Result: </lineannotation><computeroutput>|foo       |</computeroutput>
</screen>
    </para>
____________________________________________________________________________-->
    <para>
     下面是使用<parameter>width</parameter>域和<literal>-</literal>标志的例子：

<screen>
SELECT format('|%10s|', 'foo');
<lineannotation>结果：</lineannotation><computeroutput>|       foo|</computeroutput>

SELECT format('|%-10s|', 'foo');
<lineannotation>结果：</lineannotation><computeroutput>|foo       |</computeroutput>

SELECT format('|%*s|', 10, 'foo');
<lineannotation>结果：</lineannotation><computeroutput>|       foo|</computeroutput>

SELECT format('|%*s|', -10, 'foo');
<lineannotation>结果：</lineannotation><computeroutput>|foo       |</computeroutput>

SELECT format('|%-*s|', 10, 'foo');
<lineannotation>结果：</lineannotation><computeroutput>|foo       |</computeroutput>

SELECT format('|%-*s|', -10, 'foo');
<lineannotation>结果：</lineannotation><computeroutput>|foo       |</computeroutput>
</screen>
    </para>

<!--==========================orignal english content==========================
    <para>
     These examples show use of <parameter>position</parameter> fields:

<screen>
SELECT format('Testing %3$s, %2$s, %1$s', 'one', 'two', 'three');
<lineannotation>Result: </lineannotation><computeroutput>Testing three, two, one</computeroutput>

SELECT format('|%*2$s|', 'foo', 10, 'bar');
<lineannotation>Result: </lineannotation><computeroutput>|       bar|</computeroutput>

SELECT format('|%1$*2$s|', 'foo', 10, 'bar');
<lineannotation>Result: </lineannotation><computeroutput>|       foo|</computeroutput>
</screen>
    </para>
____________________________________________________________________________-->
    <para>
     这些例子展示了<parameter>position</parameter>域的例子：

<screen>
SELECT format('Testing %3$s, %2$s, %1$s', 'one', 'two', 'three');
<lineannotation>结果：</lineannotation><computeroutput>Testing three, two, one</computeroutput>

SELECT format('|%*2$s|', 'foo', 10, 'bar');
<lineannotation>结果：</lineannotation><computeroutput>|       bar|</computeroutput>

SELECT format('|%1$*2$s|', 'foo', 10, 'bar');
<lineannotation>结果：</lineannotation><computeroutput>|       foo|</computeroutput>
</screen>
    </para>

<!--==========================orignal english content==========================
    <para>
     Unlike the standard C function <function>sprintf</function>,
     <productname>PostgreSQL</productname>'s <function>format</function> function allows format
     specifiers with and without <parameter>position</parameter> fields to be mixed
     in the same format string.  A format specifier without a
     <parameter>position</parameter> field always uses the next argument after the
     last argument consumed.
     In addition, the <function>format</function> function does not require all
     function arguments to be used in the format string.
     For example:

<screen>
SELECT format('Testing %3$s, %2$s, %s', 'one', 'two', 'three');
<lineannotation>Result: </lineannotation><computeroutput>Testing three, two, three</computeroutput>
</screen>
    </para>
____________________________________________________________________________-->
    <para>
     不同于标准的 C 函数<function>sprintf</function>，<productname>PostgreSQL</productname>的<function>format</function>函数允许将带有或者不带有<parameter>position</parameter>域的格式说明符被混在同一个格式字符串中。一个不带有<parameter>position</parameter>域的格式说明符总是使用最后一个被消耗的参数的下一个参数。另外，<function>format</function>函数不要求所有函数参数都被用在格式字符串中。例如：

<screen>
SELECT format('Testing %3$s, %2$s, %s', 'one', 'two', 'three');
<lineannotation>结果：</lineannotation><computeroutput>Testing three, two, three</computeroutput>
</screen>
    </para>

<!--==========================orignal english content==========================
    <para>
     The <literal>%I</literal> and <literal>%L</literal> format specifiers are particularly
     useful for safely constructing dynamic SQL statements.  See
     <xref linkend="plpgsql-quote-literal-example"/>.
    </para>
____________________________________________________________________________-->
    <para>
     对于安全地构造动态 SQL 语句，<literal>%I</literal>和<literal>%L</literal>格式说明符特别有用。参见<xref linkend="plpgsql-quote-literal-example"/>。
    </para>
   </sect2>

  </sect1>


  <sect1 id="functions-binarystring">
<!--==========================orignal english content==========================
   <title>Binary String Functions and Operators</title>
____________________________________________________________________________-->
   <title>二进制串函数和操作符</title>

<!--==========================orignal english content==========================
   <indexterm zone="functions-binarystring">
    <primary>binary data</primary>
    <secondary>functions</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="functions-binarystring">
    <primary>binary data</primary>
    <secondary>functions</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    This section describes functions and operators for examining and
    manipulating binary strings, that is values of type <type>bytea</type>.
    Many of these are equivalent, in purpose and syntax, to the
    text-string functions described in the previous section.
   </para>
____________________________________________________________________________-->
   <para>
    本节描述那些检查和操作二进制字符串的函数和操作符，这是类型<type>bytea</type>的值。
    其中许多函数在用途和语法上都与上一节中描述的文本字符串函数等效。
   </para>

<!--==========================orignal english content==========================
   <para>
    <acronym>SQL</acronym> defines some string functions that use
    key words, rather than commas, to separate
    arguments.  Details are in
    <xref linkend="functions-binarystring-sql"/>.
    <productname>PostgreSQL</productname> also provides versions of these functions
    that use the regular function invocation syntax
    (see <xref linkend="functions-binarystring-other"/>).
   </para>
____________________________________________________________________________-->
   <para>
    <acronym>SQL</acronym>定义了一些使用关键字而不是逗号来分割参数的串函数。详情请见<xref linkend="functions-binarystring-sql"/>。<productname>PostgreSQL</productname>也提供了这些函数使用常规函数调用语法的版本（参阅<xref linkend="functions-binarystring-other"/>）。
   </para>

   <table id="functions-binarystring-sql">
<!--==========================orignal english content==========================
    <title><acronym>SQL</acronym> Binary String Functions and Operators</title>
____________________________________________________________________________-->
    <title><acronym>SQL</acronym>二进制串函数和操作符</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function/Operator
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数/操作符
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>binary string</primary>
         <secondary>concatenation</secondary>
        </indexterm>
        <type>bytea</type> <literal>||</literal> <type>bytea</type>
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        Concatenates the two binary strings.
       </para>
       <para>
        <literal>'\x123456'::bytea || '\x789a00bcde'::bytea</literal>
        <returnvalue>\x123456789a00bcde</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>binary string</primary>
         <secondary>concatenation</secondary>
        </indexterm>
        <type>bytea</type> <literal>||</literal> <type>bytea</type>
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        连接两个二进制字符串。
       </para>
       <para>
        <literal>'\x123456'::bytea || '\x789a00bcde'::bytea</literal>
        <returnvalue>\x123456789a00bcde</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bit_length</primary>
        </indexterm>
        <function>bit_length</function> ( <type>bytea</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns number of bits in the binary string (8
        times the <function>octet_length</function>).
       </para>
       <para>
        <literal>bit_length('\x123456'::bytea)</literal>
        <returnvalue>24</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bit_length</primary>
        </indexterm>
        <function>bit_length</function> ( <type>bytea</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回二进制字符串中的位数 (8 倍于 <function>octet_length</function>).
       </para>
       <para>
        <literal>bit_length('\x123456'::bytea)</literal>
        <returnvalue>24</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>octet_length</primary>
        </indexterm>
        <function>octet_length</function> ( <type>bytea</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns number of bytes in the binary string.
       </para>
       <para>
        <literal>octet_length('\x123456'::bytea)</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>octet_length</primary>
        </indexterm>
        <function>octet_length</function> ( <type>bytea</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回二进制字符串中的字节数。
       </para>
       <para>
        <literal>octet_length('\x123456'::bytea)</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>overlay</primary>
        </indexterm>
        <function>overlay</function> ( <parameter>bytes</parameter> <type>bytea</type> <literal>PLACING</literal> <parameter>newsubstring</parameter> <type>bytea</type> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        Replaces the substring of <parameter>bytes</parameter> that starts at
        the <parameter>start</parameter>'th byte and extends
        for <parameter>count</parameter> bytes
        with <parameter>newsubstring</parameter>.
        If <parameter>count</parameter> is omitted, it defaults to the length
        of <parameter>newsubstring</parameter>.
       </para>
       <para>
        <literal>overlay('\x1234567890'::bytea placing '\002\003'::bytea from 2 for 3)</literal>
        <returnvalue>\x12020390</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>overlay</primary>
        </indexterm>
        <function>overlay</function> ( <parameter>bytes</parameter> <type>bytea</type> <literal>PLACING</literal> <parameter>newsubstring</parameter> <type>bytea</type> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        将<parameter>bytes</parameter>的子字符串替换为<parameter>newsubstring</parameter>，该子字符串从<parameter>start</parameter>字节开始，并以<parameter>count</parameter>字节扩展。
        如果忽略了<parameter>count</parameter>，则默认为<parameter>newsubstring</parameter>的长度。
       </para>
       <para>
        <literal>overlay('\x1234567890'::bytea placing '\002\003'::bytea from 2 for 3)</literal>
        <returnvalue>\x12020390</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>position</primary>
        </indexterm>
        <function>position</function> ( <parameter>substring</parameter> <type>bytea</type> <literal>IN</literal> <parameter>bytes</parameter> <type>bytea</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns starting index of specified <parameter>substring</parameter>
        within <parameter>bytes</parameter>, or zero if it's not present.
       </para>
       <para>
        <literal>position('\x5678'::bytea in '\x1234567890'::bytea)</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>position</primary>
        </indexterm>
        <function>position</function> ( <parameter>substring</parameter> <type>bytea</type> <literal>IN</literal> <parameter>bytes</parameter> <type>bytea</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回指定的<parameter>substring</parameter>在<parameter>bytes</parameter>内的起始索引，如果不存在，则为零。
       </para>
       <para>
        <literal>position('\x5678'::bytea in '\x1234567890'::bytea)</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>substring</primary>
        </indexterm>
        <function>substring</function> ( <parameter>bytes</parameter> <type>bytea</type> <optional> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> </optional> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        Extracts the substring of <parameter>bytes</parameter> starting at
        the <parameter>start</parameter>'th byte if that is specified,
        and stopping after <parameter>count</parameter> bytes if that is
        specified.  Provide at least one of <parameter>start</parameter>
        and <parameter>count</parameter>.
       </para>
       <para>
        <literal>substring('\x1234567890'::bytea from 3 for 2)</literal>
        <returnvalue>\x5678</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>substring</primary>
        </indexterm>
        <function>substring</function> ( <parameter>bytes</parameter> <type>bytea</type> <optional> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> </optional> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        提取<parameter>bytes</parameter>从<parameter>start</parameter>字节开始的子字符串，如果指定了，并且在<parameter>count</parameter>字节之后停止，如果指定了的话。
        至少提供<parameter>start</parameter>和<parameter>count</parameter>中的一个。
       </para>
       <para>
        <literal>substring('\x1234567890'::bytea from 3 for 2)</literal>
        <returnvalue>\x5678</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>trim</primary>
        </indexterm>
        <function>trim</function> ( <optional> <literal>BOTH</literal> </optional>
        <parameter>bytesremoved</parameter> <type>bytea</type> <literal>FROM</literal>
        <parameter>bytes</parameter> <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        Removes the longest string containing only bytes appearing in
        <parameter>bytesremoved</parameter> from the start
        and end of <parameter>bytes</parameter>.
       </para>
       <para>
        <literal>trim('\x9012'::bytea from '\x1234567890'::bytea)</literal>
        <returnvalue>\x345678</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>trim</primary>
        </indexterm>
        <function>trim</function> ( <optional> <literal>BOTH</literal> </optional>
        <parameter>bytesremoved</parameter> <type>bytea</type> <literal>FROM</literal>
        <parameter>bytes</parameter> <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        从<parameter>bytes</parameter>的开始和结束处删除<parameter>bytesremoved</parameter>中只包含字节的最长字符串。
       </para>
       <para>
        <literal>trim('\x9012'::bytea from '\x1234567890'::bytea)</literal>
        <returnvalue>\x345678</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>trim</function> ( <optional> <literal>BOTH</literal> </optional> <optional> <literal>FROM</literal> </optional>
        <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>bytesremoved</parameter> <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        This is a non-standard syntax for <function>trim()</function>.
       </para>
       <para>
        <literal>trim(both from '\x1234567890'::bytea, '\x9012'::bytea)</literal>
        <returnvalue>\x345678</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>trim</function> ( <optional> <literal>BOTH</literal> </optional> <optional> <literal>FROM</literal> </optional>
        <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>bytesremoved</parameter> <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        这是<function>trim()</function>的非标准语法。
       </para>
       <para>
        <literal>trim(both from '\x1234567890'::bytea, '\x9012'::bytea)</literal>
        <returnvalue>\x345678</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    Additional binary string manipulation functions are available and
    are listed in <xref linkend="functions-binarystring-other"/>.  Some
    of them are used internally to implement the
    <acronym>SQL</acronym>-standard string functions listed in <xref
    linkend="functions-binarystring-sql"/>.
   </para>
____________________________________________________________________________-->
   <para>
    还有一些二进制串处理函数可以使用，在<xref linkend="functions-binarystring-other"/>列出。 其中有一些是在内部使用，用于实现<xref linkend="functions-binarystring-sql"/>列出的 SQL 标准串函数。
   </para>

   <table id="functions-binarystring-other">
<!--==========================orignal english content==========================
    <title>Other Binary String Functions</title>
____________________________________________________________________________-->
    <title>其他二进制串函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>btrim</primary>
        </indexterm>
        <function>btrim</function> ( <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>bytesremoved</parameter> <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        Removes the longest string containing only bytes appearing in
        <parameter>bytesremoved</parameter> from the start and end of
        <parameter>bytes</parameter>.
       </para>
       <para>
       <literal>btrim('\x1234567890'::bytea, '\x9012'::bytea)</literal>
       <returnvalue>\x345678</returnvalue>
      </para></entry>
     </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>btrim</primary>
        </indexterm>
        <function>btrim</function> ( <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>bytesremoved</parameter> <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        从<parameter>bytes</parameter>的开始和结束处删除只包含<parameter>bytesremoved</parameter>中出现的字节的最长字符串
       </para>
       <para>
       <literal>btrim('\x1234567890'::bytea, '\x9012'::bytea)</literal>
       <returnvalue>\x345678</returnvalue>
      </para></entry>
     </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>get_bit</primary>
        </indexterm>
        <function>get_bit</function> ( <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>n</parameter> <type>bigint</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Extracts <link linkend="functions-zerobased-note">n'th</link> bit
        from binary string.
       </para>
       <para>
        <literal>get_bit('\x1234567890'::bytea, 30)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>get_bit</primary>
        </indexterm>
        <function>get_bit</function> ( <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>n</parameter> <type>bigint</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        从二进制字符串中提取 <link linkend="functions-zerobased-note">n'th</link> 位。
       </para>
       <para>
        <literal>get_bit('\x1234567890'::bytea, 30)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>get_byte</primary>
        </indexterm>
        <function>get_byte</function> ( <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>n</parameter> <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Extracts <link linkend="functions-zerobased-note">n'th</link> byte
        from binary string.
       </para>
       <para>
        <literal>get_byte('\x1234567890'::bytea, 4)</literal>
        <returnvalue>144</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>get_byte</primary>
        </indexterm>
        <function>get_byte</function> ( <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>n</parameter> <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        从二进制字符串中提取 <link linkend="functions-zerobased-note">n'th</link> 字节。
       </para>
       <para>
        <literal>get_byte('\x1234567890'::bytea, 4)</literal>
        <returnvalue>144</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>length</primary>
        </indexterm>
        <indexterm>
         <primary>binary string</primary>
         <secondary>length</secondary>
        </indexterm>
        <indexterm>
         <primary>length</primary>
         <secondary sortas="binary string">of a binary string</secondary>
         <see>binary strings, length</see>
        </indexterm>
        <function>length</function> ( <type>bytea</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the number of bytes in the binary string.
       </para>
       <para>
        <literal>length('\x1234567890'::bytea)</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>length</primary>
        </indexterm>
        <indexterm>
         <primary>binary string</primary>
         <secondary>length</secondary>
        </indexterm>
        <indexterm>
         <primary>length</primary>
         <secondary sortas="binary string">of a binary string</secondary>
         <see>binary strings, length</see>
        </indexterm>
        <function>length</function> ( <type>bytea</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回二进制字符串中的字节数。
       </para>
       <para>
        <literal>length('\x1234567890'::bytea)</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>length</function> ( <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>encoding</parameter> <type>name</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the number of characters in the binary string, assuming
        that it is text in the given <parameter>encoding</parameter>.
       </para>
       <para>
        <literal>length('jose'::bytea, 'UTF8')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>length</function> ( <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>encoding</parameter> <type>name</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回二进制字符串中的字符数，假设它是给定<parameter>encoding</parameter>中的文本。
       </para>
       <para>
        <literal>length('jose'::bytea, 'UTF8')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>md5</primary>
        </indexterm>
        <function>md5</function> ( <type>bytea</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Computes the MD5 <link linkend="functions-hash-note">hash</link> of
        the binary string, with the result written in hexadecimal.
       </para>
       <para>
        <literal>md5('Th\000omas'::bytea)</literal>
        <returnvalue>8ab2d3c9689aaf18&zwsp;b4958c334c82d8b1</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>md5</primary>
        </indexterm>
        <function>md5</function> ( <type>bytea</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        计算二进制字符串的MD5 <link linkend="functions-hash-note">hash</link>，结果以十六进制形式写入。
       </para>
       <para>
        <literal>md5('Th\000omas'::bytea)</literal>
        <returnvalue>8ab2d3c9689aaf18&zwsp;b4958c334c82d8b1</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>set_bit</primary>
        </indexterm>
        <function>set_bit</function> ( <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>n</parameter> <type>bigint</type>,
        <parameter>newvalue</parameter> <type>integer</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        Sets <link linkend="functions-zerobased-note">n'th</link> bit in
        binary string to <parameter>newvalue</parameter>.
       </para>
       <para>
        <literal>set_bit('\x1234567890'::bytea, 30, 0)</literal>
        <returnvalue>\x1234563890</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>set_bit</primary>
        </indexterm>
        <function>set_bit</function> ( <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>n</parameter> <type>bigint</type>,
        <parameter>newvalue</parameter> <type>integer</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        设置二进制字符串中的<link linkend="functions-zerobased-note">n'th</link>位为<parameter>newvalue</parameter>。
       </para>
       <para>
        <literal>set_bit('\x1234567890'::bytea, 30, 0)</literal>
        <returnvalue>\x1234563890</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>set_byte</primary>
        </indexterm>
        <function>set_byte</function> ( <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>n</parameter> <type>integer</type>,
        <parameter>newvalue</parameter> <type>integer</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        Sets <link linkend="functions-zerobased-note">n'th</link> byte in
        binary string to <parameter>newvalue</parameter>.
       </para>
       <para>
        <literal>set_byte('\x1234567890'::bytea, 4, 64)</literal>
        <returnvalue>\x1234567840</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>set_byte</primary>
        </indexterm>
        <function>set_byte</function> ( <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>n</parameter> <type>integer</type>,
        <parameter>newvalue</parameter> <type>integer</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        设置二进制字符串中的 <link linkend="functions-zerobased-note">n'th</link> 字节到 <parameter>newvalue</parameter>。
       </para>
       <para>
        <literal>set_byte('\x1234567890'::bytea, 4, 64)</literal>
        <returnvalue>\x1234567840</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sha224</primary>
        </indexterm>
        <function>sha224</function> ( <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        Computes the SHA-224 <link linkend="functions-hash-note">hash</link>
        of the binary string.
       </para>
       <para>
        <literal>sha224('abc'::bytea)</literal>
        <returnvalue>\x23097d223405d8228642a477bda2&zwsp;55b32aadbce4bda0b3f7e36c9da7</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sha224</primary>
        </indexterm>
        <function>sha224</function> ( <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        计算二进制字符串的 SHA-224 <link linkend="functions-hash-note">hash</link>。
       </para>
       <para>
        <literal>sha224('abc'::bytea)</literal>
        <returnvalue>\x23097d223405d8228642a477bda2&zwsp;55b32aadbce4bda0b3f7e36c9da7</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sha256</primary>
        </indexterm>
        <function>sha256</function> ( <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        Computes the SHA-256 <link linkend="functions-hash-note">hash</link>
        of the binary string.
       </para>
       <para>
        <literal>sha256('abc'::bytea)</literal>
        <returnvalue>\xba7816bf8f01cfea414140de5dae2223&zwsp;b00361a396177a9cb410ff61f20015ad</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sha256</primary>
        </indexterm>
        <function>sha256</function> ( <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        计算二进制字符串的 SHA-256 <link linkend="functions-hash-note">hash</link>。
       </para>
       <para>
        <literal>sha256('abc'::bytea)</literal>
        <returnvalue>\xba7816bf8f01cfea414140de5dae2223&zwsp;b00361a396177a9cb410ff61f20015ad</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sha384</primary>
        </indexterm>
        <function>sha384</function> ( <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        Computes the SHA-384 <link linkend="functions-hash-note">hash</link>
        of the binary string.
       </para>
       <para>
        <literal>sha384('abc'::bytea)</literal>
        <returnvalue>\xcb00753f45a35e8bb5a03d699ac65007&zwsp;272c32ab0eded1631a8b605a43ff5bed&zwsp;8086072ba1e7cc2358baeca134c825a7</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sha384</primary>
        </indexterm>
        <function>sha384</function> ( <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        计算二进制字符串的 SHA-384 <link linkend="functions-hash-note">hash</link>。
       </para>
       <para>
        <literal>sha384('abc'::bytea)</literal>
        <returnvalue>\xcb00753f45a35e8bb5a03d699ac65007&zwsp;272c32ab0eded1631a8b605a43ff5bed&zwsp;8086072ba1e7cc2358baeca134c825a7</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sha512</primary>
        </indexterm>
        <function>sha512</function> ( <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        Computes the SHA-512 <link linkend="functions-hash-note">hash</link>
        of the binary string.
       </para>
       <para>
        <literal>sha512('abc'::bytea)</literal>
        <returnvalue>\xddaf35a193617abacc417349ae204131&zwsp;12e6fa4e89a97ea20a9eeee64b55d39a&zwsp;2192992a274fc1a836ba3c23a3feebbd&zwsp;454d4423643ce80e2a9ac94fa54ca49f</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sha512</primary>
        </indexterm>
        <function>sha512</function> ( <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        计算二进制字符串的 SHA-512 <link linkend="functions-hash-note">hash</link>。
       </para>
       <para>
        <literal>sha512('abc'::bytea)</literal>
        <returnvalue>\xddaf35a193617abacc417349ae204131&zwsp;12e6fa4e89a97ea20a9eeee64b55d39a&zwsp;2192992a274fc1a836ba3c23a3feebbd&zwsp;454d4423643ce80e2a9ac94fa54ca49f</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>substr</primary>
        </indexterm>
        <function>substr</function> ( <parameter>bytes</parameter> <type>bytea</type>, <parameter>start</parameter> <type>integer</type> <optional>, <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        Extracts the substring of <parameter>bytes</parameter> starting at
        the <parameter>start</parameter>'th byte,
        and extending for <parameter>count</parameter> bytes if that is
        specified.  (Same
        as <literal>substring(<parameter>bytes</parameter>
        from <parameter>start</parameter>
        for <parameter>count</parameter>)</literal>.)
       </para>
       <para>
        <literal>substr('\x1234567890'::bytea, 3, 2)</literal>
        <returnvalue>\x5678</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>substr</primary>
        </indexterm>
        <function>substr</function> ( <parameter>bytes</parameter> <type>bytea</type>, <parameter>start</parameter> <type>integer</type> <optional>, <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        从<parameter>start</parameter>字节开始提取<parameter>bytes</parameter>的子字符串，并扩展为<parameter>count</parameter>字节，如果这是指定的。
        (与 <literal>substring(<parameter>bytes</parameter> 从 <parameter>start</parameter> 到 <parameter>count</parameter>)</literal> 相同.)
       </para>
       <para>
        <literal>substr('\x1234567890'::bytea, 3, 2)</literal>
        <returnvalue>\x5678</returnvalue>
       </para></entry>
      </row>
    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para id="functions-zerobased-note">
   Functions <function>get_byte</function> and <function>set_byte</function>
   number the first byte of a binary string as byte 0.
   Functions <function>get_bit</function> and <function>set_bit</function>
   number bits from the right within each byte; for example bit 0 is the least
   significant bit of the first byte, and bit 15 is the most significant bit
   of the second byte.
  </para>
____________________________________________________________________________-->
  <para id="functions-zerobased-note">
   函数<function>get_byte</function>和<function>set_byte</function>把一个二进制串中的一个字节计数为字节 0。
   函数<function>get_bit</function>和<function>set_bit</function>在每一个字节中从右边起计数位；
   例如位 0 是第一个字节的最低有效位，而位 15 是第二个字节的最高有效位。
  </para>

<!--==========================orignal english content==========================
  <para id="functions-hash-note">
   For historical reasons, the function <function>md5</function>
   returns a hex-encoded value of type <type>text</type> whereas the SHA-2
   functions return type <type>bytea</type>.  Use the functions
   <link linkend="function-encode"><function>encode</function></link>
   and <link linkend="function-decode"><function>decode</function></link> to
   convert between the two.  For example write <literal>encode(sha256('abc'),
   'hex')</literal> to get a hex-encoded text representation,
   or <literal>decode(md5('abc'), 'hex')</literal> to get
   a <type>bytea</type> value.
  </para>
____________________________________________________________________________-->
  <para id="functions-hash-note">
   由于历史原因，函数<function>md5</function>返回的是一个十六进制编码的<type>text</type>值，而SHA-2函数返回类型<type>bytea</type>。
   可以使用函数<link linkend="function-encode"><function>encode</function></link>和<link linkend="function-decode"><function>decode</function></link>在两者之间转换。
   例如<literal>encode(sha256('abc'),'hex')</literal>可以得到一个十六进制编码的文本表示，或者<literal>decode(md5('abc'), 'hex')</literal>得到一个<type>bytea</type> 值。
  </para>

<!--==========================orignal english content==========================
  <para>
   <indexterm>
    <primary>character string</primary>
    <secondary>converting to binary string</secondary>
   </indexterm>
   <indexterm>
    <primary>binary string</primary>
    <secondary>converting to character string</secondary>
   </indexterm>
   Functions for converting strings between different character sets
   (encodings), and for representing arbitrary binary data in textual
   form, are shown in
   <xref linkend="functions-binarystring-conversions"/>.  For these
   functions, an argument or result of type <type>text</type> is expressed
   in the database's default encoding, while arguments or results of
   type <type>bytea</type> are in an encoding named by another argument.
  </para>
____________________________________________________________________________-->
  <para>
   <indexterm>
    <primary>character string</primary>
    <secondary>converting to binary string</secondary>
   </indexterm>
   <indexterm>
    <primary>binary string</primary>
    <secondary>converting to character string</secondary>
   </indexterm>
   用于在不同字符集(编码)之间转换字符串的函数，以及用于以文本形式表示任意二进制数据的函数，在<xref linkend="functions-binarystring-conversions"/>中显示。
   对于这些函数，类型为<type>text</type>的参数或结果表示为数据库的默认编码，而类型为<type>bytea</type>的参数或结果表示为由另一个参数命名的编码。
  </para>

  <table id="functions-binarystring-conversions">
<!--==========================orignal english content==========================
   <title>Text/Binary String Conversion Functions</title>
____________________________________________________________________________-->
   <title>Text/Binary String Conversion Functions</title>
   <tgroup cols="1">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry role="func_table_entry"><para role="func_signature">
       Function
      </para>
      <para>
       Description
      </para>
      <para>
       Example(s)
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="func_table_entry"><para role="func_signature">
       函数
      </para>
      <para>
       描述
      </para>
      <para>
       例子
      </para></entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>convert</primary>
       </indexterm>
       <function>convert</function> ( <parameter>bytes</parameter> <type>bytea</type>,
       <parameter>src_encoding</parameter> <type>name</type>,
       <parameter>dest_encoding</parameter> <type>name</type> )
       <returnvalue>bytea</returnvalue>
      </para>
      <para>
       Converts a binary string representing text in
       encoding <parameter>src_encoding</parameter>
       to a binary string in encoding <parameter>dest_encoding</parameter>
       (see <xref linkend="multibyte-conversions-supported"/> for
       available conversions).
      </para>
      <para>
       <literal>convert('text_in_utf8', 'UTF8', 'LATIN1')</literal>
       <returnvalue>\x746578745f696e5f75746638</returnvalue>
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>convert</primary>
       </indexterm>
       <function>convert</function> ( <parameter>bytes</parameter> <type>bytea</type>,
       <parameter>src_encoding</parameter> <type>name</type>,
       <parameter>dest_encoding</parameter> <type>name</type> )
       <returnvalue>bytea</returnvalue>
      </para>
      <para>
       将表示编码<parameter>src_encoding</parameter>的文本的二进制字符串转换为编码<parameter>dest_encoding</parameter>的二进制字符串
       (适用的转换请参阅<xref linkend="multibyte-conversions-supported"/>)。
      </para>
      <para>
       <literal>convert('text_in_utf8', 'UTF8', 'LATIN1')</literal>
       <returnvalue>\x746578745f696e5f75746638</returnvalue>
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>convert_from</primary>
       </indexterm>
       <function>convert_from</function> ( <parameter>bytes</parameter> <type>bytea</type>,
       <parameter>src_encoding</parameter> <type>name</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Converts a binary string representing text in
       encoding <parameter>src_encoding</parameter>
       to <type>text</type> in the database encoding
       (see <xref linkend="multibyte-conversions-supported"/> for
       available conversions).
      </para>
      <para>
       <literal>convert_from('text_in_utf8', 'UTF8')</literal>
       <returnvalue>text_in_utf8</returnvalue>
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>convert_from</primary>
       </indexterm>
       <function>convert_from</function> ( <parameter>bytes</parameter> <type>bytea</type>,
       <parameter>src_encoding</parameter> <type>name</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       将表示编码<parameter>src_encoding</parameter>的文本的二进制字符串转换为数据库编码中的<type>text</type>。
       (适用的转换请参阅 <xref linkend="multibyte-conversions-supported"/> )。	   
      </para>
      <para>
       <literal>convert_from('text_in_utf8', 'UTF8')</literal>
       <returnvalue>text_in_utf8</returnvalue>
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>convert_to</primary>
       </indexterm>
       <function>convert_to</function> ( <parameter>string</parameter> <type>text</type>,
       <parameter>dest_encoding</parameter> <type>name</type> )
       <returnvalue>bytea</returnvalue>
      </para>
      <para>
       Converts a <type>text</type> string (in the database encoding) to a
       binary string encoded in encoding <parameter>dest_encoding</parameter>
       (see <xref linkend="multibyte-conversions-supported"/> for
       available conversions).
      </para>
      <para>
       <literal>convert_to('some_text', 'UTF8')</literal>
       <returnvalue>\x736f6d655f74657874</returnvalue>
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>convert_to</primary>
       </indexterm>
       <function>convert_to</function> ( <parameter>string</parameter> <type>text</type>,
       <parameter>dest_encoding</parameter> <type>name</type> )
       <returnvalue>bytea</returnvalue>
      </para>
      <para>
       将<type>text</type>字符串(数据库编码)转换为编码<parameter>dest_encoding</parameter>中编码的二进制字符串。
       (适用的转换请参阅 <xref linkend="multibyte-conversions-supported"/> )。
      </para>
      <para>
       <literal>convert_to('some_text', 'UTF8')</literal>
       <returnvalue>\x736f6d655f74657874</returnvalue>
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="func_table_entry"><para role="func_signature">
       <indexterm id="function-encode">
        <primary>encode</primary>
       </indexterm>
       <function>encode</function> ( <parameter>bytes</parameter> <type>bytea</type>,
       <parameter>format</parameter> <type>text</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       Encodes binary data into a textual representation; supported
       <parameter>format</parameter> values are:
       <link linkend="encode-format-base64"><literal>base64</literal></link>,
       <link linkend="encode-format-escape"><literal>escape</literal></link>,
       <link linkend="encode-format-hex"><literal>hex</literal></link>.
      </para>
      <para>
       <literal>encode('123\000\001', 'base64')</literal>
       <returnvalue>MTIzAAE=</returnvalue>
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="func_table_entry"><para role="func_signature">
       <indexterm id="function-encode">
        <primary>encode</primary>
       </indexterm>
       <function>encode</function> ( <parameter>bytes</parameter> <type>bytea</type>,
       <parameter>format</parameter> <type>text</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
       将二进制数据编码成文本表示；支持的<parameter>format</parameter>值为：
       <link linkend="encode-format-base64"><literal>base64</literal></link>,
       <link linkend="encode-format-escape"><literal>escape</literal></link>,
       <link linkend="encode-format-hex"><literal>hex</literal></link>.
      </para>
      <para>
       <literal>encode('123\000\001', 'base64')</literal>
       <returnvalue>MTIzAAE=</returnvalue>
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="func_table_entry"><para role="func_signature">
       <indexterm id="function-decode">
        <primary>decode</primary>
       </indexterm>
       <function>decode</function> ( <parameter>string</parameter> <type>text</type>,
       <parameter>format</parameter> <type>text</type> )
       <returnvalue>bytea</returnvalue>
      </para>
      <para>
       Decodes binary data from a textual representation; supported
       <parameter>format</parameter> values are the same as
       for <function>encode</function>.
      </para>
      <para>
       <literal>decode('MTIzAAE=', 'base64')</literal>
       <returnvalue>\x3132330001</returnvalue>
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="func_table_entry"><para role="func_signature">
       <indexterm id="function-decode">
        <primary>decode</primary>
       </indexterm>
       <function>decode</function> ( <parameter>string</parameter> <type>text</type>,
       <parameter>format</parameter> <type>text</type> )
       <returnvalue>bytea</returnvalue>
      </para>
      <para>
       从文本表示中解码二进制数据;支持的<parameter>format</parameter>值与<function>encode</function>相同。
      </para>
      <para>
       <literal>decode('MTIzAAE=', 'base64')</literal>
       <returnvalue>\x3132330001</returnvalue>
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   The <function>encode</function> and <function>decode</function>
   functions support the following textual formats:

   <variablelist>
    <varlistentry id="encode-format-base64">
     <term>base64
     <indexterm>
      <primary>base64 format</primary>
     </indexterm></term>
     <listitem>
      <para>
       The <literal>base64</literal> format is that
       of <ulink url="https://tools.ietf.org/html/rfc2045#section-6.8">RFC
       2045 Section 6.8</ulink>.  As per the RFC, encoded lines are
       broken at 76 characters.  However instead of the MIME CRLF
       end-of-line marker, only a newline is used for end-of-line.
       The <function>decode</function> function ignores carriage-return,
       newline, space, and tab characters.  Otherwise, an error is
       raised when <function>decode</function> is supplied invalid
       base64 data &mdash; including when trailing padding is incorrect.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="encode-format-escape">
     <term>escape
     <indexterm>
      <primary>escape format</primary>
     </indexterm></term>
     <listitem>
      <para>
       The <literal>escape</literal> format converts zero bytes and
       bytes with the high bit set into octal escape sequences
       (<literal>\</literal><replaceable>nnn</replaceable>), and it doubles
       backslashes.  Other byte values are represented literally.
       The <function>decode</function> function will raise an error if a
       backslash is not followed by either a second backslash or three
       octal digits; it accepts other byte values unchanged.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="encode-format-hex">
     <term>hex
     <indexterm>
      <primary>hex format</primary>
     </indexterm></term>
     <listitem>
      <para>
       The <literal>hex</literal> format represents each 4 bits of
       data as one hexadecimal digit, <literal>0</literal>
       through <literal>f</literal>, writing the higher-order digit of
       each byte first.  The <function>encode</function> function outputs
       the <literal>a</literal>-<literal>f</literal> hex digits in lower
       case.  Because the smallest unit of data is 8 bits, there are
       always an even number of characters returned
       by <function>encode</function>.
       The <function>decode</function> function
       accepts the <literal>a</literal>-<literal>f</literal> characters in
       either upper or lower case.  An error is raised
       when <function>decode</function> is given invalid hex data
       &mdash; including when given an odd number of characters.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
____________________________________________________________________________-->
  <para>
   <function>encode</function> 和 <function>decode</function> 函数支持以下文本格式:

   <variablelist>
    <varlistentry id="encode-format-base64">
     <term>base64
     <indexterm>
      <primary>base64 format</primary>
     </indexterm></term>
     <listitem>
      <para>
       <literal>base64</literal>格式是<ulink url="https://tools.ietf.org/html/rfc2045#section-6.8">RFC 2045 Section 6.8</ulink>。
       根据RFC，编码的行被分割为76个字符。但是，作为MIME CRLF行结束标记的替代，只有换行符用于行结束。
       <function>decode</function>函数忽略回车、换行、空格和制表符。
       否则，当<function>decode</function>被提供了无效的base64数据&mdash;包括结尾填充不正确时。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="encode-format-escape">
     <term>escape
     <indexterm>
      <primary>escape format</primary>
     </indexterm></term>
     <listitem>
      <para>
       <literal>escape</literal>格式将零字节和设置了高位的字节转换为八进制转义序列(<literal>\</literal><replaceable>nnn</replaceable>)，并将反斜杠加倍。
       其他字节值按字面意思表示。
       <function>decode</function>函数如果反斜杠后面没有第二个反斜杠或三个八进制数字将引发错误;它接受其他未变化的字节值。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="encode-format-hex">
     <term>hex
     <indexterm>
      <primary>hex format</primary>
     </indexterm></term>
     <listitem>
      <para>
       <literal>hex</literal>格式将每4位数据表示为一个十六进制数字，从<literal>0</literal>到<literal>f</literal>，首先写入每个字节的高阶数字。
       <function>encode</function>函数输出<literal>a</literal>-<literal>f</literal>的十六进制小写数字。
       因为数据的最小单位是8位，所以<function>encode</function>总是返回偶数个字符。
       <function>decode</function>函数接受大写或小写的<literal>a</literal>-<literal>f</literal>字符。
       当<function>decode</function>给出无效的十六进制数据&mdash;时将引发一个错误，包括给定奇数个字符时。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

<!--==========================orignal english content==========================
  <para>
   See also the aggregate function <function>string_agg</function> in
   <xref linkend="functions-aggregate"/> and the large object functions
   in <xref linkend="lo-funcs"/>.
  </para>
____________________________________________________________________________-->
  <para>
   参见<xref linkend="functions-aggregate"/>中的聚集函数<function>string_agg</function>以及<xref linkend="lo-funcs"/>中的大对象函数。
  </para>
 </sect1>

  <sect1 id="functions-bitstring">
<!--==========================orignal english content==========================
   <title>Bit String Functions and Operators</title>
____________________________________________________________________________-->
   <title>位串函数和操作符</title>

<!--==========================orignal english content==========================
   <indexterm zone="functions-bitstring">
    <primary>bit strings</primary>
    <secondary>functions</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="functions-bitstring">
    <primary>bit strings</primary>
    <secondary>functions</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    This section describes functions and operators for examining and
    manipulating bit strings, that is values of the types
    <type>bit</type> and <type>bit varying</type>.  (While only
    type <type>bit</type> is mentioned in these tables, values of
    type <type>bit varying</type> can be used interchangeably.)
    Bit strings support the usual comparison operators shown in
    <xref linkend="functions-comparison-op-table"/>, as well as the
    operators shown in <xref linkend="functions-bit-string-op-table"/>.
   </para>
____________________________________________________________________________-->
   <para>
    本节描述用于检查和操作位串的函数和操作符，也就是操作类型为<type>bit</type>和<type>bit varying</type>的值的函数和操作符。
    (虽然这些表中只提到了<type>bit</type>类型，但<type>bit varying</type>类型的值可以互换使用。)
    位字符串支持<xref linkend="functions-comparison-op-table"/>中显示的常用比较操作符，就像<xref linkend="functions-bit-string-op-table"/>中显示的操作符。
   </para>

   <table id="functions-bit-string-op-table">
<!--==========================orignal english content==========================
    <title>Bit String Operators</title>
____________________________________________________________________________-->
    <title>位串操作符</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Operator
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        操作符
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bit</type> <literal>||</literal> <type>bit</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        Concatenation
       </para>
       <para>
        <literal>B'10001' || B'011'</literal>
        <returnvalue>10001011</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bit</type> <literal>||</literal> <type>bit</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        连接
       </para>
       <para>
        <literal>B'10001' || B'011'</literal>
        <returnvalue>10001011</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bit</type> <literal>&amp;</literal> <type>bit</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        Bitwise AND (inputs must be of equal length)
       </para>
       <para>
        <literal>B'10001' &amp; B'01101'</literal>
        <returnvalue>00001</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bit</type> <literal>&amp;</literal> <type>bit</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        按位与（输入的长度必须相等）
       </para>
       <para>
        <literal>B'10001' &amp; B'01101'</literal>
        <returnvalue>00001</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bit</type> <literal>|</literal> <type>bit</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        Bitwise OR (inputs must be of equal length)
       </para>
       <para>
        <literal>B'10001' | B'01101'</literal>
        <returnvalue>11101</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bit</type> <literal>|</literal> <type>bit</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        按位或 （输入的长度必须相等）
       </para>
       <para>
        <literal>B'10001' | B'01101'</literal>
        <returnvalue>11101</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bit</type> <literal>#</literal> <type>bit</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        Bitwise exclusive OR (inputs must be of equal length)
       </para>
       <para>
        <literal>B'10001' # B'01101'</literal>
        <returnvalue>11100</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bit</type> <literal>#</literal> <type>bit</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        按位异或 （输入的长度必须相等）
       </para>
       <para>
        <literal>B'10001' # B'01101'</literal>
        <returnvalue>11100</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>~</literal> <type>bit</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        Bitwise NOT
       </para>
       <para>
        <literal>~ B'10001'</literal>
        <returnvalue>01110</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>~</literal> <type>bit</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        按位求反
       </para>
       <para>
        <literal>~ B'10001'</literal>
        <returnvalue>01110</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bit</type> <literal>&lt;&lt;</literal> <type>integer</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        Bitwise shift left
        (string length is preserved)
       </para>
       <para>
        <literal>B'10001' &lt;&lt; 3</literal>
        <returnvalue>01000</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bit</type> <literal>&lt;&lt;</literal> <type>integer</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        按位左移（字符串长度被保留）
       </para>
       <para>
        <literal>B'10001' &lt;&lt; 3</literal>
        <returnvalue>01000</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bit</type> <literal>&gt;&gt;</literal> <type>integer</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        Bitwise shift right
        (string length is preserved)
       </para>
       <para>
        <literal>B'10001' &gt;&gt; 2</literal>
        <returnvalue>00100</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bit</type> <literal>&gt;&gt;</literal> <type>integer</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        按位右移（字符串长度被保留）
       </para>
       <para>
        <literal>B'10001' &gt;&gt; 2</literal>
        <returnvalue>00100</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    Some of the functions available for binary strings are also available
    for bit strings, as shown in <xref linkend="functions-bit-string-table"/>.
   </para>
____________________________________________________________________________-->
   <para>
    一些可用于二进制字符串的函数也可用于位字符串，如<xref linkend="functions-bit-string-table"/>中所示。
   </para>

   <table id="functions-bit-string-table">
<!--==========================orignal english content==========================
    <title>Bit String Functions</title>
____________________________________________________________________________-->
    <title>位字符串函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bit_length</primary>
        </indexterm>
        <function>bit_length</function> ( <type>bit</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns number of bits in the bit string.
       </para>
       <para>
        <literal>bit_length(B'10111')</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bit_length</primary>
        </indexterm>
        <function>bit_length</function> ( <type>bit</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回位字符串中的位数。
       </para>
       <para>
        <literal>bit_length(B'10111')</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>length</primary>
        </indexterm>
        <indexterm>
         <primary>bit string</primary>
         <secondary>length</secondary>
        </indexterm>
        <function>length</function> ( <type>bit</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns number of bits in the bit string.
       </para>
       <para>
        <literal>length(B'10111')</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>length</primary>
        </indexterm>
        <indexterm>
         <primary>bit string</primary>
         <secondary>length</secondary>
        </indexterm>
        <function>length</function> ( <type>bit</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回位字符串中的位数。
       </para>
       <para>
        <literal>length(B'10111')</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>octet_length</primary>
        </indexterm>
        <function>octet_length</function> ( <type>bit</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns number of bytes in the bit string.
       </para>
       <para>
        <literal>octet_length(B'1011111011')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>octet_length</primary>
        </indexterm>
        <function>octet_length</function> ( <type>bit</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回位字符串中的字节数。
       </para>
       <para>
        <literal>octet_length(B'1011111011')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>overlay</primary>
        </indexterm>
        <function>overlay</function> ( <parameter>bits</parameter> <type>bit</type> <literal>PLACING</literal> <parameter>newsubstring</parameter> <type>bit</type> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        Replaces the substring of <parameter>bits</parameter> that starts at
        the <parameter>start</parameter>'th bit and extends
        for <parameter>count</parameter> bits
        with <parameter>newsubstring</parameter>.
        If <parameter>count</parameter> is omitted, it defaults to the length
        of <parameter>newsubstring</parameter>.
       </para>
       <para>
        <literal>overlay(B'01010101010101010' placing B'11111' from 2 for 3)</literal>
        <returnvalue>0111110101010101010</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>overlay</primary>
        </indexterm>
        <function>overlay</function> ( <parameter>bits</parameter> <type>bit</type> <literal>PLACING</literal> <parameter>newsubstring</parameter> <type>bit</type> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        替换从<parameter>start</parameter>位开始的<parameter>bits</parameter>的子字符串，并将<parameter>newsubstring</parameter>扩展<parameter>count</parameter>位。
        如果<parameter>count</parameter>被省略，默认为<parameter>newsubstring</parameter>的长度。
       </para>
       <para>
        <literal>overlay(B'01010101010101010' placing B'11111' from 2 for 3)</literal>
        <returnvalue>0111110101010101010</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>position</primary>
        </indexterm>
        <function>position</function> ( <parameter>substring</parameter> <type>bit</type> <literal>IN</literal> <parameter>bits</parameter> <type>bit</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns starting index of specified <parameter>substring</parameter>
        within <parameter>bits</parameter>, or zero if it's not present.
       </para>
       <para>
        <literal>position(B'010' in B'000001101011')</literal>
        <returnvalue>8</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>position</primary>
        </indexterm>
        <function>position</function> ( <parameter>substring</parameter> <type>bit</type> <literal>IN</literal> <parameter>bits</parameter> <type>bit</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        按返回指定<parameter>substring</parameter>的起始索引，以<parameter>bits</parameter>为单位，如果不存在则返回0。
       </para>
       <para>
        <literal>position(B'010' in B'000001101011')</literal>
        <returnvalue>8</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>substring</primary>
        </indexterm>
        <function>substring</function> ( <parameter>bits</parameter> <type>bit</type> <optional> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> </optional> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        Extracts the substring of <parameter>bits</parameter> starting at
        the <parameter>start</parameter>'th bit if that is specified,
        and stopping after <parameter>count</parameter> bits if that is
        specified.  Provide at least one of <parameter>start</parameter>
        and <parameter>count</parameter>.
       </para>
       <para>
        <literal>substring(B'110010111111' from 3 for 2)</literal>
        <returnvalue>00</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>substring</primary>
        </indexterm>
        <function>substring</function> ( <parameter>bits</parameter> <type>bit</type> <optional> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> </optional> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        如果指定了起始位，则提取从<parameter>start</parameter>位开始的<parameter>bits</parameter>的子字符串，如果指定了计数位，则在<parameter>count</parameter>位之后停止。
        <parameter>start</parameter>和<parameter>count</parameter>至少提供一个。
       </para>
       <para>
        <literal>substring(B'110010111111' from 3 for 2)</literal>
        <returnvalue>00</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>get_bit</primary>
        </indexterm>
        <function>get_bit</function> ( <parameter>bits</parameter> <type>bit</type>,
        <parameter>n</parameter> <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Extracts <parameter>n</parameter>'th bit
        from bit string; the first (leftmost) bit is bit 0.
       </para>
       <para>
        <literal>get_bit(B'101010101010101010', 6)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>get_bit</primary>
        </indexterm>
        <function>get_bit</function> ( <parameter>bits</parameter> <type>bit</type>,
        <parameter>n</parameter> <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        从位字符串中提取第<parameter>n</parameter>位；第一个(最左)位为第0位。
       </para>
       <para>
        <literal>get_bit(B'101010101010101010', 6)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>set_bit</primary>
        </indexterm>
        <function>set_bit</function> ( <parameter>bits</parameter> <type>bit</type>,
        <parameter>n</parameter> <type>integer</type>,
        <parameter>newvalue</parameter> <type>integer</type> )
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        Sets <parameter>n</parameter>'th bit in
        bit string to <parameter>newvalue</parameter>;
        the first (leftmost) bit is bit 0.
       </para>
       <para>
        <literal>set_bit(B'101010101010101010', 6, 0)</literal>
        <returnvalue>101010001010101010</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>set_bit</primary>
        </indexterm>
        <function>set_bit</function> ( <parameter>bits</parameter> <type>bit</type>,
        <parameter>n</parameter> <type>integer</type>,
        <parameter>newvalue</parameter> <type>integer</type> )
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        将位字符串中的第<parameter>n</parameter>位设置为<parameter>newvalue</parameter>；第一个(最左)位是第0位。
       </para>
       <para>
        <literal>set_bit(B'101010101010101010', 6, 0)</literal>
        <returnvalue>101010001010101010</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    In addition, it is possible to cast integral values to and from type
    <type>bit</type>.
    Casting an integer to <type>bit(n)</type> copies the rightmost
    <literal>n</literal> bits.  Casting an integer to a bit string width wider
    than the integer itself will sign-extend on the left.
    Some examples:
<programlisting>
44::bit(10)                    <lineannotation>0000101100</lineannotation>
44::bit(3)                     <lineannotation>100</lineannotation>
cast(-44 as bit(12))           <lineannotation>111111010100</lineannotation>
'1110'::bit(4)::integer        <lineannotation>14</lineannotation>
</programlisting>
    Note that casting to just <quote>bit</quote> means casting to
    <literal>bit(1)</literal>, and so will deliver only the least significant
    bit of the integer.
   </para>
____________________________________________________________________________-->
   <para>
    另外，我们可以在整数和<type>bit</type>之间来回转换。
    将一个整数转换为<type>bit(n)</type>会复制最右边的<literal>n</literal>位。
    将一个整数转换为比整数本身更宽的位字符串宽度将在左边进行符号扩展。一些例子：
<programlisting>
44::bit(10)                    <lineannotation>0000101100</lineannotation>
44::bit(3)                     <lineannotation>100</lineannotation>
cast(-44 as bit(12))           <lineannotation>111111010100</lineannotation>
'1110'::bit(4)::integer        <lineannotation>14</lineannotation>
</programlisting>
    请注意，如果只是转换为<quote>bit</quote>，意思是转换成<literal>bit(1)</literal>，因此只会转换整数的最低有效位。
   </para>
  </sect1>


 <sect1 id="functions-matching">
<!--==========================orignal english content==========================
  <title>Pattern Matching</title>
____________________________________________________________________________-->
  <title>模式匹配</title>

<!--==========================orignal english content==========================
  <indexterm zone="functions-matching">
   <primary>pattern matching</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="functions-matching">
   <primary>pattern matching</primary>
  </indexterm>

<!--==========================orignal english content==========================
   <para>
    There are three separate approaches to pattern matching provided
    by <productname>PostgreSQL</productname>: the traditional
    <acronym>SQL</acronym> <function>LIKE</function> operator, the
    more recent <function>SIMILAR TO</function> operator (added in
    SQL:1999), and <acronym>POSIX</acronym>-style regular
    expressions.  Aside from the basic <quote>does this string match
    this pattern?</quote> operators, functions are available to extract
    or replace matching substrings and to split a string at matching
    locations.
   </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>提供了三种独立的实现模式匹配的方法：<acronym>SQL</acronym> <function>LIKE</function>操作符、更近一些的<function>SIMILAR TO</function>操作符（SQL:1999 里添加进来的）和<acronym>POSIX</acronym>-风格的正则表达式。除了这些基本的<quote>这个串匹配这个模式吗？</quote>操作符外，还有一些函数可用于提取或替换匹配子串并在匹配位置分离一个串。
   </para>

   <tip>
<!--==========================orignal english content==========================
    <para>
     If you have pattern matching needs that go beyond this,
     consider writing a user-defined function in Perl or Tcl.
    </para>
____________________________________________________________________________-->
    <para>
     如果你的模式匹配的要求超出了这些，请考虑用 Perl 或 Tcl 写一个用户定义的函数。
    </para>
   </tip>

   <caution>
<!--==========================orignal english content==========================
    <para>
     While most regular-expression searches can be executed very quickly,
     regular expressions can be contrived that take arbitrary amounts of
     time and memory to process.  Be wary of accepting regular-expression
     search patterns from hostile sources.  If you must do so, it is
     advisable to impose a statement timeout.
    </para>
____________________________________________________________________________-->
    <para>
     虽然大部分的正则表达式搜索都能被很快地执行，但是正则表达式仍可能被
     人为地弄成需要任意长的时间和任意量的内存进行处理。要当心从不怀好意
     的来源接受正则表达式搜索模式。如果必须这样做，建议加上语句超时限制。
    </para>

<!--==========================orignal english content==========================
    <para>
     Searches using <function>SIMILAR TO</function> patterns have the same
     security hazards, since <function>SIMILAR TO</function> provides many
     of the same capabilities as <acronym>POSIX</acronym>-style regular
     expressions.
    </para>
____________________________________________________________________________-->
    <para>
     使用<function>SIMILAR TO</function>模式的搜索具有同样的安全性危险，
     因为<function>SIMILAR TO</function>提供了很多和
     <acronym>POSIX</acronym>-风格正则表达式相同的能力。
    </para>

<!--==========================orignal english content==========================
    <para>
     <function>LIKE</function> searches, being much simpler than the other
     two options, are safer to use with possibly-hostile pattern sources.
    </para>
____________________________________________________________________________-->
    <para>
     <function>LIKE</function>搜索比其他两种选项简单得多，因此在使用
     不怀好意的模式来源时要更安全些。
    </para>
   </caution>

<!--==========================orignal english content==========================
   <para>
    The pattern matching operators of all three kinds do not support
    nondeterministic collations.  If required, apply a different collation to
    the expression to work around this limitation.
   </para>
____________________________________________________________________________-->
   <para>
    这三种类型的模式匹配算子都不支持非确定性拼贴。 如果需要的话，可以在表达式中应用不同的拼贴来绕过这个限制。
   </para>

  <sect2 id="functions-like">
<!--==========================orignal english content==========================
   <title><function>LIKE</function></title>
____________________________________________________________________________-->
   <title><function>LIKE</function></title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>LIKE</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>LIKE</primary>
   </indexterm>

<!--==========================orignal english content==========================
<synopsis>
<replaceable>string</replaceable> LIKE <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
<replaceable>string</replaceable> NOT LIKE <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>string</replaceable> LIKE <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
<replaceable>string</replaceable> NOT LIKE <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
</synopsis>

<!--==========================orignal english content==========================
    <para>
     The <function>LIKE</function> expression returns true if the
     <replaceable>string</replaceable> matches the supplied
     <replaceable>pattern</replaceable>.  (As
     expected, the <function>NOT LIKE</function> expression returns
     false if <function>LIKE</function> returns true, and vice versa.
     An equivalent expression is
     <literal>NOT (<replaceable>string</replaceable> LIKE
      <replaceable>pattern</replaceable>)</literal>.)
    </para>
____________________________________________________________________________-->
    <para>
     如果该<replaceable>string</replaceable>匹配了提供的<replaceable>pattern</replaceable>，那么<function>LIKE</function>表达式返回真（和预期的一样，如果<function>LIKE</function>返回真，那么<function>NOT LIKE</function>表达式返回假， 反之亦然。一个等效的表达式是<literal>NOT (<replaceable>string</replaceable> LIKE <replaceable>pattern</replaceable>)</literal>）。
    </para>

<!--==========================orignal english content==========================
    <para>
     If <replaceable>pattern</replaceable> does not contain percent
     signs or underscores, then the pattern only represents the string
     itself; in that case <function>LIKE</function> acts like the
     equals operator.  An underscore (<literal>_</literal>) in
     <replaceable>pattern</replaceable> stands for (matches) any single
     character; a percent sign (<literal>%</literal>) matches any sequence
     of zero or more characters.
    </para>
____________________________________________________________________________-->
    <para>
     如果<replaceable>pattern</replaceable>不包含百分号或者下划线，那么该模式只代表它本身的串；这时候<function>LIKE</function>的行为就象等号操作符。在<replaceable>pattern</replaceable>里的下划线 （<literal>_</literal>）代表（匹配）任何单个字符； 而一个百分号（<literal>%</literal>）匹配任何零或更多个字符的序列。
    </para>

<!--==========================orignal english content==========================
   <para>
    Some examples:
<programlisting>
'abc' LIKE 'abc'    <lineannotation>true</lineannotation>
'abc' LIKE 'a%'     <lineannotation>true</lineannotation>
'abc' LIKE '_b_'    <lineannotation>true</lineannotation>
'abc' LIKE 'c'      <lineannotation>false</lineannotation>
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    一些例子：
<programlisting>
'abc' LIKE 'abc'    <lineannotation>true</lineannotation>
'abc' LIKE 'a%'     <lineannotation>true</lineannotation>
'abc' LIKE '_b_'    <lineannotation>true</lineannotation>
'abc' LIKE 'c'      <lineannotation>false</lineannotation>
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    <function>LIKE</function> pattern matching always covers the entire
    string.  Therefore, if it's desired to match a sequence anywhere within
    a string, the pattern must start and end with a percent sign.
   </para>
____________________________________________________________________________-->
   <para>
    <function>LIKE</function>模式匹配总是覆盖整个串。因此，要匹配在串内任何位置的序列，该模式必须以百分号开头和结尾。
   </para>

<!--==========================orignal english content==========================
   <para>
    To match a literal underscore or percent sign without matching
    other characters, the respective character in
    <replaceable>pattern</replaceable> must be
    preceded by the escape character.  The default escape
    character is the backslash but a different one can be selected by
    using the <literal>ESCAPE</literal> clause.  To match the escape
    character itself, write two escape characters.
   </para>
____________________________________________________________________________-->
   <para>
    要匹配文本的下划线或者百分号，而不是匹配其它字符， 在<replaceable>pattern</replaceable>里相应的字符必须 前导逃逸字符。缺省的逃逸字符是反斜线，但是你可以用<literal>ESCAPE</literal>子句指定一个不同的逃逸字符。 要匹配逃逸字符本身，写两个逃逸字符。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     If you have <xref linkend="guc-standard-conforming-strings"/> turned off,
     any backslashes you write in literal string constants will need to be
     doubled.  See <xref linkend="sql-syntax-strings"/> for more information.
    </para>
____________________________________________________________________________-->
    <para>
     如果你关掉了<xref linkend="guc-standard-conforming-strings"/>，你在文串常量中写的任何反斜线都需要被双写。详见<xref linkend="sql-syntax-strings"/>。
    </para>
   </note>

<!--==========================orignal english content==========================
   <para>
    It's also possible to select no escape character by writing
    <literal>ESCAPE ''</literal>.  This effectively disables the
    escape mechanism, which makes it impossible to turn off the
    special meaning of underscore and percent signs in the pattern.
   </para>
____________________________________________________________________________-->
   <para>
    请注意反斜线在串文本里已经有特殊含义了，所以如果你写一个 包含反斜线的模式常量，那你就要在 SQL 语句里写两个反斜线。 因此，写一个匹配单个反斜线的模式实际上要在语句里写四个反斜线。 你可以通过用 ESCAPE 选择一个不同的逃逸字符 来避免这样；这样反斜线就不再是 LIKE 的特殊字符了。 但仍然是字符文本分析器的特殊字符，所以你还是需要两个反斜线。)
    我们也可以通过写<literal>ESCAPE ''</literal>的方式不选择逃逸字符，这样可以有效地禁用逃逸机制，但是没有办法关闭下划线和百分号在模式中的特殊含义。
   </para>

<!--==========================orignal english content==========================
   <para>
    According to the SQL standard, omitting <literal>ESCAPE</literal>
    means there is no escape character (rather than defaulting to a
    backslash), and a zero-length <literal>ESCAPE</literal> value is
    disallowed.  <productname>PostgreSQL</productname>'s behavior in
    this regard is therefore slightly nonstandard.
   </para>
____________________________________________________________________________-->
   <para>
    根据SQL标准，省略<literal>ESCAPE</literal>意味着没有转义字符(而不是默认为反斜杠)，并且不允许使用零长度的<literal>ESCAPE</literal>值。
	因此，<productname>PostgreSQL</productname>在这方面的行为有点不标准。
   </para>

<!--==========================orignal english content==========================
   <para>
    The key word <token>ILIKE</token> can be used instead of
    <token>LIKE</token> to make the match case-insensitive according
    to the active locale.  This is not in the <acronym>SQL</acronym> standard but is a
    <productname>PostgreSQL</productname> extension.
   </para>
____________________________________________________________________________-->
   <para>
    关键字<token>ILIKE</token>可以用于替换<token>LIKE</token>， 它令该匹配根据活动区域成为大小写无关。这个不属于<acronym>SQL</acronym>标准而是一个<productname>PostgreSQL</productname>扩展。
   </para>

<!--==========================orignal english content==========================
   <para>
    The operator <literal>~~</literal> is equivalent to
    <function>LIKE</function>, and <literal>~~*</literal> corresponds to
    <function>ILIKE</function>.  There are also
    <literal>!~~</literal> and <literal>!~~*</literal> operators that
    represent <function>NOT LIKE</function> and <function>NOT
    ILIKE</function>, respectively.  All of these operators are
    <productname>PostgreSQL</productname>-specific.  You may see these
    operator names in <command>EXPLAIN</command> output and similar
    places, since the parser actually translates <function>LIKE</function>
    et al. to these operators.
   </para>
____________________________________________________________________________-->
   <para>
    操作符<literal>~~</literal>等效于<function>LIKE</function>， 而<literal>~~*</literal>对应<function>ILIKE</function>。 
    还有 <literal>!~~</literal>和<literal>!~~*</literal>操作符分别代表<function>NOT LIKE</function>和<function>NOT ILIKE</function>。
    所有这些操作符都是<productname>PostgreSQL</productname>特有的。
    你可能会在<command>EXPLAIN</command>输出和类似的地方看到这些操作符名称，因为解析器实际上将<function>LIKE</function>等翻译成这些运算符。
   </para>

<!--==========================orignal english content==========================
   <para>
    The phrases <function>LIKE</function>, <function>ILIKE</function>,
    <function>NOT LIKE</function>, and <function>NOT ILIKE</function> are
    generally treated as operators
    in <productname>PostgreSQL</productname> syntax; for example they can
    be used in <replaceable>expression</replaceable>
    <replaceable>operator</replaceable> ANY
    (<replaceable>subquery</replaceable>) constructs, although
    an <literal>ESCAPE</literal> clause cannot be included there.  In some
    obscure cases it may be necessary to use the underlying operator names
    instead.
   </para>
____________________________________________________________________________-->
   <para>
    短语<function>LIKE</function>，<function>ILIKE</function>，<function>NOT LIKE</function>，和 <function>NOT ILIKE</function> 在<productname>PostgreSQL</productname>语法中通常被视为操作符；
    例如，它们可以用于<replaceable>expression</replaceable> <replaceable>operator</replaceable>的任何（<replaceable>subquery</replaceable>）构造，尽管这里不能包含<literal>ESCAPE</literal>子句。
    在某些晦涩难懂的情况下，可能需要用底层操作符名称替代。
   </para>

<!--==========================orignal english content==========================
   <para>
    Also see the prefix operator <literal>^@</literal> and corresponding
    <function>starts_with</function> function, which are useful in cases
    where simply matching the beginning of a string is needed.
   </para>
____________________________________________________________________________-->
   <para>
    还可参见前缀操作符<literal>^@</literal>和相应的<function>starts_with</function>函数，在需要简单匹配字符串开头的情况下比较有用。
   </para>
  </sect2>


  <sect2 id="functions-similarto-regexp">
<!--==========================orignal english content==========================
   <title><function>SIMILAR TO</function> Regular Expressions</title>
____________________________________________________________________________-->
   <title><function>SIMILAR TO</function>正则表达式</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>regular expression</primary>
    <!-&minus; <seealso>pattern matching</seealso> breaks index build -&minus;>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>regular expression</primary>
    <!-- <seealso>pattern matching</seealso> breaks index build -->
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>SIMILAR TO</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>SIMILAR TO</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>substring</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>substring</primary>
   </indexterm>

<!--==========================orignal english content==========================
<synopsis>
<replaceable>string</replaceable> SIMILAR TO <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
<replaceable>string</replaceable> NOT SIMILAR TO <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>string</replaceable> SIMILAR TO <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
<replaceable>string</replaceable> NOT SIMILAR TO <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
</synopsis>

<!--==========================orignal english content==========================
   <para>
    The <function>SIMILAR TO</function> operator returns true or
    false depending on whether its pattern matches the given string.
    It is similar to <function>LIKE</function>, except that it
    interprets the pattern using the SQL standard's definition of a
    regular expression.  SQL regular expressions are a curious cross
    between <function>LIKE</function> notation and common (POSIX) regular
    expression notation.
   </para>
____________________________________________________________________________-->
   <para>
    <function>SIMILAR TO</function>操作符根据自己的模式是否匹配给定串而返回真或者假。 
    它和<function>LIKE</function>非常类似，只不过它使用 SQL 标准定义的正则表达式理解模式。 
    SQL 正则表达式是在<function>LIKE</function>标记和普通的(POSIX)正则表达式标记的奇怪的杂交。
   </para>

<!--==========================orignal english content==========================
   <para>
    Like <function>LIKE</function>, the <function>SIMILAR TO</function>
    operator succeeds only if its pattern matches the entire string;
    this is unlike common regular expression behavior where the pattern
    can match any part of the string.
    Also like
    <function>LIKE</function>, <function>SIMILAR TO</function> uses
    <literal>_</literal> and <literal>%</literal> as wildcard characters denoting
    any single character and any string, respectively (these are
    comparable to <literal>.</literal> and <literal>.*</literal> in POSIX regular
    expressions).
   </para>
____________________________________________________________________________-->
   <para>
    类似<function>LIKE</function>，<function>SIMILAR TO</function>操作符只有在它的模式匹配整个串的时候才能成功；这一点和普通的 正则表达式的行为不同，在普通的正则表达式里，模式匹配串的任意部分。 和<function>LIKE</function>类似的地方还有，<function>SIMILAR TO</function>使用<literal>_</literal>和<literal>%</literal>作为分别代表任意单个字符和任意串的通配符（这些可以比得上 POSIX 正则表达式里的<literal>.</literal>和<literal>.*</literal>）。
   </para>

<!--==========================orignal english content==========================
   <para>
    In addition to these facilities borrowed from <function>LIKE</function>,
    <function>SIMILAR TO</function> supports these pattern-matching
    metacharacters borrowed from POSIX regular expressions:

   <itemizedlist>
    <listitem>
     <para>
      <literal>|</literal> denotes alternation (either of two alternatives).
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>*</literal> denotes repetition of the previous item zero
      or more times.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>+</literal> denotes repetition of the previous item one
      or more times.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>?</literal> denotes repetition of the previous item zero
      or one time.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>{</literal><replaceable>m</replaceable><literal>}</literal> denotes repetition
      of the previous item exactly <replaceable>m</replaceable> times.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>{</literal><replaceable>m</replaceable><literal>,}</literal> denotes repetition
      of the previous item <replaceable>m</replaceable> or more times.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal>
      denotes repetition of the previous item at least <replaceable>m</replaceable> and
      not more than <replaceable>n</replaceable> times.
     </para>
    </listitem>
    <listitem>
     <para>
      Parentheses <literal>()</literal> can be used to group items into
      a single logical item.
     </para>
    </listitem>
    <listitem>
     <para>
      A bracket expression <literal>[...]</literal> specifies a character
      class, just as in POSIX regular expressions.
     </para>
    </listitem>
   </itemizedlist>

    Notice that the period (<literal>.</literal>) is not a metacharacter
    for <function>SIMILAR TO</function>.
   </para>
____________________________________________________________________________-->
   <para>
    除了这些从<function>LIKE</function>借用的功能之外，<function>SIMILAR TO</function>支持下面这些从 POSIX 正则表达式借用的 模式匹配元字符：

   <itemizedlist>
    <listitem>
     <para>
      <literal>|</literal>表示选择（两个候选之一）。
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>*</literal>表示重复前面的项零次或更多次。
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>+</literal>表示重复前面的项一次或更多次。
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>?</literal>表示重复前面的项零次或一次。
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>{</literal><replaceable>m</replaceable><literal>}</literal>表示重复前面的项刚好<replaceable>m</replaceable>次。
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>{</literal><replaceable>m</replaceable><literal>,}</literal>表示重复前面的项<replaceable>m</replaceable>次或更多次。
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal>表示重复前面的项至少<replaceable>m</replaceable>次并且不超过<replaceable>n</replaceable>次。
     </para>
    </listitem>
    <listitem>
     <para>
      可以使用圆括号<literal>()</literal>把多个项组合成一个逻辑项。
     </para>
    </listitem>
    <listitem>
     <para>
      一个方括号表达式<literal>[...]</literal>声明一个字符类，就像 POSIX 正则表达式一样。
     </para>
    </listitem>
   </itemizedlist>

    注意点号（<literal>.</literal>）不是<function>SIMILAR TO</function>的一个元字符。
   </para>

<!--==========================orignal english content==========================
   <para>
    As with <function>LIKE</function>, a backslash disables the special
    meaning of any of these metacharacters.  A different escape character
    can be specified with <literal>ESCAPE</literal>, or the escape
    capability can be disabled by writing <literal>ESCAPE ''</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    与<function>LIKE</function>一样，反斜杠将禁用这些元字符的特殊含义。
    可以用 <literal>ESCAPE</literal> 来指定不同的转义字符，或者可以通过写 <literal>ESCAPE ''</literal> 来禁用转义功能。
   </para>

<!--==========================orignal english content==========================
   <para>
    According to the SQL standard, omitting <literal>ESCAPE</literal>
    means there is no escape character (rather than defaulting to a
    backslash), and a zero-length <literal>ESCAPE</literal> value is
    disallowed.  <productname>PostgreSQL</productname>'s behavior in
    this regard is therefore slightly nonstandard.
   </para>
____________________________________________________________________________-->
   <para>
    根据SQL标准，省略<literal>ESCAPE</literal>意味着没有转义字符(而不是默认为反斜杠)，并且不允许使用零长度的<literal>ESCAPE</literal>值。
    <productname>PostgreSQL</productname>在这方面的行为有点不标准。
   </para>

<!--==========================orignal english content==========================
   <para>
    Another nonstandard extension is that following the escape character
    with a letter or digit provides access to the escape sequences
    defined for POSIX regular expressions; see
    <xref linkend="posix-character-entry-escapes-table"/>,
    <xref linkend="posix-class-shorthand-escapes-table"/>, and
    <xref linkend="posix-constraint-escapes-table"/> below.
   </para>
____________________________________________________________________________-->
   <para>
    另一个非标准扩展是，在转义字符后面跟着一个字母或数字提供了对为POSIX正则表达式定义的转义序列的访问；参见下面的
    <xref linkend="posix-character-entry-escapes-table"/>，<xref linkend="posix-class-shorthand-escapes-table"/>，和 <xref linkend="posix-constraint-escapes-table"/> 。
   </para>

<!--==========================orignal english content==========================
   <para>
    Some examples:
<programlisting>
'abc' SIMILAR TO 'abc'          <lineannotation>true</lineannotation>
'abc' SIMILAR TO 'a'            <lineannotation>false</lineannotation>
'abc' SIMILAR TO '%(b|d)%'      <lineannotation>true</lineannotation>
'abc' SIMILAR TO '(b|c)%'       <lineannotation>false</lineannotation>
'-abc-' SIMILAR TO '%\mabc\M%'  <lineannotation>true</lineannotation>
'xabcy' SIMILAR TO '%\mabc\M%'  <lineannotation>false</lineannotation>
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    一些例子：
<programlisting>
'abc' SIMILAR TO 'abc'          <lineannotation>true</lineannotation>
'abc' SIMILAR TO 'a'            <lineannotation>false</lineannotation>
'abc' SIMILAR TO '%(b|d)%'      <lineannotation>true</lineannotation>
'abc' SIMILAR TO '(b|c)%'       <lineannotation>false</lineannotation>
'-abc-' SIMILAR TO '%\mabc\M%'  <lineannotation>true</lineannotation>
'xabcy' SIMILAR TO '%\mabc\M%'  <lineannotation>false</lineannotation>
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    The <function>substring</function> function with three parameters
    provides extraction of a substring that matches an SQL
    regular expression pattern.  The function can be written according
    to SQL99 syntax:
<synopsis>
substring(<replaceable>string</replaceable> from <replaceable>pattern</replaceable> for <replaceable>escape-character</replaceable>)
</synopsis>
    or as a plain three-argument function:
<synopsis>
substring(<replaceable>string</replaceable>, <replaceable>pattern</replaceable>, <replaceable>escape-character</replaceable>)
</synopsis>
    As with <literal>SIMILAR TO</literal>, the
    specified pattern must match the entire data string, or else the
    function fails and returns null.  To indicate the part of the
    pattern for which the matching data sub-string is of interest,
    the pattern should contain
    two occurrences of the escape character followed by a double quote
    (<literal>"</literal>). <!-&minus; " font-lock sanity -&minus;>
    The text matching the portion of the pattern
    between these separators is returned when the match is successful.
   </para>
____________________________________________________________________________-->
   <para>
    带有三个参数的<function>substring</function>函数可以提取匹配SQL正则表达式模式的子字符串。 该函数可以按照SQL99语法编写。
<synopsis>
substring(<replaceable>string</replaceable> from <replaceable>pattern</replaceable> for <replaceable>escape-character</replaceable>)
</synopsis>
    或作为一个普通的三参数函数:
<synopsis>
substring(<replaceable>string</replaceable>, <replaceable>pattern</replaceable>, <replaceable>escape-character</replaceable>)
</synopsis>
    与<literal>SIMILAR TO</literal>一样，指定的模式必须与整个数据字符串匹配，否则函数失败并返回空值。 为了表示匹配的数据子字符串的模式中，模式中应该包含两个转义字符的出现，并在后面加上一个双引号(<literal>"</literal>)。<!-- " font-lock sanity --> 匹配成功后，将返回与这些分隔符之间的模式部分匹配的文本。
   </para>

<!--==========================orignal english content==========================
   <para>
    The escape-double-quote separators actually
    divide <function>substring</function>'s pattern into three independent
    regular expressions; for example, a vertical bar (<literal>|</literal>)
    in any of the three sections affects only that section.  Also, the first
    and third of these regular expressions are defined to match the smallest
    possible amount of text, not the largest, when there is any ambiguity
    about how much of the data string matches which pattern.  (In POSIX
    parlance, the first and third regular expressions are forced to be
    non-greedy.)
   </para>
____________________________________________________________________________-->
   <para>
    转义-双引号分隔符实际上是  将<function>子字符串</function>的模式分成三个独立的 正则表达式；例如，竖条(<literal>|</literal>)  三节中的任何一节只影响到该节。 此外，第一节和第三种正则表达式的定义是为了匹配最小的  尽可能多的文字，而不是最大的文字，当有歧义的时候，就不应该是最大的文字。关于有多少数据字符串符合哪种模式。 (在POSIX术语中，第一和第三种正则表达式被强行规定为非贪婪)。
   </para>

<!--==========================orignal english content==========================
   <para>
    As an extension to the SQL standard, <productname>PostgreSQL</productname>
    allows there to be just one escape-double-quote separator, in which case
    the third regular expression is taken as empty; or no separators, in which
    case the first and third regular expressions are taken as empty.
   </para>
____________________________________________________________________________-->
   <para>
    作为对SQL标准的扩展，<productname>PostgreSQL</productname>只允许有一个转义双引号分隔符，在这种情况下，第三个正则表达式被视为空；或者没有分隔符，在这种情况下，第一个和第三个正则表达式被视为空。
   </para>

<!--==========================orignal english content==========================
   <para>
    Some examples, with <literal>#&quot;</literal> delimiting the return string:
<programlisting>
substring('foobar' from '%#"o_b#"%' for '#')   <lineannotation>oob</lineannotation>
substring('foobar' from '#"o_b#"%' for '#')    <lineannotation>NULL</lineannotation>
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    一些例子，使用<literal>#&quot;</literal>定界返回串：
<programlisting>
substring('foobar' from '%#"o_b#"%' for '#')   <lineannotation>oob</lineannotation>
substring('foobar' from '#"o_b#"%' for '#')    <lineannotation>NULL</lineannotation>
</programlisting>
   </para>
  </sect2>

  <sect2 id="functions-posix-regexp">
<!--==========================orignal english content==========================
   <title><acronym>POSIX</acronym> Regular Expressions</title>
____________________________________________________________________________-->
   <title><acronym>POSIX</acronym>正则表达式</title>

<!--==========================orignal english content==========================
   <indexterm zone="functions-posix-regexp">
    <primary>regular expression</primary>
    <seealso>pattern matching</seealso>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="functions-posix-regexp">
    <primary>regular expression</primary>
    <seealso>pattern matching</seealso>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>substring</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>substring</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>regexp_replace</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>regexp_replace</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>regexp_match</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>regexp_match</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>regexp_matches</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>regexp_matches</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>regexp_split_to_table</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>regexp_split_to_table</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>regexp_split_to_array</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>regexp_split_to_array</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    <xref linkend="functions-posix-table"/> lists the available
    operators for pattern matching using POSIX regular expressions.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-posix-table"/>列出了所有可用于 POSIX 正则表达式模式匹配的操作符。
   </para>

   <table id="functions-posix-table">
<!--==========================orignal english content==========================
    <title>Regular Expression Match Operators</title>
____________________________________________________________________________-->
    <title>正则表达式匹配操作符</title>

    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Operator
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        操作符
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

      <tbody>
<!--==========================orignal english content==========================
       <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>~</literal> <type>text</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        String matches regular expression, case sensitively
       </para>
       <para>
        <literal>'thomas' ~ '.*thom.*'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>~</literal> <type>text</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        字符串匹配正则表达式，大小写敏感
       </para>
       <para>
        <literal>'thomas' ~ '.*thom.*'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>~*</literal> <type>text</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        String matches regular expression, case insensitively
       </para>
       <para>
        <literal>'thomas' ~* '.*Thom.*'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>~*</literal> <type>text</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        字符串匹配正则表达式，大小写不敏感
       </para>
       <para>
        <literal>'thomas' ~* '.*Thom.*'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>!~</literal> <type>text</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        String does not match regular expression, case sensitively
       </para>
       <para>
        <literal>'thomas' !~ '.*thomas.*'</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>!~</literal> <type>text</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        字符串不匹配正则表达式，大小写敏感
       </para>
       <para>
        <literal>'thomas' !~ '.*thomas.*'</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>!~*</literal> <type>text</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        String does not match regular expression, case insensitively
       </para>
       <para>
        <literal>'thomas' !~* '.*vadim.*'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>!~*</literal> <type>text</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        字符串不匹配正则表达式，大小写不敏感
       </para>
       <para>
        <literal>'thomas' !~* '.*vadim.*'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

<!--==========================orignal english content==========================
    <para>
     <acronym>POSIX</acronym> regular expressions provide a more
     powerful means for pattern matching than the <function>LIKE</function> and
     <function>SIMILAR TO</function> operators.
     Many Unix tools such as <command>egrep</command>,
     <command>sed</command>, or <command>awk</command> use a pattern
     matching language that is similar to the one described here.
    </para>
____________________________________________________________________________-->
    <para>
     <acronym>POSIX</acronym>正则表达式提供了比<function>LIKE</function>和<function>SIMILAR TO</function>操作符更强大的含义。许多 Unix 工具，例如<command>egrep</command>、<command>sed</command>或<command>awk</command>使用一种与我们这里描述的类似的模式匹配语言。
    </para>

<!--==========================orignal english content==========================
    <para>
     A regular expression is a character sequence that is an
     abbreviated definition of a set of strings (a <firstterm>regular
     set</firstterm>).  A string is said to match a regular expression
     if it is a member of the regular set described by the regular
     expression.  As with <function>LIKE</function>, pattern characters
     match string characters exactly unless they are special characters
     in the regular expression language &mdash; but regular expressions use
     different special characters than <function>LIKE</function> does.
     Unlike <function>LIKE</function> patterns, a
     regular expression is allowed to match anywhere within a string, unless
     the regular expression is explicitly anchored to the beginning or
     end of the string.
    </para>
____________________________________________________________________________-->
    <para>
     正则表达式是一个字符序列，它是定义一个串集合 （一个<firstterm>正则集</firstterm>）的缩写。 如果一个串是正则表达式描述的正则集中的一员时， 我们就说这个串匹配该正则表达式。 和<function>LIKE</function>一样，模式字符准确地匹配串字符， 除非在正则表达式语言里有特殊字符 &mdash; 不过正则表达式用的 特殊字符和<function>LIKE</function>用的不同。 和<function>LIKE</function>模式不一样的是，正则表达式允许匹配串里的任何位置，除非该正则表达式显式地挂接在串的开头或者结尾。
    </para>

<!--==========================orignal english content==========================
    <para>
     Some examples:
<programlisting>
'abc' ~ 'abc'    <lineannotation>true</lineannotation>
'abc' ~ '^a'     <lineannotation>true</lineannotation>
'abc' ~ '(b|d)'  <lineannotation>true</lineannotation>
'abc' ~ '^(b|c)' <lineannotation>false</lineannotation>
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     一些例子：
<programlisting>
'abc' ~ 'abc'    <lineannotation>true</lineannotation>
'abc' ~ '^a'     <lineannotation>true</lineannotation>
'abc' ~ '(b|d)'  <lineannotation>true</lineannotation>
'abc' ~ '^(b|c)' <lineannotation>false</lineannotation>
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     The <acronym>POSIX</acronym> pattern language is described in much
     greater detail below.
    </para>
____________________________________________________________________________-->
    <para>
     <acronym>POSIX</acronym>模式语言的详细描述见下文。
    </para>

<!--==========================orignal english content==========================
    <para>
     The <function>substring</function> function with two parameters,
     <function>substring(<replaceable>string</replaceable> from
     <replaceable>pattern</replaceable>)</function>, provides extraction of a
     substring
     that matches a POSIX regular expression pattern.  It returns null if
     there is no match, otherwise the portion of the text that matched the
     pattern.  But if the pattern contains any parentheses, the portion
     of the text that matched the first parenthesized subexpression (the
     one whose left parenthesis comes first) is
     returned.  You can put parentheses around the whole expression
     if you want to use parentheses within it without triggering this
     exception.  If you need parentheses in the pattern before the
     subexpression you want to extract, see the non-capturing parentheses
     described below.
    </para>
____________________________________________________________________________-->
    <para>
     带两个参数的<function>substring</function>函数，即<function>substring(<replaceable>string</replaceable> from <replaceable>pattern</replaceable>)</function>，提供了抽取一个匹配 POSIX 正则表达式模式的子串的方法。如果没有匹配它返回空值，否则就是文本中匹配模式的那部分。 但是如果该模式包含任何圆括号，那么将返回匹配第一对子表达式（对应第一个左圆括号的） 的文本。如果你想在表达式里使用圆括号而又不想导致这个例外，那么你可以在整个表达式外边放上一对圆括号。 如果你需要在想抽取的子表达式前有圆括号，参阅后文描述的非捕获性圆括号。
    </para>

<!--==========================orignal english content==========================
   <para>
    Some examples:
<programlisting>
substring('foobar' from 'o.b')     <lineannotation>oob</lineannotation>
substring('foobar' from 'o(.)b')   <lineannotation>o</lineannotation>
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    一些例子：
<programlisting>
substring('foobar' from 'o.b')     <lineannotation>oob</lineannotation>
substring('foobar' from 'o(.)b')   <lineannotation>o</lineannotation>
</programlisting>
   </para>

<!--==========================orignal english content==========================
    <para>
     The <function>regexp_replace</function> function provides substitution of
     new text for substrings that match POSIX regular expression patterns.
     It has the syntax
     <function>regexp_replace</function>(<replaceable>source</replaceable>,
     <replaceable>pattern</replaceable>, <replaceable>replacement</replaceable>
     <optional>, <replaceable>flags</replaceable> </optional>).
     The <replaceable>source</replaceable> string is returned unchanged if
     there is no match to the <replaceable>pattern</replaceable>.  If there is a
     match, the <replaceable>source</replaceable> string is returned with the
     <replaceable>replacement</replaceable> string substituted for the matching
     substring.  The <replaceable>replacement</replaceable> string can contain
     <literal>\</literal><replaceable>n</replaceable>, where <replaceable>n</replaceable> is 1
     through 9, to indicate that the source substring matching the
     <replaceable>n</replaceable>'th parenthesized subexpression of the pattern should be
     inserted, and it can contain <literal>\&amp;</literal> to indicate that the
     substring matching the entire pattern should be inserted.  Write
     <literal>\\</literal> if you need to put a literal backslash in the replacement
     text.
     The <replaceable>flags</replaceable> parameter is an optional text
     string containing zero or more single-letter flags that change the
     function's behavior.  Flag <literal>i</literal> specifies case-insensitive
     matching, while flag <literal>g</literal> specifies replacement of each matching
     substring rather than only the first one.  Supported flags (though
     not <literal>g</literal>) are
     described in <xref linkend="posix-embedded-options-table"/>.
    </para>
____________________________________________________________________________-->
    <para>
     <function>regexp_replace</function>函数提供了将匹配 POSIX 正则表达式模式的子串替换为新文本的功能。 它的语法是 <function>regexp_replace</function>(<replaceable>source</replaceable>, <replaceable>pattern</replaceable>, <replaceable>replacement</replaceable> <optional>, <replaceable>flags</replaceable> </optional>)。 如果没有匹配<replaceable>pattern</replaceable>，那么返回不加修改的<replaceable>source</replaceable>串。 如果有匹配，则返回的<replaceable>source</replaceable>串里面的匹配子串将被<replaceable>replacement</replaceable>串替换掉。<replaceable>replacement</replaceable>串可以包含<literal>\</literal><replaceable>n</replaceable>， 其中<literal>\</literal><replaceable>n</replaceable>是 1 到 9， 表明源串里匹配模式里第<replaceable>n</replaceable>个圆括号子表达式的子串应该被插入， 并且它可以包含<literal>\&amp;</literal>表示应该插入匹配整个模式的子串。如果你需要放一个文字形式的反斜线在替换文本里，那么写<literal>\\</literal>。<replaceable>flags</replaceable>参数是一个可选的文本串，它包含另个或更多单字母标志，这些标志可以改变函数的行为。标志<literal>i</literal>指定大小写无关的匹配，而标志<literal>g</literal>指定替换每一个匹配的子串而不仅仅是第一个。支持的标志（但不是<literal>g</literal>）在<xref linkend="posix-embedded-options-table"/>中描述。
    </para>

<!--==========================orignal english content==========================
   <para>
    Some examples:
<programlisting>
regexp_replace('foobarbaz', 'b..', 'X')
                                   <lineannotation>fooXbaz</lineannotation>
regexp_replace('foobarbaz', 'b..', 'X', 'g')
                                   <lineannotation>fooXX</lineannotation>
regexp_replace('foobarbaz', 'b(..)', 'X\1Y', 'g')
                                   <lineannotation>fooXarYXazY</lineannotation>
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    一些例子：
<programlisting>
regexp_replace('foobarbaz', 'b..', 'X')
                                   <lineannotation>fooXbaz</lineannotation>
regexp_replace('foobarbaz', 'b..', 'X', 'g')
                                   <lineannotation>fooXX</lineannotation>
regexp_replace('foobarbaz', 'b(..)', 'X\1Y', 'g')
                                   <lineannotation>fooXarYXazY</lineannotation>
</programlisting>
   </para>

<!--==========================orignal english content==========================
    <para>
     The <function>regexp_match</function> function returns a text array of
     captured substring(s) resulting from the first match of a POSIX
     regular expression pattern to a string.  It has the syntax
     <function>regexp_match</function>(<replaceable>string</replaceable>,
     <replaceable>pattern</replaceable> <optional>, <replaceable>flags</replaceable> </optional>).
     If there is no match, the result is <literal>NULL</literal>.
     If a match is found, and the <replaceable>pattern</replaceable> contains no
     parenthesized subexpressions, then the result is a single-element text
     array containing the substring matching the whole pattern.
     If a match is found, and the <replaceable>pattern</replaceable> contains
     parenthesized subexpressions, then the result is a text array
     whose <replaceable>n</replaceable>'th element is the substring matching
     the <replaceable>n</replaceable>'th parenthesized subexpression of
     the <replaceable>pattern</replaceable> (not counting <quote>non-capturing</quote>
     parentheses; see below for details).
     The <replaceable>flags</replaceable> parameter is an optional text string
     containing zero or more single-letter flags that change the function's
     behavior.  Supported flags are described
     in <xref linkend="posix-embedded-options-table"/>.
    </para>
____________________________________________________________________________-->
    <para>
     <function>regexp_match</function>返回一个文本数组，它包含一个POSIX正则表达式模式与一个字符串第一个匹配所得到的子串。其语法是<function>regexp_match</function>(<replaceable>string</replaceable>, <replaceable>pattern</replaceable> <optional>, <replaceable>flags</replaceable> </optional>)。如果没有匹配，则结果为<literal>NULL</literal>。如果找到一个匹配并且<replaceable>pattern</replaceable>不包含带括号的子表达式，那么结果是一个单一元素的文本数组，其中包含匹配整个模式的子串。如果找到一个匹配并且<replaceable>pattern</replaceable>含有带括号的子表达式，那么结果是一个文本数组，其中第<replaceable>n</replaceable>个元素是与<replaceable>pattern</replaceable>的第<replaceable>n</replaceable>个圆括号子表达式匹配的子串（<quote>非捕获</quote>圆括号不计入在内，详见下文）。<replaceable>flags</replaceable>参数是一个可选的文本字符串，它包含零个或者更多个可以改变该函数行为的单字母标志。所支持的标志在<xref linkend="posix-embedded-options-table"/>中介绍。
    </para>

<!--==========================orignal english content==========================
   <para>
    Some examples:
<programlisting>
SELECT regexp_match('foobarbequebaz', 'bar.*que');
 regexp_match
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 {barbeque}
(1 row)

SELECT regexp_match('foobarbequebaz', '(bar)(beque)');
 regexp_match
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 {bar,beque}
(1 row)
</programlisting>
    In the common case where you just want the whole matching substring
    or <literal>NULL</literal> for no match, write something like
<programlisting>
SELECT (regexp_match('foobarbequebaz', 'bar.*que'))[1];
 regexp_match
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 barbeque
(1 row)
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    一些例子：
<programlisting>
SELECT regexp_match('foobarbequebaz', 'bar.*que');
 regexp_match
--------------
 {barbeque}
(1 row)

SELECT regexp_match('foobarbequebaz', '(bar)(beque)');
 regexp_match
--------------
 {bar,beque}
(1 row)
</programlisting>
    在通常情况下，人们只是想要的大整个匹配的子串或者<literal>NULL</literal>（没有匹配），可以写成这样
<programlisting>
SELECT (regexp_match('foobarbequebaz', 'bar.*que'))[1];
 regexp_match
--------------
 barbeque
(1 row)
</programlisting>
   </para>

<!--==========================orignal english content==========================
    <para>
     The <function>regexp_matches</function> function returns a set of text arrays
     of captured substring(s) resulting from matching a POSIX regular
     expression pattern to a string.  It has the same syntax as
     <function>regexp_match</function>.
     This function returns no rows if there is no match, one row if there is
     a match and the <literal>g</literal> flag is not given, or <replaceable>N</replaceable>
     rows if there are <replaceable>N</replaceable> matches and the <literal>g</literal> flag
     is given.  Each returned row is a text array containing the whole
     matched substring or the substrings matching parenthesized
     subexpressions of the <replaceable>pattern</replaceable>, just as described above
     for <function>regexp_match</function>.
     <function>regexp_matches</function> accepts all the flags shown
     in <xref linkend="posix-embedded-options-table"/>, plus
     the <literal>g</literal> flag which commands it to return all matches, not
     just the first one.
    </para>
____________________________________________________________________________-->
    <para>
     <function>regexp_matches</function>函数返回一个文本数组的集合，其中包含着一个POSIX正则表达式模式与一个字符串匹配得到的子串。它和<function>regexp_match</function>具有相同的语法。如果没有匹配，这个函数不会返回行。如果有一个匹配并且给定了<literal>g</literal>标志，则返回一行。如果有<replaceable>N</replaceable>个匹配并且给定了<literal>g</literal>标志，则返回<replaceable>N</replaceable>行。每一个返回的行都是一个文本数组，其中含有整个匹配的子串或者匹配<replaceable>pattern</replaceable>的圆括号子表达式的子串，这和上面对<function>regexp_match</function>的介绍一样。<function>regexp_matches</function>接受<xref linkend="posix-embedded-options-table"/>中展示的所有标志，外加令它返回所有匹配而不仅仅是第一个匹配的<literal>g</literal>标志。
    </para>

<!--==========================orignal english content==========================
   <para>
    Some examples:
<programlisting>
SELECT regexp_matches('foo', 'not there');
 regexp_matches
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
(0 rows)

SELECT regexp_matches('foobarbequebazilbarfbonk', '(b[^b]+)(b[^b]+)', 'g');
 regexp_matches
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 {bar,beque}
 {bazil,barf}
(2 rows)
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    一些例子：
<programlisting>
SELECT regexp_matches('foo', 'not there');
 regexp_matches
----------------
(0 rows)

SELECT regexp_matches('foobarbequebazilbarfbonk', '(b[^b]+)(b[^b]+)', 'g');
 regexp_matches
----------------
 {bar,beque}
 {bazil,barf}
(2 rows)
</programlisting>
   </para>

   <tip>
<!--==========================orignal english content==========================
    <para>
     In most cases <function>regexp_matches()</function> should be used with
     the <literal>g</literal> flag, since if you only want the first match, it's
     easier and more efficient to use <function>regexp_match()</function>.
     However, <function>regexp_match()</function> only exists
     in <productname>PostgreSQL</productname> version 10 and up.  When working in older
     versions, a common trick is to place a <function>regexp_matches()</function>
     call in a sub-select, for example:
<programlisting>
SELECT col1, (SELECT regexp_matches(col2, '(bar)(beque)')) FROM tab;
</programlisting>
     This produces a text array if there's a match, or <literal>NULL</literal> if
     not, the same as <function>regexp_match()</function> would do.  Without the
     sub-select, this query would produce no output at all for table rows
     without a match, which is typically not the desired behavior.
    </para>
____________________________________________________________________________-->
    <para>
     在大部分情况下，<function>regexp_matches()</function>应该与<literal>g</literal>标志一起使用，因为如果只是想要第一个匹配，使用<function>regexp_match()</function>会更加简单高效。不过，<function>regexp_match()</function>仅存在于<productname>PostgreSQL</productname>版本10以及更高的版本中。当在较老的版本中使用时，一种常用的技巧是把<function>regexp_matches()</function>调用放在子选择中，例如：
<programlisting>
SELECT col1, (SELECT regexp_matches(col2, '(bar)(beque)')) FROM tab;
</programlisting>
     如果有一个匹配，则这个语句会产生一个文本数组，否则返回<literal>NULL</literal>，这和<function>regexp_match()</function>的做法一样。如果没有子选择，这个查询对于没有匹配的表行根本不会产生输出，显然那不是想要的行为。
    </para>
   </tip>

<!--==========================orignal english content==========================
    <para>
     The <function>regexp_split_to_table</function> function splits a string using a POSIX
     regular expression pattern as a delimiter.  It has the syntax
     <function>regexp_split_to_table</function>(<replaceable>string</replaceable>, <replaceable>pattern</replaceable>
     <optional>, <replaceable>flags</replaceable> </optional>).
     If there is no match to the <replaceable>pattern</replaceable>, the function returns the
     <replaceable>string</replaceable>.  If there is at least one match, for each match it returns
     the text from the end of the last match (or the beginning of the string)
     to the beginning of the match.  When there are no more matches, it
     returns the text from the end of the last match to the end of the string.
     The <replaceable>flags</replaceable> parameter is an optional text string containing
     zero or more single-letter flags that change the function's behavior.
     <function>regexp_split_to_table</function> supports the flags described in
     <xref linkend="posix-embedded-options-table"/>.
    </para>
____________________________________________________________________________-->
    <para>
     <function>regexp_split_to_table</function>把一个 POSIX 正则表达式模式当作一个定界符来分离一个串。它的语法形式是<function>regexp_split_to_table</function>(<replaceable>string</replaceable>, <replaceable>pattern</replaceable> <optional>, <replaceable>flags</replaceable> </optional>)。如果没有与<replaceable>pattern</replaceable>的匹配，该函数返回<replaceable>string</replaceable>。如果有至少有一个匹配，对每一个匹配它都返回从上一个匹配的末尾（或者串的开头）到这次匹配开头之间的文本。当没有更多匹配时，它返回从上一次匹配的末尾到串末尾之间的文本。<replaceable>flags</replaceable>参数是一个可选的文本串，它包含零个或更多单字母标志，这些标识可以改变该函数的行为。<function>regexp_split_to_table</function>能支持的标志在<xref linkend="posix-embedded-options-table"/>中描述。
    </para>

<!--==========================orignal english content==========================
    <para>
     The <function>regexp_split_to_array</function> function behaves the same as
     <function>regexp_split_to_table</function>, except that <function>regexp_split_to_array</function>
     returns its result as an array of <type>text</type>.  It has the syntax
     <function>regexp_split_to_array</function>(<replaceable>string</replaceable>, <replaceable>pattern</replaceable>
     <optional>, <replaceable>flags</replaceable> </optional>).
     The parameters are the same as for <function>regexp_split_to_table</function>.
    </para>
____________________________________________________________________________-->
    <para>
     <function>regexp_split_to_array</function>函数的行为和<function>regexp_split_to_table</function>相同，不过<function>regexp_split_to_array</function>会把它的结果以一个<type>text</type>数组的形式返回。它的语法是<function>regexp_split_to_array</function>(<replaceable>string</replaceable>, <replaceable>pattern</replaceable> <optional>, <replaceable>flags</replaceable> </optional>)。这些参数和<function>regexp_split_to_table</function>的相同。
    </para>

<!--==========================orignal english content==========================
   <para>
    Some examples:
<programlisting>

SELECT foo FROM regexp_split_to_table('the quick brown fox jumps over the lazy dog', '\s+') AS foo;
  foo   
-&minus;-&minus;-&minus;-
 the    
 quick  
 brown  
 fox    
 jumps 
 over   
 the    
 lazy   
 dog    
(9 rows)

SELECT regexp_split_to_array('the quick brown fox jumps over the lazy dog', '\s+');
              regexp_split_to_array             
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 {the,quick,brown,fox,jumps,over,the,lazy,dog}
(1 row)

SELECT foo FROM regexp_split_to_table('the quick brown fox', '\s*') AS foo;
 foo 
-&minus;-&minus;-
 t         
 h         
 e         
 q         
 u         
 i         
 c         
 k         
 b         
 r         
 o         
 w         
 n         
 f         
 o         
 x         
(16 rows)
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    一些例子：
<programlisting>

SELECT foo FROM regexp_split_to_table('the quick brown fox jumps over the lazy dog', '\s+') AS foo;
  foo   
-------
 the    
 quick  
 brown  
 fox    
 jumps 
 over   
 the    
 lazy   
 dog    
(9 rows)

SELECT regexp_split_to_array('the quick brown fox jumps over the lazy dog', '\s+');
              regexp_split_to_array             
-----------------------------------------------
 {the,quick,brown,fox,jumps,over,the,lazy,dog}
(1 row)

SELECT foo FROM regexp_split_to_table('the quick brown fox', '\s*') AS foo;
 foo 
-----
 t         
 h         
 e         
 q         
 u         
 i         
 c         
 k         
 b         
 r         
 o         
 w         
 n         
 f         
 o         
 x         
(16 rows)
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    As the last example demonstrates, the regexp split functions ignore
    zero-length matches that occur at the start or end of the string
    or immediately after a previous match.  This is contrary to the strict
    definition of regexp matching that is implemented by
    <function>regexp_match</function> and
    <function>regexp_matches</function>, but is usually the most convenient behavior
    in practice.  Other software systems such as Perl use similar definitions.
   </para>
____________________________________________________________________________-->
   <para>
    正如上一个例子所示，正则表达式分离函数会忽略零长度的匹配，这种匹配发生在串的开头或结尾或者正好发生在前一个匹配之后。这和正则表达式匹配的严格定义是相悖的，后者由<function>regexp_match</function>和<function>regexp_matches</function>实现，但是通常前者是实际中最常用的行为。其他软件系统如Perl也使用相似的定义。
   </para>

<!-- derived from the re_syntax.n man page -->

   <sect3 id="posix-syntax-details">
<!--==========================orignal english content==========================
    <title>Regular Expression Details</title>
____________________________________________________________________________-->
    <title>正则表达式细节</title>

<!--==========================orignal english content==========================
   <para>
    <productname>PostgreSQL</productname>'s regular expressions are implemented
    using a software package written by Henry Spencer.  Much of
    the description of regular expressions below is copied verbatim from his
    manual.
   </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>的正则表达式是使用 Henry Spencer 写的一个包来实现的。下面的正则表达式的大部分描述都是从他的手册页中逐字拷贝过来的。
   </para>

<!--==========================orignal english content==========================
   <para>
    Regular expressions (<acronym>RE</acronym>s), as defined in
    <acronym>POSIX</acronym> 1003.2, come in two forms:
    <firstterm>extended</firstterm> <acronym>RE</acronym>s or <acronym>ERE</acronym>s
    (roughly those of <command>egrep</command>), and
    <firstterm>basic</firstterm> <acronym>RE</acronym>s or <acronym>BRE</acronym>s
    (roughly those of <command>ed</command>).
    <productname>PostgreSQL</productname> supports both forms, and
    also implements some extensions
    that are not in the POSIX standard, but have become widely used
    due to their availability in programming languages such as Perl and Tcl.
    <acronym>RE</acronym>s using these non-POSIX extensions are called
    <firstterm>advanced</firstterm> <acronym>RE</acronym>s or <acronym>ARE</acronym>s
    in this documentation.  AREs are almost an exact superset of EREs,
    but BREs have several notational incompatibilities (as well as being
    much more limited).
    We first describe the ARE and ERE forms, noting features that apply
    only to AREs, and then describe how BREs differ.
   </para>
____________________________________________________________________________-->
   <para>
    正则表达式（<acronym>RE</acronym>），在<acronym>POSIX</acronym> 1003.2 中定义， 它有两种形式：<firstterm>扩展</firstterm>的<acronym>RE</acronym>或者是<acronym>ERE</acronym>（大概地说就是那些在<command>egrep</command>里的）， <firstterm>基本</firstterm>的<acronym>RE</acronym>或者是<acronym>BRE</acronym>（大概地说就是那些在<command>ed</command>里的）。<productname>PostgreSQL</productname>支持两种形式，并且还实现了一些POSIX标准中没有但是在类似 Perl 或者 Tcl 这样的语言中得到广泛应用的一些扩展。使用了那些非POSIX扩展的<acronym>RE</acronym>叫<firstterm>高级</firstterm><acronym>RE</acronym>， 或者本文档里说的<acronym>ARE</acronym>。ARE 几乎完全是 ERE 的超集，但是 BRE 有几个符号上的不兼容（以及更多的限制）。我们首先描述 ARE 和 ERE 形式， 描述那些只适用于 ARE 的特性，然后描述 BRE 的区别是什么。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     <productname>PostgreSQL</productname> always initially presumes that a regular
     expression follows the ARE rules.  However, the more limited ERE or
     BRE rules can be chosen by prepending an <firstterm>embedded option</firstterm>
     to the RE pattern, as described in <xref linkend="posix-metasyntax"/>.
     This can be useful for compatibility with applications that expect
     exactly the <acronym>POSIX</acronym> 1003.2 rules.
    </para>
____________________________________________________________________________-->
    <para>
     <productname>PostgreSQL</productname>初始时总是推测一个正则表达式遵循 ARE 规则。但是，可以通过为 RE 模式预置一个<firstterm>embedded option</firstterm>来选择限制更多的 ERE 或 BRE 规则，如<xref linkend="posix-metasyntax"/>中所述。这对为期望准确的<acronym>POSIX</acronym> 1003.2 规则的应用提供兼容性很有用。
    </para>
   </note>

<!--==========================orignal english content==========================
   <para>
    A regular expression is defined as one or more
    <firstterm>branches</firstterm>, separated by
    <literal>|</literal>.  It matches anything that matches one of the
    branches.
   </para>
____________________________________________________________________________-->
   <para>
    一个正则表达式被定义为一个或更多<firstterm>分支</firstterm>，它们之间被<literal>|</literal>分隔。只要能匹配其中一个分支的东西都能匹配正则表达式。
   </para>

<!--==========================orignal english content==========================
   <para>
    A branch is zero or more <firstterm>quantified atoms</firstterm> or
    <firstterm>constraints</firstterm>, concatenated.
    It matches a match for the first, followed by a match for the second, etc;
    an empty branch matches the empty string.
   </para>
____________________________________________________________________________-->
   <para>
    一个分支是一个或多个<firstterm>量化原子</firstterm>或者<firstterm>约束</firstterm>连接而成。一个原子匹配第一个，然后后面的原子匹配第二个， 以此类推；一个空分支匹配空串。
   </para>

<!--==========================orignal english content==========================
   <para>
    A quantified atom is an <firstterm>atom</firstterm> possibly followed
    by a single <firstterm>quantifier</firstterm>.
    Without a quantifier, it matches a match for the atom.
    With a quantifier, it can match some number of matches of the atom.
    An <firstterm>atom</firstterm> can be any of the possibilities
    shown in <xref linkend="posix-atoms-table"/>.
    The possible quantifiers and their meanings are shown in
    <xref linkend="posix-quantifiers-table"/>.
   </para>
____________________________________________________________________________-->
   <para>
    一个量化原子是一个<firstterm>原子</firstterm>， 后面可能跟着一个<firstterm>量词</firstterm>。没有量词的时候，它匹配一个原子， 有量词的时候，它可以匹配若干个原子。一个<firstterm>原子</firstterm>可以是在<xref linkend="posix-atoms-table"/>里面显示的任何可能。 可能的量词和它们的含义在<xref linkend="posix-quantifiers-table"/>里显示。
   </para>

<!--==========================orignal english content==========================
   <para>
    A <firstterm>constraint</firstterm> matches an empty string, but matches only when
    specific conditions are met.  A constraint can be used where an atom
    could be used, except it cannot be followed by a quantifier.
    The simple constraints are shown in
    <xref linkend="posix-constraints-table"/>;
    some more constraints are described later.
   </para>
____________________________________________________________________________-->
   <para>
    一个<firstterm>约束</firstterm>匹配一个空串，但只是在满足特定条件下才匹配。 约束可以在能够使用原子的地方使用，只是它不能跟着量词。简单的约束在<xref linkend="posix-constraints-table"/>里显示； 更多的约束稍后描述。
   </para>


   <table id="posix-atoms-table">
<!--==========================orignal english content==========================
    <title>Regular Expression Atoms</title>
____________________________________________________________________________-->
    <title>正则表达式原子</title>

    <tgroup cols="2">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Atom</entry>
       <entry>Description</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>原子</entry>
       <entry>描述</entry>
      </row>
     </thead>

      <tbody>
<!--==========================orignal english content==========================
       <row>
       <entry> <literal>(</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry> (where <replaceable>re</replaceable> is any regular expression)
       matches a match for
       <replaceable>re</replaceable>, with the match noted for possible reporting </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>(</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry>（其中<replaceable>re</replaceable>是任何正则表达式） 匹配一个对<replaceable>re</replaceable>的匹配，匹配将为可能的报告被记下</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>(?:</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry> as above, but the match is not noted for reporting
       (a <quote>non-capturing</quote> set of parentheses)
       (AREs only) </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>(?:</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry>同上，但是匹配不会为了报告而被记下 （一个<quote>非捕获</quote>圆括号集） （只对 ARE）</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>.</literal> </entry>
       <entry> matches any single character </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>.</literal> </entry>
       <entry>匹配任意单个字符</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>[</literal><replaceable>chars</replaceable><literal>]</literal> </entry>
       <entry> a <firstterm>bracket expression</firstterm>,
       matching any one of the <replaceable>chars</replaceable> (see
       <xref linkend="posix-bracket-expressions"/> for more detail) </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>[</literal><replaceable>chars</replaceable><literal>]</literal> </entry>
       <entry> 一个<firstterm>方括号表达式</firstterm>， 匹配<replaceable>chars</replaceable>中的任意一个（详见<xref linkend="posix-bracket-expressions"/>）</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\</literal><replaceable>k</replaceable> </entry>
       <entry> (where <replaceable>k</replaceable> is a non-alphanumeric character)
       matches that character taken as an ordinary character,
       e.g., <literal>\\</literal> matches a backslash character </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\</literal><replaceable>k</replaceable> </entry>
       <entry>（其中<replaceable>k</replaceable>是一个非字母数字字符） 匹配一个被当作普通字符看待的特定字符， 例如，<literal>\\</literal>匹配一个反斜线字符</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\</literal><replaceable>c</replaceable> </entry>
       <entry> where <replaceable>c</replaceable> is alphanumeric
       (possibly followed by other characters)
       is an <firstterm>escape</firstterm>, see <xref linkend="posix-escape-sequences"/>
       (AREs only; in EREs and BREs, this matches <replaceable>c</replaceable>) </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\</literal><replaceable>c</replaceable> </entry>
       <entry>其中<replaceable>c</replaceable>是一个字母数字 （可能跟着其它字符），它是一个<firstterm>逃逸</firstterm>， 参阅<xref linkend="posix-escape-sequences"/>（仅对 ARE； 在 ERE 和 BRE 中，它匹配<replaceable>c</replaceable>）</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>{</literal> </entry>
       <entry> when followed by a character other than a digit,
       matches the left-brace character <literal>{</literal>;
       when followed by a digit, it is the beginning of a
       <replaceable>bound</replaceable> (see below) </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>{</literal> </entry>
       <entry>如果后面跟着一个字符，而不是数字， 那么就匹配左花括弧<literal>{</literal>；如果跟着一个数字， 那么它是<replaceable>range</replaceable>的开始（见下文）</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <replaceable>x</replaceable> </entry>
       <entry> where <replaceable>x</replaceable> is a single character with no other
       significance, matches that character </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <replaceable>x</replaceable> </entry>
       <entry>其中<replaceable>x</replaceable>是一个没有其它意义的单个字符，则匹配该字符</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

<!--==========================orignal english content==========================
   <para>
    An RE cannot end with a backslash (<literal>\</literal>).
   </para>
____________________________________________________________________________-->
   <para>
    RE 不能以反斜线（<literal>\</literal>）结尾。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     If you have <xref linkend="guc-standard-conforming-strings"/> turned off,
     any backslashes you write in literal string constants will need to be
     doubled.  See <xref linkend="sql-syntax-strings"/> for more information.
    </para>
____________________________________________________________________________-->
    <para>
     如果你关掉了<xref linkend="guc-standard-conforming-strings"/>，任何你写在文字串常量中的反斜线都需要被双写。详见<xref linkend="sql-syntax-strings"/>。
    </para>
   </note>

   <table id="posix-quantifiers-table">
<!--==========================orignal english content==========================
    <title>Regular Expression Quantifiers</title>
____________________________________________________________________________-->
    <title>正则表达式量词</title>

    <tgroup cols="2">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Quantifier</entry>
       <entry>Matches</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>量词</entry>
       <entry>匹配</entry>
      </row>
     </thead>

      <tbody>
<!--==========================orignal english content==========================
       <row>
       <entry> <literal>*</literal> </entry>
       <entry> a sequence of 0 or more matches of the atom </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>*</literal> </entry>
       <entry>一个由原子的 0 次或更多次匹配组成的序列</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>+</literal> </entry>
       <entry> a sequence of 1 or more matches of the atom </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>+</literal> </entry>
       <entry>一个由原子的 1 次或更多次匹配组成的序列</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>?</literal> </entry>
       <entry> a sequence of 0 or 1 matches of the atom </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>?</literal> </entry>
       <entry>一个由原子的 0 次或 1 次匹配组成的序列</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>{</literal><replaceable>m</replaceable><literal>}</literal> </entry>
       <entry> a sequence of exactly <replaceable>m</replaceable> matches of the atom </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>{</literal><replaceable>m</replaceable><literal>}</literal> </entry>
       <entry>一个由原子的正好<replaceable>m</replaceable>次匹配组成的序列</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>{</literal><replaceable>m</replaceable><literal>,}</literal> </entry>
       <entry> a sequence of <replaceable>m</replaceable> or more matches of the atom </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>{</literal><replaceable>m</replaceable><literal>,}</literal> </entry>
       <entry>一个由原子的<replaceable>m</replaceable>次或更多次匹配组成的序列</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry>
       <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal> </entry>
       <entry> a sequence of <replaceable>m</replaceable> through <replaceable>n</replaceable>
       (inclusive) matches of the atom; <replaceable>m</replaceable> cannot exceed
       <replaceable>n</replaceable> </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry>
       <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal> </entry>
       <entry>一个由原子的从<replaceable>m</replaceable>次到<replaceable>n</replaceable>次（包括）匹配组成的序列；<replaceable>m</replaceable>不能超过<replaceable>n</replaceable> </entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>*?</literal> </entry>
       <entry> non-greedy version of <literal>*</literal> </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>*?</literal> </entry>
       <entry><literal>*</literal>的非贪婪版本</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>+?</literal> </entry>
       <entry> non-greedy version of <literal>+</literal> </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>+?</literal> </entry>
       <entry><literal>+</literal>的非贪婪版本</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>??</literal> </entry>
       <entry> non-greedy version of <literal>?</literal> </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>??</literal> </entry>
       <entry><literal>?</literal>的非贪婪版本</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>{</literal><replaceable>m</replaceable><literal>}?</literal> </entry>
       <entry> non-greedy version of <literal>{</literal><replaceable>m</replaceable><literal>}</literal> </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>{</literal><replaceable>m</replaceable><literal>}?</literal> </entry>
       <entry><literal>{</literal><replaceable>m</replaceable><literal>}</literal>的非贪婪版本 </entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>{</literal><replaceable>m</replaceable><literal>,}?</literal> </entry>
       <entry> non-greedy version of <literal>{</literal><replaceable>m</replaceable><literal>,}</literal> </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>{</literal><replaceable>m</replaceable><literal>,}?</literal> </entry>
       <entry><literal>{</literal><replaceable>m</replaceable><literal>,}</literal>的非贪婪版本 </entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry>
       <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}?</literal> </entry>
       <entry> non-greedy version of <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal> </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry>
       <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}?</literal> </entry>
       <entry><literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal>的非贪婪版本 </entry>
       </row>
      </tbody>
     </tgroup>
    </table>

<!--==========================orignal english content==========================
   <para>
    The forms using <literal>{</literal><replaceable>...</replaceable><literal>}</literal>
    are known as <firstterm>bounds</firstterm>.
    The numbers <replaceable>m</replaceable> and <replaceable>n</replaceable> within a bound are
    unsigned decimal integers with permissible values from 0 to 255 inclusive.
   </para>
____________________________________________________________________________-->
   <para>
    使用<literal>{</literal><replaceable>...</replaceable><literal>}</literal>的形式被称作<firstterm>范围</firstterm>。 一个范围内的数字<replaceable>m</replaceable>和<replaceable>n</replaceable>都是无符号十进制整数， 允许的数值从 0 到 255（包含）。
   </para>

<!--==========================orignal english content==========================
    <para>
     <firstterm>Non-greedy</firstterm> quantifiers (available in AREs only) match the
     same possibilities as their corresponding normal (<firstterm>greedy</firstterm>)
     counterparts, but prefer the smallest number rather than the largest
     number of matches.
     See <xref linkend="posix-matching-rules"/> for more detail.
   </para>
____________________________________________________________________________-->
    <para>
     <firstterm>非贪婪</firstterm>的量词（只在 ARE 中可用）匹配对应的正常 （<firstterm>贪婪</firstterm>）模式，区别是它寻找最少的匹配，而不是最多的匹配。详见<xref linkend="posix-matching-rules"/>。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     A quantifier cannot immediately follow another quantifier, e.g.,
     <literal>**</literal> is invalid.
     A quantifier cannot
     begin an expression or subexpression or follow
     <literal>^</literal> or <literal>|</literal>.
    </para>
____________________________________________________________________________-->
    <para>
     一个量词不能紧跟在另外一个量词后面，例如<literal>**</literal>是非法的。量词不能作为表达式或者子表达式的开头，也不能跟在<literal>^</literal>或者<literal>|</literal>后面。
    </para>
   </note>

   <table id="posix-constraints-table">
<!--==========================orignal english content==========================
    <title>Regular Expression Constraints</title>
____________________________________________________________________________-->
    <title>正则表达式约束</title>

    <tgroup cols="2">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Constraint</entry>
       <entry>Description</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>约束</entry>
       <entry>描述</entry>
      </row>
     </thead>

      <tbody>
<!--==========================orignal english content==========================
       <row>
       <entry> <literal>^</literal> </entry>
       <entry> matches at the beginning of the string </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>^</literal> </entry>
       <entry>串开头的匹配</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>$</literal> </entry>
       <entry> matches at the end of the string </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>$</literal> </entry>
       <entry>串末尾的匹配</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>(?=</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry> <firstterm>positive lookahead</firstterm> matches at any point
       where a substring matching <replaceable>re</replaceable> begins
       (AREs only) </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>(?=</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry>在匹配<replaceable>re</replaceable>的子串开始的任何点的<firstterm>positive lookahead</firstterm>匹配（只对 ARE）</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>(?!</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry> <firstterm>negative lookahead</firstterm> matches at any point
       where no substring matching <replaceable>re</replaceable> begins
       (AREs only) </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>(?!</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry>在匹配<replaceable>re</replaceable>的子串开始的任何点的<firstterm>negative lookahead</firstterm>匹配（只对 ARE）</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>(?&lt;=</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry> <firstterm>positive lookbehind</firstterm> matches at any point
       where a substring matching <replaceable>re</replaceable> ends
       (AREs only) </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>(?&lt;=</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry>只要有一个点上有一个子串匹配<replaceable>re</replaceable>端， <firstterm>positive lookbehind</firstterm>就在这个点上匹配（只对 ARE）</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>(?&lt;!</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry> <firstterm>negative lookbehind</firstterm> matches at any point
       where no substring matching <replaceable>re</replaceable> ends
       (AREs only) </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>(?&lt;!</literal><replaceable>re</replaceable><literal>)</literal> </entry>
       <entry>只要有一个点上没有子串匹配<replaceable>re</replaceable>端， <firstterm>negative lookbehind</firstterm>就在这个点上匹配（只对 ARE）</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

<!--==========================orignal english content==========================
   <para>
    Lookahead and lookbehind constraints cannot contain <firstterm>back
    references</firstterm> (see <xref linkend="posix-escape-sequences"/>),
    and all parentheses within them are considered non-capturing.
   </para>
____________________________________________________________________________-->
   <para>
    Lookahead 和 lookbehind 约束不能包含<firstterm>后引用</firstterm> （参阅<xref linkend="posix-escape-sequences"/>），并且其中的所有圆括号 都被认为是非捕获的。
   </para>
   </sect3>

   <sect3 id="posix-bracket-expressions">
<!--==========================orignal english content==========================
    <title>Bracket Expressions</title>
____________________________________________________________________________-->
    <title>方括号表达式</title>

<!--==========================orignal english content==========================
   <para>
    A <firstterm>bracket expression</firstterm> is a list of
    characters enclosed in <literal>[]</literal>.  It normally matches
    any single character from the list (but see below).  If the list
    begins with <literal>^</literal>, it matches any single character
    <emphasis>not</emphasis> from the rest of the list.
    If two characters
    in the list are separated by <literal>-</literal>, this is
    shorthand for the full range of characters between those two
    (inclusive) in the collating sequence,
    e.g., <literal>[0-9]</literal> in <acronym>ASCII</acronym> matches
    any decimal digit.  It is illegal for two ranges to share an
    endpoint, e.g.,  <literal>a-c-e</literal>.  Ranges are very
    collating-sequence-dependent, so portable programs should avoid
    relying on them.
   </para>
____________________________________________________________________________-->
   <para>
    <firstterm>方括号表达式</firstterm>是一个包围在<literal>[]</literal>中的字符列表。它通常匹配列表中的任意单个字符（但见下文）。 如果列表以<literal>^</literal>开头，它匹配任意单个<emphasis>不</emphasis>在该列表参与部分中的字符。如果该列表中两个字符用<literal>-</literal>隔开， 那它就是那两个字符（包括在内）之间的所有字符范围的缩写，例如，在<acronym>ASCII</acronym>中<literal>[0-9]</literal>匹配任何十进制数字。两个范围共享一个端点是非法的，例如，<literal>a-c-e</literal>。范围与字符集关系密切， 可移植的程序应该避免依靠它们。
   </para>

<!--==========================orignal english content==========================
   <para>
    To include a literal <literal>]</literal> in the list, make it the
    first character (after <literal>^</literal>, if that is used).  To
    include a literal <literal>-</literal>, make it the first or last
    character, or the second endpoint of a range.  To use a literal
    <literal>-</literal> as the first endpoint of a range, enclose it
    in <literal>[.</literal> and <literal>.]</literal> to make it a
    collating element (see below).  With the exception of these characters,
    some combinations using <literal>[</literal>
    (see next paragraphs), and escapes (AREs only), all other special
    characters lose their special significance within a bracket expression.
    In particular, <literal>\</literal> is not special when following
    ERE or BRE rules, though it is special (as introducing an escape)
    in AREs.
   </para>
____________________________________________________________________________-->
   <para>
    想在列表中包含文本<literal>]</literal>，可以让它做列表的首字符（如果使用了<literal>^</literal>，需要放在其后）。 想在列表中包含文本<literal>-</literal>，可以让它做列表的首字符或者尾字符，或者一个范围的第二个端点。 想在列表中把文本<literal>-</literal>当做范围的起点， 把它用<literal>[.</literal>和<literal>.]</literal>包围起来，这样它就成为一个排序元素（见下文）。 除了这些字符本身、一些用<literal>[</literal>的组合（见下段）以及逃逸（只在 ARE 中有效）以外，所有其它特殊字符 在方括号表达式里都失去它们的特殊含义。特别是，在 ERE 和 BRE 规则下<literal>\</literal>不是特殊的， 但在 ARE 里，它是特殊的（引入一个逃逸）。
   </para>

<!--==========================orignal english content==========================
   <para>
    Within a bracket expression, a collating element (a character, a
    multiple-character sequence that collates as if it were a single
    character, or a collating-sequence name for either) enclosed in
    <literal>[.</literal> and <literal>.]</literal> stands for the
    sequence of characters of that collating element.  The sequence is
    treated as a single element of the bracket expression's list.  This
    allows a bracket
    expression containing a multiple-character collating element to
    match more than one character, e.g., if the collating sequence
    includes a <literal>ch</literal> collating element, then the RE
    <literal>[[.ch.]]*c</literal> matches the first five characters of
    <literal>chchcc</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    在一个方括号表达式里，一个排序元素（一个字符、一个被当做一个单一字符排序的多字符序列或者一个表示上面两种情况的排序序列名称） 包含在<literal>[.</literal>和<literal>.]</literal>里面的时候表示该排序元素的字符序列。该序列被当做该方括号列表 的一个单一元素。这允许一个包含多字符排序元素的方括号表达式去匹配多于一个字符，例如，如果排序序列包含一个<literal>ch</literal>排序元素， 那么 RE <literal>[[.ch.]]*c</literal>匹配<literal>chchcc</literal>的头五个字符。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     <productname>PostgreSQL</productname> currently does not support multi-character collating
     elements. This information describes possible future behavior.
    </para>
____________________________________________________________________________-->
    <para>
     <productname>PostgreSQL</productname>当前不支持多字符排序元素。这些信息描述了将来可能有的行为。
    </para>
   </note>

<!--==========================orignal english content==========================
   <para>
    Within a bracket expression, a collating element enclosed in
    <literal>[=</literal> and <literal>=]</literal> is an <firstterm>equivalence
    class</firstterm>, standing for the sequences of characters of all collating
    elements equivalent to that one, including itself.  (If there are
    no other equivalent collating elements, the treatment is as if the
    enclosing delimiters were <literal>[.</literal> and
    <literal>.]</literal>.)  For example, if <literal>o</literal> and
    <literal>^</literal> are the members of an equivalence class, then
    <literal>[[=o=]]</literal>, <literal>[[=^=]]</literal>, and
    <literal>[o^]</literal> are all synonymous.  An equivalence class
    cannot be an endpoint of a range.
   </para>
____________________________________________________________________________-->
   <para>
    在方括号表达式里，包围在<literal>[=</literal>和<literal>=]</literal>里的排序元素是一个<firstterm>等价类</firstterm>， 代表等效于那一个的所有排序元素的字符序列，包括它本身（如果没有其它等效排序元素，那么就好象封装定界符是<literal>[.</literal>和 <literal>.]</literal>）。例如，如果<literal>o</literal>和<literal>^</literal>是一个等价类的成员，那么<literal>[[=o=]]</literal>、<literal>[[=^=]]</literal>和<literal>[o^]</literal>都是同义的。一个等价类不能是一个范围的端点。
   </para>

<!--==========================orignal english content==========================
   <para>
    Within a bracket expression, the name of a character class
    enclosed in <literal>[:</literal> and <literal>:]</literal> stands
    for the list of all characters belonging to that class.  A character
    class cannot be used as an endpoint of a range.
    The <acronym>POSIX</acronym> standard defines these character class
    names:
    <literal>alnum</literal> (letters and numeric digits),
    <literal>alpha</literal> (letters),
    <literal>blank</literal> (space and tab),
    <literal>cntrl</literal> (control characters),
    <literal>digit</literal> (numeric digits),
    <literal>graph</literal> (printable characters except space),
    <literal>lower</literal> (lower-case letters),
    <literal>print</literal> (printable characters including space),
    <literal>punct</literal> (punctuation),
    <literal>space</literal> (any white space),
    <literal>upper</literal> (upper-case letters),
    and <literal>xdigit</literal> (hexadecimal digits).
    The behavior of these standard character classes is generally
    consistent across platforms for characters in the 7-bit ASCII set.
    Whether a given non-ASCII character is considered to belong to one
    of these classes depends on the <firstterm>collation</firstterm>
    that is used for the regular-expression function or operator
    (see <xref linkend="collation"/>), or by default on the
    database's <envar>LC_CTYPE</envar> locale setting (see
    <xref linkend="locale"/>).  The classification of non-ASCII
    characters can vary across platforms even in similarly-named
    locales.  (But the <literal>C</literal> locale never considers any
    non-ASCII characters to belong to any of these classes.)
    In addition to these standard character
    classes, <productname>PostgreSQL</productname> defines
    the <literal>ascii</literal> character class, which contains exactly
    the 7-bit ASCII set.
   </para>
____________________________________________________________________________-->
   <para>
    在方括号表达式里，在<literal>[:</literal>和<literal>:]</literal>里面封装的字符类的名字代表属于该类的所有字符的列表。 字符类不能作为范围的端点使用。<acronym>POSIX</acronym>标准定义了这些字符类的名称：
    <literal>alnum</literal> (字符和数字),
    <literal>alpha</literal> (字符),
    <literal>blank</literal> (空格和制表符tab),
    <literal>cntrl</literal> (控制符),
    <literal>digit</literal> (数位数),
    <literal>graph</literal> (空格除外可打印字符),
    <literal>lower</literal> (小写字母),
    <literal>print</literal> (包含空格可打印字符),
    <literal>punct</literal> (标点符号),
    <literal>space</literal> (空白),
    <literal>upper</literal> (大写字母),
    和 <literal>xdigit</literal> (十六进制数).
    对于7位ASCII字符集中的字符来说，这些标准字符类的行为在不同平台上一般是一致的。一个给定的非ASCII字符是否被认为属于这些类别中的一个，取决于正则表达式函数或运算符使用的<firstterm>collation</firstterm>（见<xref linkend="collation"/>），或者默认情况下取决于数据库的<envar>LC_CTYPE</envar> locale设置（见<xref linkend="locale"/>）。非ASCII字符的分类在不同的平台上会有不同的分类，即使是在类似命名的locale中也是如此。 (但<literal>C</literal> locale从不认为任何非ASCII字符属于上述任何一类)。除了这些标准字符类之外，<productname>PostgreSQL</productname>定义了<literal>ascii</literal>字符类，它完全包含7位ASCII字符集。
   </para>

<!--==========================orignal english content==========================
   <para>
    There are two special cases of bracket expressions:  the bracket
    expressions <literal>[[:&lt;:]]</literal> and
    <literal>[[:&gt;:]]</literal> are constraints,
    matching empty strings at the beginning
    and end of a word respectively.  A word is defined as a sequence
    of word characters that is neither preceded nor followed by word
    characters.  A word character is an <literal>alnum</literal> character (as
    defined by the <acronym>POSIX</acronym> character class described above)
    or an underscore.  This is an extension, compatible with but not
    specified by <acronym>POSIX</acronym> 1003.2, and should be used with
    caution in software intended to be portable to other systems.
    The constraint escapes described below are usually preferable; they
    are no more standard, but are easier to type.
   </para>
____________________________________________________________________________-->
   <para>
    方括号表达式里有两个特例：方括号表达式<literal>[[:&lt;:]]</literal>和<literal>[[:&gt;:]]</literal>是约束，分别匹配一个单词开头和结束的空串。 单词定义为一个单词字符序列，前面和后面都没有其它单词字符。单词字符是一个<literal>alnum</literal>字符（和如上所述<acronym>POSIX</acronym>字符类中定义的一样） 或者一个下划线。这是一个扩展，兼容<acronym>POSIX</acronym> 1003.2， 但那里面并没有说明， 而且在准备移植到其他系统里去的软件里一定要小心使用。通常下文描述的约束逃逸更好些（它们并非更标准，但是更容易键入）。
   </para>
   </sect3>

   <sect3 id="posix-escape-sequences">
<!--==========================orignal english content==========================
    <title>Regular Expression Escapes</title>
____________________________________________________________________________-->
    <title>正则表达式逃逸</title>

<!--==========================orignal english content==========================
   <para>
    <firstterm>Escapes</firstterm> are special sequences beginning with <literal>\</literal>
    followed by an alphanumeric character. Escapes come in several varieties:
    character entry, class shorthands, constraint escapes, and back references.
    A <literal>\</literal> followed by an alphanumeric character but not constituting
    a valid escape is illegal in AREs.
    In EREs, there are no escapes: outside a bracket expression,
    a <literal>\</literal> followed by an alphanumeric character merely stands for
    that character as an ordinary character, and inside a bracket expression,
    <literal>\</literal> is an ordinary character.
    (The latter is the one actual incompatibility between EREs and AREs.)
   </para>
____________________________________________________________________________-->
   <para>
    <firstterm>逃逸</firstterm>是以<literal>\</literal>开头，后面跟着一个字母数字字符得特殊序列。 逃逸有好几种变体：字符项、类缩写、约束逃逸以及后引用。在 ARE 里， 如果一个<literal>\</literal>后面跟着一个字母数字，但是并未组成一个合法的逃逸， 那么它是非法的。在 ERE 中没有逃逸：在方括号表达式之外，一个后面跟着字母数字字符的<literal>\</literal>只是表示该字符是一个普通的字符，而且在一个方括号表达式里，<literal>\</literal>是一个普通的字符（后者实际上在 ERE 和 ARE 不兼容）。
   </para>

<!--==========================orignal english content==========================
   <para>
    <firstterm>Character-entry escapes</firstterm> exist to make it easier to specify
    non-printing and other inconvenient characters in REs.  They are
    shown in <xref linkend="posix-character-entry-escapes-table"/>.
   </para>
____________________________________________________________________________-->
   <para>
    <firstterm>字符项逃逸</firstterm>用于便于我们在 RE 中声明那些不可打印的或其他习惯的字符。它们显示在<xref linkend="posix-character-entry-escapes-table"/>中。
   </para>

<!--==========================orignal english content==========================
   <para>
    <firstterm>Class-shorthand escapes</firstterm> provide shorthands for certain
    commonly-used character classes.  They are
    shown in <xref linkend="posix-class-shorthand-escapes-table"/>.
   </para>
____________________________________________________________________________-->
   <para>
    <firstterm>类缩写逃逸</firstterm>用来提供一些常用的字符类缩写。它们显示在<xref linkend="posix-class-shorthand-escapes-table"/>中。
   </para>

<!--==========================orignal english content==========================
   <para>
    A <firstterm>constraint escape</firstterm> is a constraint,
    matching the empty string if specific conditions are met,
    written as an escape.  They are
    shown in <xref linkend="posix-constraint-escapes-table"/>.
   </para>
____________________________________________________________________________-->
   <para>
    <firstterm>约束逃逸</firstterm>是一个约束，如果满足特定的条件，它匹配该空串。它们显示在<xref linkend="posix-constraint-escapes-table"/>中。
   </para>

<!--==========================orignal english content==========================
   <para>
    A <firstterm>back reference</firstterm> (<literal>\</literal><replaceable>n</replaceable>) matches the
    same string matched by the previous parenthesized subexpression specified
    by the number <replaceable>n</replaceable>
    (see <xref linkend="posix-constraint-backref-table"/>).  For example,
    <literal>([bc])\1</literal> matches <literal>bb</literal> or <literal>cc</literal>
    but not <literal>bc</literal> or <literal>cb</literal>.
    The subexpression must entirely precede the back reference in the RE.
    Subexpressions are numbered in the order of their leading parentheses.
    Non-capturing parentheses do not define subexpressions.
   </para>
____________________________________________________________________________-->
   <para>
    <firstterm>后引用</firstterm>（<literal>\</literal><replaceable>n</replaceable>）匹配数字<literal>\</literal><replaceable>n</replaceable>指定的被前面的圆括号子表达式匹配的同一个串 （参阅<xref linkend="posix-constraint-backref-table"/>）。例如， <literal>([bc])\1</literal>匹配<literal>bb</literal>或者<literal>cc</literal>， 但是不匹配<literal>bc</literal>或者<literal>cb</literal>。RE 中子表达式必须完全在后引用前面。子表达式以它们的先导圆括号的顺序编号。非捕获圆括号并不定义子表达式。
   </para>

   <table id="posix-character-entry-escapes-table">
<!--==========================orignal english content==========================
    <title>Regular Expression Character-Entry Escapes</title>
____________________________________________________________________________-->
    <title>正则表达式字符项逃逸</title>

    <tgroup cols="2">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Escape</entry>
       <entry>Description</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>逃逸</entry>
       <entry>描述</entry>
      </row>
     </thead>

      <tbody>
<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\a</literal> </entry>
       <entry> alert (bell) character, as in C </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\a</literal> </entry>
       <entry>警告（响铃）字符，和 C 中一样</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\b</literal> </entry>
       <entry> backspace, as in C </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\b</literal> </entry>
       <entry>退格，和 C 中一样</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\B</literal> </entry>
       <entry> synonym for backslash (<literal>\</literal>) to help reduce the need for backslash
       doubling </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\B</literal> </entry>
       <entry>反斜线（<literal>\</literal>）的同义词，用来减少双写反斜线</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\c</literal><replaceable>X</replaceable> </entry>
       <entry> (where <replaceable>X</replaceable> is any character) the character whose
       low-order 5 bits are the same as those of
       <replaceable>X</replaceable>, and whose other bits are all zero </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\c</literal><replaceable>X</replaceable> </entry>
       <entry>（其中<replaceable>X</replaceable>是任意字符）低序5位和<replaceable>X</replaceable>相同的字符，它的其他位都是零</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\e</literal> </entry>
       <entry> the character whose collating-sequence name
       is <literal>ESC</literal>,
       or failing that, the character with octal value <literal>033</literal> </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\e</literal> </entry>
       <entry>排序序列名为<literal>ESC</literal>的字符，如果无法做到该字符为八进制值 <literal>033</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\f</literal> </entry>
       <entry> form feed, as in C </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\f</literal> </entry>
       <entry>换页，和 C 中一样</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\n</literal> </entry>
       <entry> newline, as in C </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\n</literal> </entry>
       <entry>新行，和 C 中一样</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\r</literal> </entry>
       <entry> carriage return, as in C </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\r</literal> </entry>
       <entry>回车，和 C 中一样</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\t</literal> </entry>
       <entry> horizontal tab, as in C </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\t</literal> </entry>
       <entry>水平制表符，和 C 中一样</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\u</literal><replaceable>wxyz</replaceable> </entry>
       <entry> (where <replaceable>wxyz</replaceable> is exactly four hexadecimal digits)
       the character whose hexadecimal value is
       <literal>0x</literal><replaceable>wxyz</replaceable>
       </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\u</literal><replaceable>wxyz</replaceable> </entry>
       <entry>（其中<replaceable>wxyz</replaceable>正好是四个十六进制位）十六进制值为<literal>0x</literal><replaceable>wxyz</replaceable>的字符</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\U</literal><replaceable>stuvwxyz</replaceable> </entry>
       <entry> (where <replaceable>stuvwxyz</replaceable> is exactly eight hexadecimal
       digits)
       the character whose hexadecimal value is
       <literal>0x</literal><replaceable>stuvwxyz</replaceable>
       </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\U</literal><replaceable>stuvwxyz</replaceable> </entry>
       <entry>（其中<replaceable>stuvwxyz</replaceable>正好是八个十六进制位）十六进制值为<literal>0x</literal><replaceable>stuvwxyz</replaceable>的字符
       </entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\v</literal> </entry>
       <entry> vertical tab, as in C </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\v</literal> </entry>
       <entry>垂直制表符，和 C 中一样</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\x</literal><replaceable>hhh</replaceable> </entry>
       <entry> (where <replaceable>hhh</replaceable> is any sequence of hexadecimal
       digits)
       the character whose hexadecimal value is
       <literal>0x</literal><replaceable>hhh</replaceable>
       (a single character no matter how many hexadecimal digits are used)
       </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\x</literal><replaceable>hhh</replaceable> </entry>
       <entry>（其中<replaceable>hhh</replaceable>是十六进制位的任意序列）十六进制值为<literal>0x</literal><replaceable>hhh</replaceable>的字符（一个单一字符，不管用了多少个十六进制位）
       </entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\0</literal> </entry>
       <entry> the character whose value is <literal>0</literal> (the null byte)</entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\0</literal> </entry>
       <entry>值为<literal>0</literal>（空字节）的字符</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\</literal><replaceable>xy</replaceable> </entry>
       <entry> (where <replaceable>xy</replaceable> is exactly two octal digits,
       and is not a <firstterm>back reference</firstterm>)
       the character whose octal value is
       <literal>0</literal><replaceable>xy</replaceable> </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\</literal><replaceable>xy</replaceable> </entry>
       <entry>（其中<replaceable>xy</replaceable>正好是两个八进制位，并且不是一个<firstterm>后引用</firstterm>）八进制值为<literal>0</literal><replaceable>xy</replaceable>的字符</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\</literal><replaceable>xyz</replaceable> </entry>
       <entry> (where <replaceable>xyz</replaceable> is exactly three octal digits,
       and is not a <firstterm>back reference</firstterm>)
       the character whose octal value is
       <literal>0</literal><replaceable>xyz</replaceable> </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\</literal><replaceable>xyz</replaceable> </entry>
       <entry>（其中<replaceable>xyz</replaceable>正好是三个八进制位，并且不是一个<firstterm>后引用</firstterm>）八进制值为<literal>0</literal><replaceable>xyz</replaceable>的字符</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

<!--==========================orignal english content==========================
   <para>
    Hexadecimal digits are <literal>0</literal>-<literal>9</literal>,
    <literal>a</literal>-<literal>f</literal>, and <literal>A</literal>-<literal>F</literal>.
    Octal digits are <literal>0</literal>-<literal>7</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    十六进制位是<literal>0</literal>-<literal>9</literal>、<literal>a</literal>-<literal>f</literal>和<literal>A</literal>-<literal>F</literal>。八进制位是<literal>0</literal>-<literal>7</literal>。
   </para>

<!--==========================orignal english content==========================
   <para>
    Numeric character-entry escapes specifying values outside the ASCII range
    (0&ndash;127) have meanings dependent on the database encoding.  When the
    encoding is UTF-8, escape values are equivalent to Unicode code points,
    for example <literal>\u1234</literal> means the character <literal>U+1234</literal>.
    For other multibyte encodings, character-entry escapes usually just
    specify the concatenation of the byte values for the character.  If the
    escape value does not correspond to any legal character in the database
    encoding, no error will be raised, but it will never match any data.
   </para>
____________________________________________________________________________-->
   <para>
    指定 ASCII 范围（0&ndash;127）之外的值的数字字符项转义的含义取决于数据库编码。
    当编码是 UTF-8 时，转义值等价于 Unicode 代码点，例如
    <literal>\u1234</literal>表示字符<literal>U+1234</literal>。对于其他多字节编码，
    字符项转义通常只是指定该字符的字节值的串接。如果该转义值不对应数据库编码
    中的任何合法字符，将不会发生错误，但是它不会匹配任何数据。
   </para>

<!--==========================orignal english content==========================
   <para>
    The character-entry escapes are always taken as ordinary characters.
    For example, <literal>\135</literal> is <literal>]</literal> in ASCII, but
    <literal>\135</literal> does not terminate a bracket expression.
   </para>
____________________________________________________________________________-->
   <para>
    字符项逃逸总是被当作普通字符。例如，<literal>\135</literal>是 ASCII 中的<literal>]</literal>， 但<literal>\135</literal>并不终止一个方括号表达式。
   </para>

   <table id="posix-class-shorthand-escapes-table">
<!--==========================orignal english content==========================
    <title>Regular Expression Class-Shorthand Escapes</title>
____________________________________________________________________________-->
    <title>正则表达式类缩写逃逸</title>

    <tgroup cols="2">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Escape</entry>
       <entry>Description</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>逃逸</entry>
       <entry>描述</entry>
      </row>
     </thead>

      <tbody>
<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\d</literal> </entry>
       <entry> <literal>[[:digit:]]</literal> </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\d</literal> </entry>
       <entry> <literal>[[:digit:]]</literal> </entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\s</literal> </entry>
       <entry> <literal>[[:space:]]</literal> </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\s</literal> </entry>
       <entry> <literal>[[:space:]]</literal> </entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\w</literal> </entry>
       <entry> <literal>[[:alnum:]_]</literal>
       (note underscore is included) </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\w</literal> </entry>
       <entry> <literal>[[:alnum:]_]</literal>（注意下划线是被包括的）</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\D</literal> </entry>
       <entry> <literal>[^[:digit:]]</literal> </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\D</literal> </entry>
       <entry> <literal>[^[:digit:]]</literal> </entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\S</literal> </entry>
       <entry> <literal>[^[:space:]]</literal> </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\S</literal> </entry>
       <entry> <literal>[^[:space:]]</literal> </entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\W</literal> </entry>
       <entry> <literal>[^[:alnum:]_]</literal>
       (note underscore is included) </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\W</literal> </entry>
       <entry> <literal>[^[:alnum:]_]</literal>
       （注意下划线是被包括的）</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

<!--==========================orignal english content==========================
   <para>
    Within bracket expressions, <literal>\d</literal>, <literal>\s</literal>,
    and <literal>\w</literal> lose their outer brackets,
    and <literal>\D</literal>, <literal>\S</literal>, and <literal>\W</literal> are illegal.
    (So, for example, <literal>[a-c\d]</literal> is equivalent to
    <literal>[a-c[:digit:]]</literal>.
    Also, <literal>[a-c\D]</literal>, which is equivalent to
    <literal>[a-c^[:digit:]]</literal>, is illegal.)
   </para>
____________________________________________________________________________-->
   <para>
    在方括号表达式里，<literal>\d</literal>、<literal>\s</literal>和<literal>\w</literal>会失去它们的外层方括号，而<literal>\D</literal>、<literal>\S</literal>和 <literal>\W</literal>是非法的（也就是说，例如<literal>[a-c\d]</literal>等效于<literal>[a-c[:digit:]]</literal>。同样<literal>[a-c\D]</literal>等效于 <literal>[a-c^[:digit:]]</literal>的，也是非法的）。
   </para>

   <table id="posix-constraint-escapes-table">
<!--==========================orignal english content==========================
    <title>Regular Expression Constraint Escapes</title>
____________________________________________________________________________-->
    <title>正则表达式约束逃逸</title>

    <tgroup cols="2">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Escape</entry>
       <entry>Description</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>逃逸</entry>
       <entry>描述</entry>
      </row>
     </thead>

      <tbody>
<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\A</literal> </entry>
       <entry> matches only at the beginning of the string
       (see <xref linkend="posix-matching-rules"/> for how this differs from
       <literal>^</literal>) </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\A</literal> </entry>
       <entry>只在串开头匹配（与<literal>^</literal>的不同请参见<xref linkend="posix-matching-rules"/>）</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\m</literal> </entry>
       <entry> matches only at the beginning of a word </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\m</literal> </entry>
       <entry>只在一个词的开头匹配</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\M</literal> </entry>
       <entry> matches only at the end of a word </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\M</literal> </entry>
       <entry>只在一个词的末尾匹配</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\y</literal> </entry>
       <entry> matches only at the beginning or end of a word </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\y</literal> </entry>
       <entry>只在一个词的开头或末尾匹配</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\Y</literal> </entry>
       <entry> matches only at a point that is not the beginning or end of a
       word </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\Y</literal> </entry>
       <entry>只在一个词的不是开头或末尾的点上匹配</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\Z</literal> </entry>
       <entry> matches only at the end of the string
       (see <xref linkend="posix-matching-rules"/> for how this differs from
       <literal>$</literal>) </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\Z</literal> </entry>
       <entry>只在串的末尾匹配（与<literal>$</literal>的不同请参见<xref linkend="posix-matching-rules"/>）</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

<!--==========================orignal english content==========================
   <para>
    A word is defined as in the specification of
    <literal>[[:&lt;:]]</literal> and <literal>[[:&gt;:]]</literal> above.
    Constraint escapes are illegal within bracket expressions.
   </para>
____________________________________________________________________________-->
   <para>
    一个词被定义成在上面<literal>[[:&lt;:]]</literal>和<literal>[[:&gt;:]]</literal>中的声明。在方括号表达式里，约束逃逸是非法的。
   </para>

   <table id="posix-constraint-backref-table">
<!--==========================orignal english content==========================
    <title>Regular Expression Back References</title>
____________________________________________________________________________-->
    <title>正则表达式后引用</title>

    <tgroup cols="2">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Escape</entry>
       <entry>Description</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>逃逸</entry>
       <entry>描述</entry>
      </row>
     </thead>

      <tbody>
<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\</literal><replaceable>m</replaceable> </entry>
       <entry> (where <replaceable>m</replaceable> is a nonzero digit)
       a back reference to the <replaceable>m</replaceable>'th subexpression </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\</literal><replaceable>m</replaceable> </entry>
       <entry>（其中<replaceable>m</replaceable>是一个非零位）一个到第<replaceable>m</replaceable>个子表达式的后引用</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>\</literal><replaceable>mnn</replaceable> </entry>
       <entry> (where <replaceable>m</replaceable> is a nonzero digit, and
       <replaceable>nn</replaceable> is some more digits, and the decimal value
       <replaceable>mnn</replaceable> is not greater than the number of closing capturing
       parentheses seen so far)
       a back reference to the <replaceable>mnn</replaceable>'th subexpression </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>\</literal><replaceable>mnn</replaceable> </entry>
       <entry>（其中<replaceable>m</replaceable>是一个非零位，并且<replaceable>nn</replaceable>是一些更多的位，并且十六进制值<replaceable>mnn</replaceable>不超过目前能看到的封闭捕获圆括号的数目）一个到第<replaceable>mnn</replaceable>个子表达式的后引用</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <note>
<!--==========================orignal english content==========================
    <para>
     There is an inherent ambiguity between octal character-entry
     escapes and back references, which is resolved by the following heuristics,
     as hinted at above.
     A leading zero always indicates an octal escape.
     A single non-zero digit, not followed by another digit,
     is always taken as a back reference.
     A multi-digit sequence not starting with a zero is taken as a back
     reference if it comes after a suitable subexpression
     (i.e., the number is in the legal range for a back reference),
     and otherwise is taken as octal.
    </para>
____________________________________________________________________________-->
    <para>
     在八进制字符项逃逸和后引用之间有一个历史继承的歧义存在，这个歧义是 通过下面的启发式规则解决的，像上面描述地那样。前导零总是表示这是一个八进制逃逸。 而单个非零数字，如果没有跟着任何其它位，那么总是被认为后引用。 一个多位的非零开头的序列也被认为是后引用，只要它出现在合适的子表达式后面 （也就是说，在后引用的合法范围中的数），否则就被认为是一个八进制。
    </para>
   </note>
   </sect3>

   <sect3 id="posix-metasyntax">
<!--==========================orignal english content==========================
    <title>Regular Expression Metasyntax</title>
____________________________________________________________________________-->
    <title>正则表达式元语法</title>

<!--==========================orignal english content==========================
   <para>
    In addition to the main syntax described above, there are some special
    forms and miscellaneous syntactic facilities available.
   </para>
____________________________________________________________________________-->
   <para>
    除了上面描述的主要语法之外，还有几种特殊形式和杂项语法。
   </para>

<!--==========================orignal english content==========================
   <para>
    An RE can begin with one of two special <firstterm>director</firstterm> prefixes.
    If an RE begins with <literal>***:</literal>,
    the rest of the RE is taken as an ARE.  (This normally has no effect in
    <productname>PostgreSQL</productname>, since REs are assumed to be AREs;
    but it does have an effect if ERE or BRE mode had been specified by
    the <replaceable>flags</replaceable> parameter to a regex function.)
    If an RE begins with <literal>***=</literal>,
    the rest of the RE is taken to be a literal string,
    with all characters considered ordinary characters.
   </para>
____________________________________________________________________________-->
   <para>
    如果一个 RE 以<literal>***:</literal>开头，那么剩下的 RE 都被当作 ARE（这在<productname>PostgreSQL</productname>中通常是无效的，因为 RE 被假定为 ARE，但是如果 ERE 或 BRE 模式通过<replaceable>flags</replaceable>参数被指定为一个正则表达式函数时，它确实能产生效果）。如果一个 RE 以<literal>***=</literal>开头， 那么剩下的 RE 被当作一个文本串，所有的字符都被认为是一个普通字符。
   </para>

<!--==========================orignal english content==========================
   <para>
    An ARE can begin with <firstterm>embedded options</firstterm>:
    a sequence <literal>(?</literal><replaceable>xyz</replaceable><literal>)</literal>
    (where <replaceable>xyz</replaceable> is one or more alphabetic characters)
    specifies options affecting the rest of the RE.
    These options override any previously determined options &mdash;
    in particular, they can override the case-sensitivity behavior implied by
    a regex operator, or the <replaceable>flags</replaceable> parameter to a regex
    function.
    The available option letters are
    shown in <xref linkend="posix-embedded-options-table"/>.
    Note that these same option letters are used in the <replaceable>flags</replaceable>
    parameters of regex functions.
   </para>
____________________________________________________________________________-->
   <para>
    一个 ARE 可以以<firstterm>嵌入选项</firstterm>开头：一个序列<literal>(?</literal><replaceable>xyz</replaceable><literal>)</literal>（这里的<replaceable>xyz</replaceable>是一个或多个字母字符）声明影响剩余 RE 的选项。 这些选项覆盖任何前面判断的选项 &mdash; 特别地，它们可以覆盖一个正则表达式操作符隐含的大小写敏感的行为，或者覆盖<replaceable>flags</replaceable>参数中的正则表达式函数。可用的选项字母在<xref linkend="posix-embedded-options-table"/>中显示。注意这些同样的选项字母也被用在正则表达式函数的<replaceable>flags</replaceable>参数中。
   </para>

   <table id="posix-embedded-options-table">
<!--==========================orignal english content==========================
    <title>ARE Embedded-Option Letters</title>
____________________________________________________________________________-->
    <title>ARE 嵌入选项字母</title>

    <tgroup cols="2">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Option</entry>
       <entry>Description</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>选项</entry>
       <entry>描述</entry>
      </row>
     </thead>

      <tbody>
<!--==========================orignal english content==========================
       <row>
       <entry> <literal>b</literal> </entry>
       <entry> rest of RE is a BRE </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>b</literal> </entry>
       <entry>RE的剩余部分是一个BRE </entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>c</literal> </entry>
       <entry> case-sensitive matching (overrides operator type) </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>c</literal> </entry>
       <entry>大小写敏感的匹配（覆盖操作符类型）</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>e</literal> </entry>
       <entry> rest of RE is an ERE </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>e</literal> </entry>
       <entry>RE的剩余部分是一个ERE </entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>i</literal> </entry>
       <entry> case-insensitive matching (see
       <xref linkend="posix-matching-rules"/>) (overrides operator type) </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>i</literal> </entry>
       <entry>大小写不敏感的匹配（见<xref linkend="posix-matching-rules"/>）（覆盖操作符类型）</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>m</literal> </entry>
       <entry> historical synonym for <literal>n</literal> </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>m</literal> </entry>
       <entry><literal>n</literal>的历史原因的同义词 </entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>n</literal> </entry>
       <entry> newline-sensitive matching (see
       <xref linkend="posix-matching-rules"/>) </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>n</literal> </entry>
       <entry>新行敏感的匹配（见<xref linkend="posix-matching-rules"/>）</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>p</literal> </entry>
       <entry> partial newline-sensitive matching (see
       <xref linkend="posix-matching-rules"/>) </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>p</literal> </entry>
       <entry>部分新行敏感的匹配（见<xref linkend="posix-matching-rules"/>）</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>q</literal> </entry>
       <entry> rest of RE is a literal (<quote>quoted</quote>) string, all ordinary
       characters </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>q</literal> </entry>
       <entry>RE的剩余部分是一个文字（<quote>quoted</quote>）串，全部是普通字符</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>s</literal> </entry>
       <entry> non-newline-sensitive matching (default) </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>s</literal> </entry>
       <entry>非新行敏感的匹配（默认）</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>t</literal> </entry>
       <entry> tight syntax (default; see below) </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>t</literal> </entry>
       <entry>紧语法（默认，见下文）</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>w</literal> </entry>
       <entry> inverse partial newline-sensitive (<quote>weird</quote>) matching
       (see <xref linkend="posix-matching-rules"/>) </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>w</literal> </entry>
       <entry>逆部分新行敏感（<quote>怪异</quote>）的匹配（见<xref linkend="posix-matching-rules"/>）</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
       <entry> <literal>x</literal> </entry>
       <entry> expanded syntax (see below) </entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry> <literal>x</literal> </entry>
       <entry>扩展语法（见下文）</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

<!--==========================orignal english content==========================
   <para>
    Embedded options take effect at the <literal>)</literal> terminating the sequence.
    They can appear only at the start of an ARE (after the
    <literal>***:</literal> director if any).
   </para>
____________________________________________________________________________-->
   <para>
    嵌入选项在<literal>)</literal>终止序列时发生作用。它们只在 ARE 的开始处起作用 （在任何可能存在的<literal>***:</literal>控制器后面）。
   </para>

<!--==========================orignal english content==========================
   <para>
    In addition to the usual (<firstterm>tight</firstterm>) RE syntax, in which all
    characters are significant, there is an <firstterm>expanded</firstterm> syntax,
    available by specifying the embedded <literal>x</literal> option.
    In the expanded syntax,
    white-space characters in the RE are ignored, as are
    all characters between a <literal>#</literal>
    and the following newline (or the end of the RE).  This
    permits paragraphing and commenting a complex RE.
    There are three exceptions to that basic rule:

    <itemizedlist>
     <listitem>
      <para>
       a white-space character or <literal>#</literal> preceded by <literal>\</literal> is
       retained
      </para>
     </listitem>
     <listitem>
      <para>
       white space or <literal>#</literal> within a bracket expression is retained
      </para>
     </listitem>
     <listitem>
      <para>
       white space and comments cannot appear within multi-character symbols,
       such as <literal>(?:</literal>
      </para>
     </listitem>
    </itemizedlist>

    For this purpose, white-space characters are blank, tab, newline, and
    any character that belongs to the <replaceable>space</replaceable> character class.
   </para>
____________________________________________________________________________-->
   <para>
    除了通常的（<firstterm>紧</firstterm>）RE 语法（这种情况下所有字符都有效）， 还有一种<firstterm>扩展</firstterm>语法，可以通过声明嵌入的<literal>x</literal>选项获得。在扩展语法里，RE 中的空白字符被忽略，就像那些在<literal>#</literal>和其后的新行（或 RE 的末尾）之间的字符一样。这样就允许我们给一个复杂的 RE 分段和注释。不过这个基本规则有三种例外：

    <itemizedlist>
     <listitem>
      <para>
       空白字符或前置了<literal>\</literal>的<literal>#</literal>将被保留
      </para>
     </listitem>
     <listitem>
      <para>
       方括号表达式里的空白或者<literal>#</literal>将被保留
      </para>
     </listitem>
     <listitem>
      <para>
       在多字符符号里面不能出现空白和注释，例如<literal>(?:</literal>
      </para>
     </listitem>
    </itemizedlist>

    为了这个目的，空白是空格、制表符、新行和任何属于<replaceable>空白</replaceable>字符类的字符。
   </para>

<!--==========================orignal english content==========================
   <para>
    Finally, in an ARE, outside bracket expressions, the sequence
    <literal>(?#</literal><replaceable>ttt</replaceable><literal>)</literal>
    (where <replaceable>ttt</replaceable> is any text not containing a <literal>)</literal>)
    is a comment, completely ignored.
    Again, this is not allowed between the characters of
    multi-character symbols, like <literal>(?:</literal>.
    Such comments are more a historical artifact than a useful facility,
    and their use is deprecated; use the expanded syntax instead.
   </para>
____________________________________________________________________________-->
   <para>
    最后，在 ARE 里，方括号表达式外面，序列<literal>(?#</literal><replaceable>ttt</replaceable><literal>)</literal>（其中<replaceable>ttt</replaceable>是任意不包含一个<literal>)</literal>)的文本）是一个注释， 它被完全忽略。同样，这样的东西是不允许出现在多字符符号的字符中间的，例如 <literal>(?:</literal>。这种注释更像是一种历史产物而不是一种有用的设施，并且它们的使用已经被废弃；请使用扩展语法来替代。   </para>

<!--==========================orignal english content==========================
   <para>
    <emphasis>None</emphasis> of these metasyntax extensions is available if
    an initial <literal>***=</literal> director
    has specified that the user's input be treated as a literal string
    rather than as an RE.
   </para>
____________________________________________________________________________-->
   <para>
    如果声明了一个初始的<literal>***=</literal>控制器，那么所有这些元语法扩展<emphasis>都不能</emphasis>使用，因为这样表示把用户输入当作一个文字串而不是 RE 对待。
   </para>
   </sect3>

   <sect3 id="posix-matching-rules">
<!--==========================orignal english content==========================
    <title>Regular Expression Matching Rules</title>
____________________________________________________________________________-->
    <title>正则表达式匹配规则</title>

<!--==========================orignal english content==========================
   <para>
    In the event that an RE could match more than one substring of a given
    string, the RE matches the one starting earliest in the string.
    If the RE could match more than one substring starting at that point,
    either the longest possible match or the shortest possible match will
    be taken, depending on whether the RE is <firstterm>greedy</firstterm> or
    <firstterm>non-greedy</firstterm>.
   </para>
____________________________________________________________________________-->
   <para>
    在 RE 可以在给定串中匹配多于一个子串的情况下， RE 匹配串中最靠前的那个子串。如果 RE 可以匹配在那个位置开始 的多个子串，要么是取最长的子串，要么是最短的，具体哪种， 取决于 RE 是<firstterm>贪婪</firstterm>的还是<firstterm>非贪婪</firstterm>的。
   </para>

<!--==========================orignal english content==========================
   <para>
    Whether an RE is greedy or not is determined by the following rules:
    <itemizedlist>
     <listitem>
      <para>
       Most atoms, and all constraints, have no greediness attribute (because
       they cannot match variable amounts of text anyway).
      </para>
     </listitem>
     <listitem>
      <para>
       Adding parentheses around an RE does not change its greediness.
      </para>
     </listitem>
     <listitem>
      <para>
       A quantified atom with a fixed-repetition quantifier
       (<literal>{</literal><replaceable>m</replaceable><literal>}</literal>
       or
       <literal>{</literal><replaceable>m</replaceable><literal>}?</literal>)
       has the same greediness (possibly none) as the atom itself.
      </para>
     </listitem>
     <listitem>
      <para>
       A quantified atom with other normal quantifiers (including
       <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal>
       with <replaceable>m</replaceable> equal to <replaceable>n</replaceable>)
       is greedy (prefers longest match).
      </para>
     </listitem>
     <listitem>
      <para>
       A quantified atom with a non-greedy quantifier (including
       <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}?</literal>
       with <replaceable>m</replaceable> equal to <replaceable>n</replaceable>)
       is non-greedy (prefers shortest match).
      </para>
     </listitem>
     <listitem>
      <para>
       A branch &mdash; that is, an RE that has no top-level
       <literal>|</literal> operator &mdash; has the same greediness as the first
       quantified atom in it that has a greediness attribute.
      </para>
     </listitem>
     <listitem>
      <para>
       An RE consisting of two or more branches connected by the
       <literal>|</literal> operator is always greedy.
      </para>
     </listitem>
    </itemizedlist>
   </para>
____________________________________________________________________________-->
   <para>
    一个 RE 是否贪婪取决于下面规则：
    <itemizedlist>
     <listitem>
      <para>
       大多数原子以及所有约束，都没有贪婪属性（因为它们毕竟无法匹配个数变化的文本）。
      </para>
     </listitem>
     <listitem>
      <para>
       在一个 RE 周围加上圆括号并不会改变其贪婪性。
      </para>
     </listitem>
     <listitem>
      <para>
       带一个固定重复次数量词 （<literal>{</literal><replaceable>m</replaceable><literal>}</literal>或者<literal>{</literal><replaceable>m</replaceable><literal>}?</literal>） 的量化原子和原子自身具有同样的贪婪性（可能是没有）。
      </para>
     </listitem>
     <listitem>
      <para>
       一个带其他普通的量词（包括<literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal>中<replaceable>m</replaceable>等于<replaceable>n</replaceable>的情况）的量化原子是贪婪的（首选最长匹配）。
      </para>
     </listitem>
     <listitem>
      <para>
       一个带非贪婪量词（包括<literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}?</literal>中<replaceable>m</replaceable>等于 <replaceable>n</replaceable>的情况）的量化原子是非贪婪的（首选最短匹配）。
      </para>
     </listitem>
     <listitem>
      <para>
       一个分支 &mdash; 也就是说，一个没有顶级<literal>|</literal>操作符的 RE &mdash; 和它里面的第一个有贪婪属性的量化原子有着同样的贪婪性。
      </para>
     </listitem>
     <listitem>
      <para>
       一个由<literal>|</literal>操作符连接起来的两个或者更多分支组成的 RE 总是贪婪的。
      </para>
     </listitem>
    </itemizedlist>
   </para>

<!--==========================orignal english content==========================
   <para>
    The above rules associate greediness attributes not only with individual
    quantified atoms, but with branches and entire REs that contain quantified
    atoms.  What that means is that the matching is done in such a way that
    the branch, or whole RE, matches the longest or shortest possible
    substring <emphasis>as a whole</emphasis>.  Once the length of the entire match
    is determined, the part of it that matches any particular subexpression
    is determined on the basis of the greediness attribute of that
    subexpression, with subexpressions starting earlier in the RE taking
    priority over ones starting later.
   </para>
____________________________________________________________________________-->
   <para>
    上面的规则所描述的贪婪属性不仅仅适用于独立的量化原子， 而且也适用于包含量化原子的分支和整个 RE。这里的意思是， 匹配是按照分支或者整个 RE <emphasis>作为一个整体</emphasis>匹配最长或者最短的可能子串。 一旦整个匹配的长度确定，那么匹配任意特定子表达式的部分就基于该子表达式的贪婪属性进行判断，在 RE 里面靠前的子表达式的优先级高于靠后的子表达式。
   </para>

<!--==========================orignal english content==========================
   <para>
    An example of what this means:
<screen>
SELECT SUBSTRING('XY1234Z', 'Y*([0-9]{1,3})');
<lineannotation>Result: </lineannotation><computeroutput>123</computeroutput>
SELECT SUBSTRING('XY1234Z', 'Y*?([0-9]{1,3})');
<lineannotation>Result: </lineannotation><computeroutput>1</computeroutput>
</screen>
    In the first case, the RE as a whole is greedy because <literal>Y*</literal>
    is greedy.  It can match beginning at the <literal>Y</literal>, and it matches
    the longest possible string starting there, i.e., <literal>Y123</literal>.
    The output is the parenthesized part of that, or <literal>123</literal>.
    In the second case, the RE as a whole is non-greedy because <literal>Y*?</literal>
    is non-greedy.  It can match beginning at the <literal>Y</literal>, and it matches
    the shortest possible string starting there, i.e., <literal>Y1</literal>.
    The subexpression <literal>[0-9]{1,3}</literal> is greedy but it cannot change
    the decision as to the overall match length; so it is forced to match
    just <literal>1</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    一个相应的例子：
<screen>
SELECT SUBSTRING('XY1234Z', 'Y*([0-9]{1,3})');
<lineannotation>结果：</lineannotation><computeroutput>123</computeroutput>
SELECT SUBSTRING('XY1234Z', 'Y*?([0-9]{1,3})');
<lineannotation>结果：</lineannotation><computeroutput>1</computeroutput>
</screen>
    在第一个例子里，RE 作为整体是贪婪的，因为<literal>Y*</literal>是贪婪的。它可以匹配从<literal>Y</literal>开始的东西，并且它匹配从这个位置开始的最长的串， 也就是，<literal>Y123</literal>。输出是这里的圆括号包围的部分，或者说是<literal>123</literal>。在第二个例子里， RE 总体上是一个非贪婪的 RE，因为<literal>Y*?</literal>是非贪婪的。它可以匹配从<literal>Y</literal>开始的最短的子串，也就是说<literal>Y1</literal>。子表达式<literal>[0-9]{1,3}</literal>是贪婪的，但是它不能修改总体匹配长度的决定； 因此它被迫只匹配<literal>1</literal>。
   </para>

<!--==========================orignal english content==========================
   <para>
    In short, when an RE contains both greedy and non-greedy subexpressions,
    the total match length is either as long as possible or as short as
    possible, according to the attribute assigned to the whole RE.  The
    attributes assigned to the subexpressions only affect how much of that
    match they are allowed to <quote>eat</quote> relative to each other.
   </para>
____________________________________________________________________________-->
   <para>
    简而言之，如果一个 RE 同时包含贪婪和非贪婪的子表达式，那么总的匹配长度要么是尽可能长，要么是尽可能短，这取决于给整个 RE 赋予的属性。给子表达式赋予的属性只影响在这个匹配里，各个子表达式之间相互允许<quote>吃掉</quote>的多少。
   </para>

<!--==========================orignal english content==========================
   <para>
    The quantifiers <literal>{1,1}</literal> and <literal>{1,1}?</literal>
    can be used to force greediness or non-greediness, respectively,
    on a subexpression or a whole RE.
    This is useful when you need the whole RE to have a greediness attribute
    different from what's deduced from its elements.  As an example,
    suppose that we are trying to separate a string containing some digits
    into the digits and the parts before and after them.  We might try to
    do that like this:
<screen>
SELECT regexp_match('abc01234xyz', '(.*)(\d+)(.*)');
<lineannotation>Result: </lineannotation><computeroutput>{abc0123,4,xyz}</computeroutput>
</screen>
    That didn't work: the first <literal>.*</literal> is greedy so
    it <quote>eats</quote> as much as it can, leaving the <literal>\d+</literal> to
    match at the last possible place, the last digit.  We might try to fix
    that by making it non-greedy:
<screen>
SELECT regexp_match('abc01234xyz', '(.*?)(\d+)(.*)');
<lineannotation>Result: </lineannotation><computeroutput>{abc,0,""}</computeroutput>
</screen>
    That didn't work either, because now the RE as a whole is non-greedy
    and so it ends the overall match as soon as possible.  We can get what
    we want by forcing the RE as a whole to be greedy:
<screen>
SELECT regexp_match('abc01234xyz', '(?:(.*?)(\d+)(.*)){1,1}');
<lineannotation>Result: </lineannotation><computeroutput>{abc,01234,xyz}</computeroutput>
</screen>
    Controlling the RE's overall greediness separately from its components'
    greediness allows great flexibility in handling variable-length patterns.
   </para>
____________________________________________________________________________-->
   <para>
    量词<literal>{1,1}</literal>和<literal>{1,1}?</literal>可以分别用于在一个子表达式
    或者整个 RE 上强制贪婪或者非贪婪。当需要整个 RE 具有不同于从其元素中
    推导出的贪婪属性时，这很有用。例如，假设我们尝试将一个包含一些数字的
    字符串分隔成数字以及在它们之前和之后的部分，我们可能会尝试这样做：
<screen>
SELECT regexp_match('abc01234xyz', '(.*)(\d+)(.*)');
<lineannotation>Result: </lineannotation><computeroutput>{abc0123,4,xyz}</computeroutput>
</screen>
    这不会有用：第一个<literal>.*</literal>是贪婪的，因此它会<quote>吃掉</quote>
    尽可能多的字符而留下<literal>\d+</literal>去匹配在最后一个可能位置上的最
    后一个数字。我们可能会通过让它变成非贪婪来修复：
<screen>
SELECT regexp_match('abc01234xyz', '(.*?)(\d+)(.*)');
<lineannotation>Result: </lineannotation><computeroutput>{abc,0,""}</computeroutput>
</screen>
    这也不会有用：因为现在 RE 作为整体来说是非贪婪的，因此它会尽快结束
    全部的匹配。我们可以通过强制 RE 整体是贪婪的来得到我们想要的：
<screen>
SELECT regexp_match('abc01234xyz', '(?:(.*?)(\d+)(.*)){1,1}');
<lineannotation>Result: </lineannotation><computeroutput>{abc,01234,xyz}</computeroutput>
</screen>
    独立于 RE 的组件的贪婪性之外控制 RE 的整体贪婪性为处理变长模式提供了
    很大的灵活性。
   </para>

<!--==========================orignal english content==========================
   <para>
    When deciding what is a longer or shorter match,
    match lengths are measured in characters, not collating elements.
    An empty string is considered longer than no match at all.
    For example:
    <literal>bb*</literal>
    matches the three middle characters of <literal>abbbc</literal>;
    <literal>(week|wee)(night|knights)</literal>
    matches all ten characters of <literal>weeknights</literal>;
    when <literal>(.*).*</literal>
    is matched against <literal>abc</literal> the parenthesized subexpression
    matches all three characters; and when
    <literal>(a*)*</literal> is matched against <literal>bc</literal>
    both the whole RE and the parenthesized
    subexpression match an empty string.
   </para>
____________________________________________________________________________-->
   <para>
    在决定更长或者更短的匹配时，匹配长度是以字符衡量的，而不是排序元素。一个空串会被认为比什么都不匹配长。例如：<literal>bb*</literal>匹配<literal>abbbc</literal>的中间三个字符；<literal>(week|wee)(night|knights)</literal>匹配<literal>weeknights</literal>的所有十个字符； 而<literal>(.*).*</literal>匹配 <literal>abc</literal>的时候，圆括号包围的子表达式匹配所有三个字符；当<literal>(a*)*</literal>被拿来匹配<literal>bc</literal>时，整个 RE 和圆括号 子表达式都匹配一个空串。
   </para>

<!--==========================orignal english content==========================
   <para>
    If case-independent matching is specified,
    the effect is much as if all case distinctions had vanished from the
    alphabet.
    When an alphabetic that exists in multiple cases appears as an
    ordinary character outside a bracket expression, it is effectively
    transformed into a bracket expression containing both cases,
    e.g., <literal>x</literal> becomes <literal>[xX]</literal>.
    When it appears inside a bracket expression, all case counterparts
    of it are added to the bracket expression, e.g.,
    <literal>[x]</literal> becomes <literal>[xX]</literal>
    and <literal>[^x]</literal> becomes <literal>[^xX]</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    如果声明了大小写无关的匹配，那么效果就好像所有大小写区别在字母表中消失了。如果在多个情况中一个字母以一个普通字符的形式出现在方括号表达式外面，那么它实际上被转换成 一个包含大小写的方括号表达式，也就是说，x 变成 [xX]。 如果它出现在一个方括号表达式里面，那么它的所有大小写的同族都被加入 方括号表达式中，也就是说，<literal>x</literal>变成<literal>[xX]</literal>。当它出现在一个方括号表达式内时，它的所有大小写副本都被加入到方括号表达式中，例如， <literal>[x]</literal>会变成<literal>[xX]</literal>，而<literal>[^x]</literal>会变成<literal>[^xX]</literal>。
   </para>

<!--==========================orignal english content==========================
   <para>
    If newline-sensitive matching is specified, <literal>.</literal>
    and bracket expressions using <literal>^</literal>
    will never match the newline character
    (so that matches will never cross newlines unless the RE
    explicitly arranges it)
    and <literal>^</literal> and <literal>$</literal>
    will match the empty string after and before a newline
    respectively, in addition to matching at beginning and end of string
    respectively.
    But the ARE escapes <literal>\A</literal> and <literal>\Z</literal>
    continue to match beginning or end of string <emphasis>only</emphasis>.
   </para>
____________________________________________________________________________-->
   <para>
    如果指定了新行敏感的匹配，<literal>.</literal>和使用<literal>^</literal>的方括号表达式 将永远不会匹配新行字符（这样，匹配就绝对不会跨越新行，除非 RE 显式地安排了这样的情况）并且<literal>^</literal>和<literal>$</literal>除了分别匹配串开头和结尾之外，还将分别匹配新行后面和前面的空串。但是 ARE 逃逸<literal>\A</literal>和<literal>\Z</literal>仍然<emphasis>只</emphasis>匹配串的开头和结尾。
   </para>

<!--==========================orignal english content==========================
   <para>
    If partial newline-sensitive matching is specified,
    this affects <literal>.</literal> and bracket expressions
    as with newline-sensitive matching, but not <literal>^</literal>
    and <literal>$</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    如果指定了部分新行敏感的匹配，那么它影响<literal>.</literal>和方括号表达式， 这个时候和新行敏感的匹配一样，但是不影响<literal>^</literal>和<literal>$</literal>。
   </para>

<!--==========================orignal english content==========================
   <para>
    If inverse partial newline-sensitive matching is specified,
    this affects <literal>^</literal> and <literal>$</literal>
    as with newline-sensitive matching, but not <literal>.</literal>
    and bracket expressions.
    This isn't very useful but is provided for symmetry.
   </para>
____________________________________________________________________________-->
   <para>
    如果指定了逆新行敏感匹配，那么它影响<literal>^</literal>和<literal>$</literal>，其作用和在新行敏感的匹配里一样，但是不影响<literal>.</literal>和方括号表达式。这个并不是很有用，只是为了满足对称性而提供的。
   </para>
   </sect3>

   <sect3 id="posix-limits-compatibility">
<!--==========================orignal english content==========================
    <title>Limits and Compatibility</title>
____________________________________________________________________________-->
    <title>限制和兼容性</title>

<!--==========================orignal english content==========================
   <para>
    No particular limit is imposed on the length of REs in this
    implementation.  However,
    programs intended to be highly portable should not employ REs longer
    than 256 bytes,
    as a POSIX-compliant implementation can refuse to accept such REs.
   </para>
____________________________________________________________________________-->
   <para>
    在这个实现里，对 RE 的长度没有特别的限制。但是，那些希望高移植性的程序应该避免使用长度超过 256 字节的 RE，因为 POSIX 兼容 的实现可以拒绝接受这样的 RE。
   </para>

<!--==========================orignal english content==========================
   <para>
    The only feature of AREs that is actually incompatible with
    POSIX EREs is that <literal>\</literal> does not lose its special
    significance inside bracket expressions.
    All other ARE features use syntax which is illegal or has
    undefined or unspecified effects in POSIX EREs;
    the <literal>***</literal> syntax of directors likewise is outside the POSIX
    syntax for both BREs and EREs.
   </para>
____________________________________________________________________________-->
   <para>
    ARE 实际上和 POSIX ERE 不兼容的唯一的特性是在方括号表达式里<literal>\</literal>并不失去它特殊的含义。所有其它 ARE 特性都使用在 POSIX ERE 里面是非法或者是未定义、未声明效果的语法；指示器的<literal>***</literal>就是在 POSIX 的 BRE 和 ERE 之外的语法。
   </para>

<!--==========================orignal english content==========================
   <para>
    Many of the ARE extensions are borrowed from Perl, but some have
    been changed to clean them up, and a few Perl extensions are not present.
    Incompatibilities of note include <literal>\b</literal>, <literal>\B</literal>,
    the lack of special treatment for a trailing newline,
    the addition of complemented bracket expressions to the things
    affected by newline-sensitive matching,
    the restrictions on parentheses and back references in lookahead/lookbehind
    constraints, and the longest/shortest-match (rather than first-match)
    matching semantics.
   </para>
____________________________________________________________________________-->
   <para>
    许多 ARE 扩展都是从 Perl 那里借来的（但是有些被做了修改来清理它们），以及一些 Perl 里没有出现的扩展。要注意的不兼容性包括<literal>\b</literal>、<literal>\B</literal>、对结尾的新行缺乏特别的处理、对那些被新行敏感匹配的东西附加的补齐方括号表达式、在 lookahead/lookbehind 约束里对圆括号和后引用的限制以及最长/最短 匹配（而不是第一匹配）的语义。
   </para>

<!--==========================orignal english content==========================
   <para>
    Two significant incompatibilities exist between AREs and the ERE syntax
    recognized by pre-7.4 releases of <productname>PostgreSQL</productname>:

    <itemizedlist>
     <listitem>
      <para>
       In AREs, <literal>\</literal> followed by an alphanumeric character is either
       an escape or an error, while in previous releases, it was just another
       way of writing the alphanumeric.
       This should not be much of a problem because there was no reason to
       write such a sequence in earlier releases.
      </para>
     </listitem>
     <listitem>
      <para>
       In AREs, <literal>\</literal> remains a special character within
       <literal>[]</literal>, so a literal <literal>\</literal> within a bracket
       expression must be written <literal>\\</literal>.
      </para>
     </listitem>
    </itemizedlist>
   </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname> 7.4 之前的版本中识别的 ARE 和 ERE 语法存在两个非常明显的不兼容：

    <itemizedlist>
     <listitem>
      <para>
       在 ARE 中，后面跟着一个字母数字字符的<literal>\</literal>要么是一个逃逸要么是一个错误， 但是在以前的版本里，它只是写该字母数字字符的另外一种方法。这个应该不是什么问题， 因为在以前的版本里没有什么理由会让我们写这样的序列。
      </para>
     </listitem>
     <listitem>
      <para>
       在 ARE 里，<literal>\</literal>在<literal>[]</literal>里还是一个特殊字符， 因此在方括号表达式里的一个文本<literal>\</literal>必须被写成<literal>\\</literal>。
      </para>
     </listitem>
    </itemizedlist>
   </para>
   </sect3>

   <sect3 id="posix-basic-regexes">
<!--==========================orignal english content==========================
    <title>Basic Regular Expressions</title>
____________________________________________________________________________-->
    <title>基本正则表达式</title>

<!--==========================orignal english content==========================
   <para>
    BREs differ from EREs in several respects.
    In BREs, <literal>|</literal>, <literal>+</literal>, and <literal>?</literal>
    are ordinary characters and there is no equivalent
    for their functionality.
    The delimiters for bounds are
    <literal>\{</literal> and <literal>\}</literal>,
    with <literal>{</literal> and <literal>}</literal>
    by themselves ordinary characters.
    The parentheses for nested subexpressions are
    <literal>\(</literal> and <literal>\)</literal>,
    with <literal>(</literal> and <literal>)</literal> by themselves ordinary characters.
    <literal>^</literal> is an ordinary character except at the beginning of the
    RE or the beginning of a parenthesized subexpression,
    <literal>$</literal> is an ordinary character except at the end of the
    RE or the end of a parenthesized subexpression,
    and <literal>*</literal> is an ordinary character if it appears at the beginning
    of the RE or the beginning of a parenthesized subexpression
    (after a possible leading <literal>^</literal>).
    Finally, single-digit back references are available, and
    <literal>\&lt;</literal> and <literal>\&gt;</literal>
    are synonyms for
    <literal>[[:&lt;:]]</literal> and <literal>[[:&gt;:]]</literal>
    respectively; no other escapes are available in BREs.
   </para>
____________________________________________________________________________-->
   <para>
    BREs 在几个方面和 ERE 不太一样。在 BRE 中，<literal>|</literal>、<literal>+</literal>和<literal>?</literal>都是普通字符并且没有与它们功能等价的东西。范围的定界符是<literal>\{</literal>和<literal>\}</literal>， 因为 <literal>{</literal>和<literal>}</literal>本身是普通字符。嵌套的子表达式的圆括号是<literal>\(</literal>和<literal>\)</literal>，因为<literal>(</literal>和<literal>)</literal>自身是普通字符。除非在 RE 开头或者是圆括号子表达式开头，<literal>^</literal>都是一个普通字符。 除非在 RE 结尾或者是圆括号子表达式的结尾，<literal>$</literal>是一个普通字符。如果<literal>*</literal>出现在 RE 开头或者是圆括号封装的子表达式开头 （前面可能有<literal>^</literal>），那么它是个普通字符。最后，可以用单数字的后引用，<literal>\&lt;</literal>和<literal>\&gt;</literal>分别是<literal>[[:&lt;:]]</literal>和<literal>[[:&gt;:]]</literal>的同义词；在 BRE 中没有其它可用的逃逸。
   </para>
   </sect3>

<!-- end re_syntax.n man page -->

   <sect3 id="posix-vs-xquery">
<!--==========================orignal english content==========================
   <title>Differences from XQuery (<literal>LIKE_REGEX</literal>)</title>
____________________________________________________________________________-->
   <title>与XQuery的区别 (<literal>LIKE_REGEX</literal>)</title>

<!--==========================orignal english content==========================
   <indexterm zone="posix-vs-xquery">
    <primary><literal>LIKE_REGEX</literal></primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="posix-vs-xquery">
    <primary><literal>LIKE_REGEX</literal></primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="posix-vs-xquery">
    <primary>XQuery regular expressions</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="posix-vs-xquery">
    <primary>XQuery正则表达式</primary>
   </indexterm>

<!--==========================orignal english content==========================
    <para>
     Since SQL:2008, the SQL standard includes
     a <literal>LIKE_REGEX</literal> operator that performs pattern
     matching according to the XQuery regular expression
     standard.  <productname>PostgreSQL</productname> does not yet
     implement this operator, but you can get very similar behavior using
     the <function>regexp_match()</function> function, since XQuery
     regular expressions are quite close to the ARE syntax described above.
    </para>
____________________________________________________________________________-->
    <para>
     从SQL:2008开始，SQL标准中包含了一个<literal>LIKE_REGEX</literal>操作符，它根据XQuery正则表达式标准执行模式匹配。 <productname>PostgreSQL</productname>还没有实现这个操作符，但是你可以使用<function>regexp_match()</function>函数获得非常类似的行为，因为XQuery正则表达式非常接近于上面描述的ARE语法。
    </para>

<!--==========================orignal english content==========================
    <para>
     Notable differences between the existing POSIX-based
     regular-expression feature and XQuery regular expressions include:

     <itemizedlist>
      <listitem>
       <para>
        XQuery character class subtraction is not supported.  An example of
        this feature is using the following to match only English
        consonants: <literal>[a-z-[aeiou]]</literal>.
       </para>
      </listitem>
      <listitem>
       <para>
        XQuery character class shorthands <literal>\c</literal>,
        <literal>\C</literal>, <literal>\i</literal>,
        and <literal>\I</literal> are not supported.
       </para>
      </listitem>
      <listitem>
       <para>
        XQuery character class elements
        using <literal>\p{UnicodeProperty}</literal> or the
        inverse <literal>\P{UnicodeProperty}</literal> are not supported.
       </para>
      </listitem>
      <listitem>
       <para>
        POSIX interprets character classes such as <literal>\w</literal>
        (see <xref linkend="posix-class-shorthand-escapes-table"/>)
        according to the prevailing locale (which you can control by
        attaching a <literal>COLLATE</literal> clause to the operator or
        function).  XQuery specifies these classes by reference to Unicode
        character properties, so equivalent behavior is obtained only with
        a locale that follows the Unicode rules.
       </para>
      </listitem>
      <listitem>
       <para>
        The SQL standard (not XQuery itself) attempts to cater for more
        variants of <quote>newline</quote> than POSIX does.  The
        newline-sensitive matching options described above consider only
        ASCII NL (<literal>\n</literal>) to be a newline, but SQL would have
        us treat CR (<literal>\r</literal>), CRLF (<literal>\r\n</literal>)
        (a Windows-style newline), and some Unicode-only characters like
        LINE SEPARATOR (U+2028) as newlines as well.
        Notably, <literal>.</literal> and <literal>\s</literal> should
        count <literal>\r\n</literal> as one character not two according to
        SQL.
       </para>
      </listitem>
      <listitem>
       <para>
        Of the character-entry escapes described in
        <xref linkend="posix-character-entry-escapes-table"/>,
        XQuery supports only <literal>\n</literal>, <literal>\r</literal>,
        and <literal>\t</literal>.
       </para>
      </listitem>
      <listitem>
       <para>
        XQuery does not support
        the <literal>[:<replaceable>name</replaceable>:]</literal> syntax
        for character classes within bracket expressions.
       </para>
      </listitem>
      <listitem>
       <para>
        XQuery does not have lookahead or lookbehind constraints,
        nor any of the constraint escapes described in
        <xref linkend="posix-constraint-escapes-table"/>.
       </para>
      </listitem>
      <listitem>
       <para>
        The metasyntax forms described in <xref linkend="posix-metasyntax"/>
        do not exist in XQuery.
       </para>
      </listitem>
      <listitem>
       <para>
        The regular expression flag letters defined by XQuery are
        related to but not the same as the option letters for POSIX
        (<xref linkend="posix-embedded-options-table"/>).  While the
        <literal>i</literal> and <literal>q</literal> options behave the
        same, others do not:
        <itemizedlist>
         <listitem>
          <para>
           XQuery's <literal>s</literal> (allow dot to match newline)
           and <literal>m</literal> (allow <literal>^</literal>
           and <literal>$</literal> to match at newlines) flags provide
           access to the same behaviors as
           POSIX's <literal>n</literal>, <literal>p</literal>
           and <literal>w</literal> flags, but they
           do <emphasis>not</emphasis> match the behavior of
           POSIX's <literal>s</literal> and <literal>m</literal> flags.
           Note in particular that dot-matches-newline is the default
           behavior in POSIX but not XQuery.
          </para>
         </listitem>
         <listitem>
          <para>
           XQuery's <literal>x</literal> (ignore whitespace in pattern) flag
           is noticeably different from POSIX's expanded-mode flag.
           POSIX's <literal>x</literal> flag also
           allows <literal>#</literal> to begin a comment in the pattern,
           and POSIX will not ignore a whitespace character after a
           backslash.
          </para>
         </listitem>
        </itemizedlist>
       </para>
      </listitem>
     </itemizedlist>
    </para>
____________________________________________________________________________-->
    <para>
     与现有的基于POSIX的
正则表达式功能和XQuery正则表达式包括。

     <itemizedlist>
      <listitem>
       <para>
        不支持XQuery字符类减法。 这个功能的一个例子是使用下面的例子，只匹配英文辅音。<literal>[a-z-[aeiou]]</literal>。
       </para>
      </listitem>
      <listitem>
       <para>
        XQuery字符类速记<literal>c</literal>。
不支持<literal>C</literal>、<literal>i</literal>和<literal>I</literal>。
       </para>
      </listitem>
      <listitem>
       <para>
        不支持使用<literal>p{UnicodeProperty}</literal>或反过来的<literal>P{UnicodeProperty}</literal>的XQuery字符类元素。
       </para>
      </listitem>
      <listitem>
       <para>
        POSIX根据当前的locale来解释字符类，如<literal>/w</literal> (见<xref linkend="posix-class-shorthand-escapes-table"/>)(你可以通过在操作符或函数中附加一个<literal>COLLATE</literal>子句来控制)。 XQuery通过引用Unicode字符属性来指定这些类，因此只有遵循Unicode规则的locale才能获得等效的行为。
       </para>
      </listitem>
      <listitem>
       <para>
        SQL标准（而不是XQuery本身）试图满足更多的需求。<quote>newline的变体</quote>比POSIX的变体。 上面描述的对新行敏感的匹配选项只考虑ASCII NL (<literal>n</literal>)是新行，但SQL会让我们把CR (<literal>r</literal>)、CRLF (<literal>r/n</literal>)(Windows风格的新行)，以及一些Unicode唯一的字符，如LINE SEPARATOR (U+2028)也视为新行。值得注意的是，<literal>.</literal>和<literal>s</literal>应该算作一个字符，而不是按照SQL的规定算作两个字符。
       </para>
      </listitem>
      <listitem>
       <para>
        在<xref linkend="posix-character-entry-escapes-table"/>中描述的字符输入转义中，XQuery只支持<literal>n</literal>、<literal>r</literal>和<literal>t</literal>。
       </para>
      </listitem>
      <listitem>
       <para>
        XQuery不支持<literal>[::<replaceable>name</replaceable>:]]</literal>语法，不支持括号表达式中的字符类。
       </para>
      </listitem>
      <listitem>
       <para>
        XQuery没有 lookahead 或 lookbehind 约束，也没有任何在
        <xref linkend="posix-constraint-escapes-table"/>.
       </para>
      </listitem>
      <listitem>
       <para>
        <xref linkend="posix-metasyntax"/>中描述的metasyntax形式在XQuery中不存在。
       </para>
      </listitem>
      <listitem>
       <para>
        由XQuery定义的正则表达式标志字母与POSIX的选项字母相关，但不一样。
 <xref linkend="posix-embedded-options-table"/>）。 虽然<literal>i</literal>和<literal>q</literal>选项的行为是一样的，但其他的选项却不一样。
        <itemizedlist>
         <listitem>
          <para>
           XQuery的<literal>s</literal>（允许点匹配换行）和<literal>m</literal>（允许<literal>^</literal>和<literal>$</literal>在换行处匹配）标志提供了与POSIX的<literal>n</literal>相同的行为。<literal>p</literal>和<literal>w</literal>标志，但它们与POSIX的<literal>s</literal>和<literal>m</literal>标志的行为不匹配。特别要注意的是，点匹配-newline是POSIX中的默认行为，但不是XQuery。
          </para>
         </listitem>
         <listitem>
          <para>
           XQuery的<literal>x</literal>（忽略模式中的空格）标志与POSIX的扩展模式标志明显不同。 POSIX的<literal>x</literal>标志也允许<literal>#</literal>在模式中开始注释，并且POSIX不会忽略反斜线后的空格字符。
          </para>
         </listitem>
        </itemizedlist>
       </para>
      </listitem>
     </itemizedlist>
    </para>

   </sect3>
  </sect2>
 </sect1>


  <sect1 id="functions-formatting">
<!--==========================orignal english content==========================
   <title>Data Type Formatting Functions</title>
____________________________________________________________________________-->
   <title>数据类型格式化函数</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>formatting</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>formatting</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    The <productname>PostgreSQL</productname> formatting functions
    provide a powerful set of tools for converting various data types
    (date/time, integer, floating point, numeric) to formatted strings
    and for converting from formatted strings to specific data types.
    <xref linkend="functions-formatting-table"/> lists them.
    These functions all follow a common calling convention: the first
    argument is the value to be formatted and the second argument is a
    template that defines the output or input format.
   </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>格式化函数提供一套强大的工具用于把各种数据类型 （日期/时间、整数、浮点、数字） 转换成格式化的字符串以及反过来从格式化的字符串转换成 指定的数据类型。<xref linkend="functions-formatting-table"/>列出了这些函数。这些函数都遵循一个公共的调用规范： 第一个参数是待格式化的值，而第二个是一个定义输出或输入格式的模板。
   </para>

   <table id="functions-formatting-table">
<!--==========================orignal english content==========================
    <title>Formatting Functions</title>
____________________________________________________________________________-->
    <title>格式化函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_char</primary>
        </indexterm>
        <function>to_char</function> ( <type>timestamp</type>, <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>to_char</function> ( <type>timestamp with time zone</type>, <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts time stamp to string according to the given format.
       </para>
       <para>
        <literal>to_char(timestamp '2002-04-20 17:31:12.66', 'HH12:MI:SS')</literal>
        <returnvalue>05:31:12</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_char</primary>
        </indexterm>
        <function>to_char</function> ( <type>timestamp</type>, <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>to_char</function> ( <type>timestamp with time zone</type>, <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        根据给定的格式将时间戳转换为字符串。
       </para>
       <para>
        <literal>to_char(timestamp '2002-04-20 17:31:12.66', 'HH12:MI:SS')</literal>
        <returnvalue>05:31:12</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>to_char</function> ( <type>interval</type>, <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts interval to string according to the given format.
       </para>
       <para>
       <literal>to_char(interval '15h 2m 12s', 'HH24:MI:SS')</literal>
       <returnvalue>15:02:12</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>to_char</function> ( <type>interval</type>, <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        根据给定的格式将间隔转换为字符串。
       </para>
       <para>
       <literal>to_char(interval '15h 2m 12s', 'HH24:MI:SS')</literal>
       <returnvalue>15:02:12</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>to_char</function> ( <replaceable>numeric_type</replaceable>, <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts number to string according to the given format; available
        for <type>integer</type>, <type>bigint</type>, <type>numeric</type>,
        <type>real</type>, <type>double precision</type>.
       </para>
       <para>
        <literal>to_char(125, '999')</literal>
        <returnvalue>125</returnvalue>
       </para>
       <para>
        <literal>to_char(125.8::real, '999D9')</literal>
        <returnvalue>125.8</returnvalue>
       </para>
       <para>
        <literal>to_char(-125.8, '999D99S')</literal>
        <returnvalue>125.80-</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>to_char</function> ( <replaceable>numeric_type</replaceable>, <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        根据给定的格式将数字转换为字符串；适用于 <type>integer</type>， <type>bigint</type>， <type>numeric</type>，<type>real</type>， <type>double precision</type>。
       </para>
       <para>
        <literal>to_char(125, '999')</literal>
        <returnvalue>125</returnvalue>
       </para>
       <para>
        <literal>to_char(125.8::real, '999D9')</literal>
        <returnvalue>125.8</returnvalue>
       </para>
       <para>
        <literal>to_char(-125.8, '999D99S')</literal>
        <returnvalue>125.80-</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_date</primary>
        </indexterm>
        <function>to_date</function> ( <type>text</type>, <type>text</type> )
        <returnvalue>date</returnvalue>
       </para>
       <para>
        Converts string to date according to the given format.
       </para>
       <para>
        <literal>to_date('05 Dec 2000', 'DD Mon YYYY')</literal>
        <returnvalue>2000-12-05</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_date</primary>
        </indexterm>
        <function>to_date</function> ( <type>text</type>, <type>text</type> )
        <returnvalue>date</returnvalue>
       </para>
       <para>
        根据给定的格式将字符串转换为日期。
       </para>
       <para>
        <literal>to_date('05 Dec 2000', 'DD Mon YYYY')</literal>
        <returnvalue>2000-12-05</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_number</primary>
        </indexterm>
        <function>to_number</function> ( <type>text</type>, <type>text</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        Converts string to numeric according to the given format.
       </para>
       <para>
        <literal>to_number('12,454.8-', '99G999D9S')</literal>
        <returnvalue>-12454.8</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_number</primary>
        </indexterm>
        <function>to_number</function> ( <type>text</type>, <type>text</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        根据给定的格式将字符串转换为数字。
       </para>
       <para>
        <literal>to_number('12,454.8-', '99G999D9S')</literal>
        <returnvalue>-12454.8</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_timestamp</primary>
        </indexterm>
        <function>to_timestamp</function> ( <type>text</type>, <type>text</type> )
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
        Converts string to time stamp according to the given format.
        (See also <function>to_timestamp(double precision)</function> in
        <xref linkend="functions-datetime-table"/>.)
       </para>
       <para>
        <literal>to_timestamp('05 Dec 2000', 'DD Mon YYYY')</literal>
        <returnvalue>2000-12-05 00:00:00-05</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_timestamp</primary>
        </indexterm>
        <function>to_timestamp</function> ( <type>text</type>, <type>text</type> )
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
        根据给定的格式将字符串转换为时间戳。
        （也请参见<xref linkend="functions-datetime-table"/>中的<function>to_timestamp(double precision)</function> 。）
       </para>
       <para>
        <literal>to_timestamp('05 Dec 2000', 'DD Mon YYYY')</literal>
        <returnvalue>2000-12-05 00:00:00-05</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <tip>
<!--==========================orignal english content==========================
    <para>
     <function>to_timestamp</function> and <function>to_date</function>
     exist to handle input formats that cannot be converted by
     simple casting.  For most standard date/time formats, simply casting the
     source string to the required data type works, and is much easier.
     Similarly, <function>to_number</function> is unnecessary for standard numeric
     representations.
    </para>
____________________________________________________________________________-->
    <para>
     <function>to_timestamp</function>和<function>to_date</function>存在的目的是为了处理无法用简单造型转换的输入格式。对于大部分标准的日期/时间格式，简单地把源字符串造型成所需的数据类型是可以的，并且简单很多。类似地，对于标准的数字表示形式，<function>to_number</function>也是没有必要的。
    </para>
   </tip>

<!--==========================orignal english content==========================
   <para>
    In a <function>to_char</function> output template string, there are certain
    patterns that are recognized and replaced with appropriately-formatted
    data based on the given value.  Any text that is not a template pattern is
    simply copied verbatim.  Similarly, in an input template string (for the
    other functions), template patterns identify the values to be supplied by
    the input data string.  If there are characters in the template string
    that are not template patterns, the corresponding characters in the input
    data string are simply skipped over (whether or not they are equal to the
    template string characters).
   </para>
____________________________________________________________________________-->
   <para>
    在一个<function>to_char</function>输出模板串中，一些特定的模式可以被识别并且被替换成基于给定值的被恰当地格式化的数据。任何不属于模板模式的文本都简单地照字面拷贝。同样，在一个输入 模板串里（对其他函数），模板模式标识由输入数据串提供的值。如果在模板字符串中有不是模板模式的字符，输入数据字符串中的对应字符会被简单地跳过（不管它们是否等于模板字符串字符）。
   </para>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="functions-formatting-datetime-table"/> shows the
   template patterns available for formatting date and time values.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="functions-formatting-datetime-table"/>展示了可以用于格式化日期和时间值的模版。
  </para>

    <table id="functions-formatting-datetime-table">
<!--==========================orignal english content==========================
     <title>Template Patterns for Date/Time Formatting</title>
____________________________________________________________________________-->
     <title>用于日期/时间格式化的模板模式</title>
     <tgroup cols="2">
      <thead>
<!--==========================orignal english content==========================
       <row>
        <entry>Pattern</entry>
        <entry>Description</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>模式</entry>
        <entry>描述</entry>
       </row>
      </thead>
      <tbody>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>HH</literal></entry>
        <entry>hour of day (01&ndash;12)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>HH</literal></entry>
        <entry>一天中的小时(01&ndash;12)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>HH12</literal></entry>
        <entry>hour of day (01&ndash;12)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>HH12</literal></entry>
        <entry>一天中的小时(01&ndash;12)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>HH24</literal></entry>
        <entry>hour of day (00&ndash;23)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>HH24</literal></entry>
        <entry>一天中的小时 (00&ndash;23)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>MI</literal></entry>
        <entry>minute (00&ndash;59)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>MI</literal></entry>
        <entry>分钟 (00&ndash;59)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>SS</literal></entry>
        <entry>second (00&ndash;59)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>SS</literal></entry>
        <entry>秒 (00&ndash;59)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>MS</literal></entry>
        <entry>millisecond (000&ndash;999)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>MS</literal></entry>
        <entry>毫秒 (000&ndash;999)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>US</literal></entry>
        <entry>microsecond (000000&ndash;999999)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>US</literal></entry>
        <entry>微秒 (000000&ndash;999999)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>FF1</literal></entry>
        <entry>tenth of second (0&ndash;9)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>FF1</literal></entry>
        <entry>十分之一秒 (0&ndash;9)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>FF2</literal></entry>
        <entry>hundredth of second (00&ndash;99)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>FF2</literal></entry>
        <entry>百分之一秒 (00&ndash;99)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>FF3</literal></entry>
        <entry>millisecond (000&ndash;999)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>FF3</literal></entry>
        <entry>毫秒 (000&ndash;999)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>FF4</literal></entry>
        <entry>tenth of a millisecond (0000&ndash;9999)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>FF4</literal></entry>
        <entry>十分之一毫秒 (0000&ndash;9999)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>FF5</literal></entry>
        <entry>hundredth of a millisecond (00000&ndash;99999)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>FF5</literal></entry>
        <entry>百分之一毫秒 (00000&ndash;99999)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>FF6</literal></entry>
        <entry>microsecond (000000&ndash;999999)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>FF6</literal></entry>
        <entry>微秒 (000000&ndash;999999)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>SSSS</literal>, <literal>SSSSS</literal></entry>
        <entry>seconds past midnight (0&ndash;86399)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>SSSS</literal>, <literal>SSSSS</literal></entry>
        <entry>午夜后的秒 (0&ndash;86399)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>AM</literal>, <literal>am</literal>,
        <literal>PM</literal> or <literal>pm</literal></entry>
        <entry>meridiem indicator (without periods)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>AM</literal>, <literal>am</literal>,
        <literal>PM</literal> or <literal>pm</literal></entry>
        <entry>正午指示器（不带句号）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>A.M.</literal>, <literal>a.m.</literal>,
        <literal>P.M.</literal> or <literal>p.m.</literal></entry>
        <entry>meridiem indicator (with periods)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>A.M.</literal>, <literal>a.m.</literal>,
        <literal>P.M.</literal> or <literal>p.m.</literal></entry>
        <entry>正午指示器（带句号）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>Y,YYY</literal></entry>
        <entry>year (4 or more digits) with comma</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>Y,YYY</literal></entry>
        <entry>带逗号的年（4 位或者更多位） with comma</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>YYYY</literal></entry>
        <entry>year (4 or more digits)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>YYYY</literal></entry>
        <entry>年（4 位或者更多位）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>YYY</literal></entry>
        <entry>last 3 digits of year</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>YYY</literal></entry>
        <entry>年的最后 3 位数字</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>YY</literal></entry>
        <entry>last 2 digits of year</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>YY</literal></entry>
        <entry>年的最后 2 位数字</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>Y</literal></entry>
        <entry>last digit of year</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>Y</literal></entry>
        <entry>年的最后 1 位数字</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>IYYY</literal></entry>
        <entry>ISO 8601 week-numbering year (4 or more digits)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>IYYY</literal></entry>
        <entry>ISO 8601 周编号方式的年（4 位或更多位）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>IYY</literal></entry>
        <entry>last 3 digits of ISO 8601 week-numbering year</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>IYY</literal></entry>
        <entry>ISO 8601 周编号方式的年的最后 3 位数字</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>IY</literal></entry>
        <entry>last 2 digits of ISO 8601 week-numbering year</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>IY</literal></entry>
        <entry>ISO 8601 周编号方式的年的最后 2 位数字</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>I</literal></entry>
        <entry>last digit of ISO 8601 week-numbering year</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>I</literal></entry>
        <entry>ISO 8601 周编号方式的年的最后 1 位数字</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>BC</literal>, <literal>bc</literal>,
        <literal>AD</literal> or <literal>ad</literal></entry>
        <entry>era indicator (without periods)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>BC</literal>, <literal>bc</literal>,
        <literal>AD</literal> 或 <literal>ad</literal></entry>
        <entry>纪元指示器（不带句号）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>B.C.</literal>, <literal>b.c.</literal>,
        <literal>A.D.</literal> or <literal>a.d.</literal></entry>
        <entry>era indicator (with periods)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>B.C.</literal>, <literal>b.c.</literal>,
        <literal>A.D.</literal> 或 <literal>a.d.</literal></entry>
        <entry>纪元指示器（带句号）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>MONTH</literal></entry>
        <entry>full upper case month name (blank-padded to 9 chars)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>MONTH</literal></entry>
        <entry>全大写形式的月名（空格补齐到 9 字符）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>Month</literal></entry>
        <entry>full capitalized month name (blank-padded to 9 chars)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>Month</literal></entry>
        <entry>全首字母大写形式的月名（空格补齐到 9 字符）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>month</literal></entry>
        <entry>full lower case month name (blank-padded to 9 chars)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>month</literal></entry>
        <entry>全小写形式的月名（空格补齐到 9 字符）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>MON</literal></entry>
        <entry>abbreviated upper case month name (3 chars in English, localized lengths vary)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>MON</literal></entry>
        <entry>简写的大写形式的月名（英文 3 字符，本地化长度可变）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>Mon</literal></entry>
        <entry>abbreviated capitalized month name (3 chars in English, localized lengths vary)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>Mon</literal></entry>
        <entry>简写的首字母大写形式的月名（英文 3 字符，本地化长度可变）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>mon</literal></entry>
        <entry>abbreviated lower case month name (3 chars in English, localized lengths vary)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>mon</literal></entry>
        <entry>简写的小写形式的月名（英文 3 字符，本地化长度可变）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>MM</literal></entry>
        <entry>month number (01&ndash;12)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>MM</literal></entry>
        <entry>月编号 (01&ndash;12)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>DAY</literal></entry>
        <entry>full upper case day name (blank-padded to 9 chars)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>DAY</literal></entry>
        <entry>全大写形式的日名（空格补齐到 9 字符）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>Day</literal></entry>
        <entry>full capitalized day name (blank-padded to 9 chars)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>Day</literal></entry>
        <entry>全首字母大写形式的日名（空格补齐到 9 字符）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>day</literal></entry>
        <entry>full lower case day name (blank-padded to 9 chars)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>day</literal></entry>
        <entry>全小写形式的日名（空格补齐到 9 字符）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>DY</literal></entry>
        <entry>abbreviated upper case day name (3 chars in English, localized lengths vary)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>DY</literal></entry>
        <entry>简写的大写形式的日名（英语 3 字符，本地化长度可变）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>Dy</literal></entry>
        <entry>abbreviated capitalized day name (3 chars in English, localized lengths vary)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>Dy</literal></entry>
        <entry>简写的首字母大写形式的日名（英语 3 字符，本地化长度可变）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>dy</literal></entry>
        <entry>abbreviated lower case day name (3 chars in English, localized lengths vary)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>dy</literal></entry>
        <entry>简写的小写形式的日名（英语 3 字符，本地化长度可变）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>DDD</literal></entry>
        <entry>day of year (001&ndash;366)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>DDD</literal></entry>
        <entry>一年中的日(001&ndash;366)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>IDDD</literal></entry>
        <entry>day of ISO 8601 week-numbering year (001&ndash;371; day 1 of the year is Monday of the first ISO week)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>IDDD</literal></entry>
        <entry>ISO 8601 周编号方式的年中的日 （001&ndash;371; 年的第 1 日时第一个 ISO 周的周一）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>DD</literal></entry>
        <entry>day of month (01&ndash;31)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>DD</literal></entry>
        <entry>月中的日 (01&ndash;31)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>D</literal></entry>
        <entry>day of the week, Sunday (<literal>1</literal>) to Saturday (<literal>7</literal>)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>D</literal></entry>
        <entry>周中的日，周日 (<literal>1</literal>) 到周六 (<literal>7</literal>)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>ID</literal></entry>
        <entry>ISO 8601 day of the week, Monday (<literal>1</literal>) to Sunday (<literal>7</literal>)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>ID</literal></entry>
        <entry>周中的 ISO 8601 日，周一 (<literal>1</literal>) 到周日 (<literal>7</literal>)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>W</literal></entry>
        <entry>week of month (1&ndash;5) (the first week starts on the first day of the month)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>W</literal></entry>
        <entry>月中的周 (1&ndash;5) （第一周从该月的第一天开始）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>WW</literal></entry>
        <entry>week number of year (1&ndash;53) (the first week starts on the first day of the year)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>WW</literal></entry>
        <entry>年中的周数 (1&ndash;53) （第一周从该年的第一天开始）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>IW</literal></entry>
        <entry>week number of ISO 8601 week-numbering year (01&ndash;53; the first Thursday of the year is in week 1)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>IW</literal></entry>
        <entry>ISO 8601 周编号方式的年中的周数 (01&ndash;53; 新的一年的第一个周四在第一周)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>CC</literal></entry>
        <entry>century (2 digits) (the twenty-first century starts on 2001-01-01)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>CC</literal></entry>
        <entry>世纪（2 位数）（21 世纪开始于 2001-01-01）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>J</literal></entry>
        <entry>Julian Day (integer days since November 24, 4714 BC at midnight UTC)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>J</literal></entry>
        <entry>儒略日（从午夜 UTC 的公元前 4714 年 11 月 24 日开始的整数日数）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>Q</literal></entry>
        <entry>quarter</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>Q</literal></entry>
        <entry>季度</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>RM</literal></entry>
        <entry>month in upper case Roman numerals (I&ndash;XII; I=January)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>RM</literal></entry>
        <entry>大写形式的罗马计数法的月 (I&ndash;XII; I=一月)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>rm</literal></entry>
        <entry>month in lower case Roman numerals (i&ndash;xii; i=January)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>rm</literal></entry>
        <entry>小写形式的罗马计数法的月 (i&ndash;xii; i=一月)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>TZ</literal></entry>
        <entry>upper case time-zone abbreviation
         (only supported in <function>to_char</function>)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>TZ</literal></entry>
        <entry>大写形式的时区缩写（仅在<function>to_char</function>中支持）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>tz</literal></entry>
        <entry>lower case time-zone abbreviation
         (only supported in <function>to_char</function>)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>tz</literal></entry>
        <entry>小写形式的时区缩写（仅在<function>to_char</function>中支持）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
       <entry><literal>TZH</literal></entry>
        <entry>time-zone hours</entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry><literal>TZH</literal></entry>
        <entry>时区的小时</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
       <entry><literal>TZM</literal></entry>
        <entry>time-zone minutes</entry>
       </row>
____________________________________________________________________________-->
       <row>
       <entry><literal>TZM</literal></entry>
        <entry>时区的分钟</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>OF</literal></entry>
        <entry>time-zone offset from UTC
         (only supported in <function>to_char</function>)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>OF</literal></entry>
        <entry>从UTC开始的时区偏移（仅在<function>to_char</function>中支持）</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

<!--==========================orignal english content==========================
   <para>
    Modifiers can be applied to any template pattern to alter its
    behavior.  For example, <literal>FMMonth</literal>
    is the <literal>Month</literal> pattern with the
    <literal>FM</literal> modifier.
    <xref linkend="functions-formatting-datetimemod-table"/> shows the
    modifier patterns for date/time formatting.
   </para>
____________________________________________________________________________-->
   <para>
    修饰语可以被应用于模板模式来修改它们的行为。例如，<literal>FMMonth</literal>就是带着<literal>FM</literal>修饰语的<literal>Month</literal>模式。<xref linkend="functions-formatting-datetimemod-table"/>展示了可用于日期/时间格式化的修饰语模式。
   </para>

    <table id="functions-formatting-datetimemod-table">
<!--==========================orignal english content==========================
     <title>Template Pattern Modifiers for Date/Time Formatting</title>
____________________________________________________________________________-->
     <title>用于日期/时间格式化的模板模式修饰语</title>
     <tgroup cols="3">
      <thead>
<!--==========================orignal english content==========================
       <row>
        <entry>Modifier</entry>
        <entry>Description</entry>
        <entry>Example</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>修饰语</entry>
        <entry>描述</entry>
        <entry>例子</entry>
       </row>
      </thead>
      <tbody>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>FM</literal> prefix</entry>
        <entry>fill mode (suppress leading zeroes and padding blanks)</entry>
        <entry><literal>FMMonth</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>FM</literal> prefix</entry>
        <entry>填充模式（抑制前导零和填充的空格）</entry>
        <entry><literal>FMMonth</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>TH</literal> suffix</entry>
        <entry>upper case ordinal number suffix</entry>
        <entry><literal>DDTH</literal>, e.g., <literal>12TH</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>TH</literal> suffix</entry>
        <entry>大写形式的序数后缀</entry>
        <entry><literal>DDTH</literal>, e.g., <literal>12TH</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>th</literal> suffix</entry>
        <entry>lower case ordinal number suffix</entry>
        <entry><literal>DDth</literal>, e.g., <literal>12th</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>th</literal> suffix</entry>
        <entry>小写形式的序数后缀</entry>
        <entry><literal>DDth</literal>, e.g., <literal>12th</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>FX</literal> prefix</entry>
        <entry>fixed format global option (see usage notes)</entry>
        <entry><literal>FX&nbsp;Month&nbsp;DD&nbsp;Day</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>FX</literal> prefix</entry>
        <entry>固定的格式化全局选项（见使用须知）</entry>
        <entry><literal>FX&nbsp;Month&nbsp;DD&nbsp;Day</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>TM</literal> prefix</entry>
        <entry>translation mode (use localized day and month names based on
         <xref linkend="guc-lc-time"/>)</entry>
        <entry><literal>TMMonth</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>TM</literal> prefix</entry>
        <entry>翻译模式（基于<xref linkend="guc-lc-time"/>使用本地化的日和月名）</entry>
        <entry><literal>TMMonth</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>SP</literal> suffix</entry>
        <entry>spell mode (not implemented)</entry>
        <entry><literal>DDSP</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>SP</literal> suffix</entry>
        <entry>拼写模式（未实现）</entry>
        <entry><literal>DDSP</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

<!--==========================orignal english content==========================
   <para>
    Usage notes for date/time formatting:

    <itemizedlist>
     <listitem>
      <para>
       <literal>FM</literal> suppresses leading zeroes and trailing blanks
       that would otherwise be added to make the output of a pattern be
       fixed-width.  In <productname>PostgreSQL</productname>,
       <literal>FM</literal> modifies only the next specification, while in
       Oracle <literal>FM</literal> affects all subsequent
       specifications, and repeated <literal>FM</literal> modifiers
       toggle fill mode on and off.
      </para>
     </listitem>

     <listitem>
      <para>
       <literal>TM</literal> suppresses trailing blanks whether or
       not <literal>FM</literal> is specified.
      </para>
     </listitem>

     <listitem>
      <para>
       <function>to_timestamp</function> and <function>to_date</function>
       ignore letter case in the input; so for
       example <literal>MON</literal>, <literal>Mon</literal>,
       and <literal>mon</literal> all accept the same strings.  When using
       the <literal>TM</literal> modifier, case-folding is done according to
       the rules of the function's input collation (see
       <xref linkend="collation"/>).
      </para>
     </listitem>

     <listitem>
      <para>
       <function>to_timestamp</function> and <function>to_date</function>
       skip multiple blank spaces at the beginning of the input string and
       around date and time values unless the <literal>FX</literal> option is used.  For example,
       <literal>to_timestamp('&nbsp;2000&nbsp;&nbsp;&nbsp;&nbsp;JUN', 'YYYY MON')</literal> and
       <literal>to_timestamp('2000 - JUN', 'YYYY-MON')</literal> work, but
       <literal>to_timestamp('2000&nbsp;&nbsp;&nbsp;&nbsp;JUN', 'FXYYYY MON')</literal> returns an error
       because <function>to_timestamp</function> expects only a single space.
       <literal>FX</literal> must be specified as the first item in
       the template.
      </para>
     </listitem>

     <listitem>
      <para>
       A separator (a space or non-letter/non-digit character) in the template string of
       <function>to_timestamp</function> and <function>to_date</function>
       matches any single separator in the input string or is skipped,
       unless the <literal>FX</literal> option is used.
       For example, <literal>to_timestamp('2000JUN', 'YYYY///MON')</literal> and
       <literal>to_timestamp('2000/JUN', 'YYYY MON')</literal> work, but
       <literal>to_timestamp('2000//JUN', 'YYYY/MON')</literal>
       returns an error because the number of separators in the input string
       exceeds the number of separators in the template.
      </para>
      <para>
       If <literal>FX</literal> is specified, a separator in the template string
       matches exactly one character in the input string.  But note that the
       input string character is not required to be the same as the separator from the template string.
       For example, <literal>to_timestamp('2000/JUN', 'FXYYYY MON')</literal>
       works, but <literal>to_timestamp('2000/JUN', 'FXYYYY&nbsp;&nbsp;MON')</literal>
       returns an error because the second space in the template string consumes
       the letter <literal>J</literal> from the input string.
      </para>
     </listitem>

     <listitem>
      <para>
       A <literal>TZH</literal> template pattern can match a signed number.
       Without the <literal>FX</literal> option, minus signs may be ambiguous,
       and could be interpreted as a separator.
       This ambiguity is resolved as follows:  If the number of separators before
       <literal>TZH</literal> in the template string is less than the number of
       separators before the minus sign in the input string, the minus sign
       is interpreted as part of <literal>TZH</literal>.
       Otherwise, the minus sign is considered to be a separator between values.
       For example, <literal>to_timestamp('2000 -10', 'YYYY TZH')</literal> matches
       <literal>-10</literal> to <literal>TZH</literal>, but
       <literal>to_timestamp('2000 -10', 'YYYY&nbsp;&nbsp;TZH')</literal>
       matches <literal>10</literal> to <literal>TZH</literal>.
      </para>
     </listitem>

     <listitem>
      <para>
       Ordinary text is allowed in <function>to_char</function>
       templates and will be output literally.  You can put a substring
       in double quotes to force it to be interpreted as literal text
       even if it contains template patterns.  For example, in
       <literal>'"Hello Year "YYYY'</literal>, the <literal>YYYY</literal>
       will be replaced by the year data, but the single <literal>Y</literal> in <literal>Year</literal>
       will not be.
       In <function>to_date</function>, <function>to_number</function>,
       and <function>to_timestamp</function>, literal text and double-quoted
       strings result in skipping the number of characters contained in the
       string; for example <literal>"XX"</literal> skips two input characters
       (whether or not they are <literal>XX</literal>).
      </para>
      <tip>
        <para>
          Prior to <productname>PostgreSQL</productname> 12, it was possible to
          skip arbitrary text in the input string using non-letter or non-digit
          characters. For example,
          <literal>to_timestamp('2000y6m1d', 'yyyy-MM-DD')</literal> used to
          work.  Now you can only use letter characters for this purpose.  For example,
          <literal>to_timestamp('2000y6m1d', 'yyyytMMtDDt')</literal> and
          <literal>to_timestamp('2000y6m1d', 'yyyy"y"MM"m"DD"d"')</literal>
          skip <literal>y</literal>, <literal>m</literal>, and
          <literal>d</literal>.
        </para>
      </tip>
     </listitem>

     <listitem>
      <para>
       If you want to have a double quote in the output you must
       precede it with a backslash, for example <literal>'\"YYYY
       Month\"'</literal>. <!-&minus; "" font-lock sanity :-) -&minus;>
       Backslashes are not otherwise special outside of double-quoted
       strings.  Within a double-quoted string, a backslash causes the
       next character to be taken literally, whatever it is (but this
       has no special effect unless the next character is a double quote
       or another backslash).
      </para>
     </listitem>

     <listitem>
      <para>
       In <function>to_timestamp</function> and <function>to_date</function>,
       if the year format specification is less than four digits, e.g.,
       <literal>YYY</literal>, and the supplied year is less than four digits,
       the year will be adjusted to be nearest to the year 2020, e.g.,
       <literal>95</literal> becomes 1995.
      </para>
     </listitem>

     <listitem>
      <para>
       In <function>to_timestamp</function> and <function>to_date</function>,
       negative years are treated as signifying BC.  If you write both a
       negative year and an explicit <literal>BC</literal> field, you get AD
       again.  An input of year zero is treated as 1 BC.
      </para>
     </listitem>

     <listitem>
      <para>
       In <function>to_timestamp</function> and <function>to_date</function>,
       the <literal>YYYY</literal> conversion has a restriction when
       processing years with more than 4 digits. You must
       use some non-digit character or template after <literal>YYYY</literal>,
       otherwise the year is always interpreted as 4 digits. For example
       (with the year 20000):
       <literal>to_date('200001131', 'YYYYMMDD')</literal> will be
       interpreted as a 4-digit year; instead use a non-digit
       separator after the year, like
       <literal>to_date('20000-1131', 'YYYY-MMDD')</literal> or
       <literal>to_date('20000Nov31', 'YYYYMonDD')</literal>.
      </para>
     </listitem>

     <listitem>
      <para>
       In <function>to_timestamp</function> and <function>to_date</function>,
       the <literal>CC</literal> (century) field is accepted but ignored
       if there is a <literal>YYY</literal>, <literal>YYYY</literal> or
       <literal>Y,YYY</literal> field. If <literal>CC</literal> is used with
       <literal>YY</literal> or <literal>Y</literal> then the result is
       computed as that year in the specified century.  If the century is
       specified but the year is not, the first year of the century
       is assumed.
      </para>
     </listitem>

     <listitem>
      <para>
       In <function>to_timestamp</function> and <function>to_date</function>,
       weekday names or numbers (<literal>DAY</literal>, <literal>D</literal>,
       and related field types) are accepted but are ignored for purposes of
       computing the result.  The same is true for quarter
       (<literal>Q</literal>) fields.
      </para>
     </listitem>

     <listitem>
      <para>
       In <function>to_timestamp</function> and <function>to_date</function>,
       an ISO 8601 week-numbering date (as distinct from a Gregorian date)
       can be specified in one of two ways:
       <itemizedlist>
        <listitem>
         <para>
          Year, week number, and weekday:  for
          example <literal>to_date('2006-42-4', 'IYYY-IW-ID')</literal>
          returns the date <literal>2006-10-19</literal>.
          If you omit the weekday it is assumed to be 1 (Monday).
         </para>
        </listitem>
        <listitem>
         <para>
          Year and day of year:  for example <literal>to_date('2006-291',
          'IYYY-IDDD')</literal> also returns <literal>2006-10-19</literal>.
         </para>
        </listitem>
       </itemizedlist>
      </para>
      <para>
       Attempting to enter a date using a mixture of ISO 8601 week-numbering
       fields and Gregorian date fields is nonsensical, and will cause an
       error.  In the context of an ISO 8601 week-numbering year, the
       concept of a <quote>month</quote> or <quote>day of month</quote> has no
       meaning.  In the context of a Gregorian year, the ISO week has no
       meaning.
      </para>
      <caution>
       <para>
        While <function>to_date</function> will reject a mixture of
        Gregorian and ISO week-numbering date
        fields, <function>to_char</function> will not, since output format
        specifications like <literal>YYYY-MM-DD (IYYY-IDDD)</literal> can be
        useful.  But avoid writing something like <literal>IYYY-MM-DD</literal>;
        that would yield surprising results near the start of the year.
        (See <xref linkend="functions-datetime-extract"/> for more
        information.)
       </para>
      </caution>
     </listitem>

     <listitem>
      <para>
       In <function>to_timestamp</function>, millisecond
       (<literal>MS</literal>) or microsecond (<literal>US</literal>)
       fields are used as the
       seconds digits after the decimal point. For example
       <literal>to_timestamp('12.3', 'SS.MS')</literal> is not 3 milliseconds,
       but 300, because the conversion treats it as 12 + 0.3 seconds.
       So, for the format <literal>SS.MS</literal>, the input values
       <literal>12.3</literal>, <literal>12.30</literal>,
       and <literal>12.300</literal> specify the
       same number of milliseconds. To get three milliseconds, one must write
       <literal>12.003</literal>, which the conversion treats as
       12 + 0.003 = 12.003 seconds.
      </para>

      <para>
       Here is a more
       complex example:
       <literal>to_timestamp('15:12:02.020.001230', 'HH24:MI:SS.MS.US')</literal>
       is 15 hours, 12 minutes, and 2 seconds + 20 milliseconds +
       1230 microseconds = 2.021230 seconds.
      </para>
     </listitem>

     <listitem>
      <para>
        <function>to_char(..., 'ID')</function>'s day of the week numbering
        matches the <function>extract(isodow from ...)</function> function, but
        <function>to_char(..., 'D')</function>'s does not match
        <function>extract(dow from ...)</function>'s day numbering.
      </para>
     </listitem>

     <listitem>
      <para>
        <function>to_char(interval)</function> formats <literal>HH</literal> and
        <literal>HH12</literal> as shown on a 12-hour clock, for example zero hours
        and 36 hours both output as <literal>12</literal>, while <literal>HH24</literal>
        outputs the full hour value, which can exceed 23 in
        an <type>interval</type> value.
      </para>
     </listitem>

    </itemizedlist>
   </para>
____________________________________________________________________________-->
   <para>
    日期/时间格式化的使用须知：

    <itemizedlist>
     <listitem>
      <para>
       <literal>FM</literal>抑制前导的零或尾随的空白， 否则会把它们增加到输入从而把一个模式的输出变成固定宽度。在<productname>PostgreSQL</productname>中，<literal>FM</literal>只修改下一个声明，而在 Oracle 中，<literal>FM</literal>影响所有随后的声明，并且重复的<literal>FM</literal>修饰语将触发填充模式开和关。
      </para>
     </listitem>

     <listitem>
      <para>
       无论是否指定<literal>FM</literal>，<literal>TM</literal>抑制尾随的空格。
      </para>
     </listitem>

     <listitem>
      <para>
       <function>to_timestamp</function>和<function>to_date</function>忽略输入中的字母大小写；
       例如<literal>MON</literal>，<literal>Mon</literal>和<literal>mon</literal>都接受相同的字符串。
       当使用<literal>TM</literal>修饰符时，大小写折叠是根据函数的输入排序规则进行的(参见 <xref linkend="collation"/>)。
      </para>
     </listitem>

     <listitem>
      <para>
       <function>to_timestamp</function>和<function>to_date</function>跳过了输入字符串开头和日期和时间值周围的多个空格，除非使用了<literal>FX</literal>选项。 例如，<literal>to_to_timestamp('&nbsp;2000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JUN', 'YYY-MON')</literal>和<literal>to_timestamp('2000 - JUN', 'YYY-MON')</literal>都能工作，但<literal>to_timestamp('2000&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JUN', 'FXYYYY-MON')</literal>返回一个错误，因为<function>to_timestamp</function>只期望一个空格。<literal>FX</literal>必须指定为模板中的第一个项目。
      </para>
     </listitem>

     <listitem>
      <para>
       <function>to_timestamp</function>和<function>to_date</function>的模板字符串中的分隔符（一个空格或非字母/非数字字符）与输入字符串中的任何一个分隔符相匹配，或者被跳过，除非使用了<literal>FX</literal>选项。例如，<literal>to_to_timestamp('2000JUN', 'YYY///MON')</literal>和<literal>to_timestamp('2000/JUN', 'YYY/MON')</literal>可以工作，但<literal>to_timestamp('2000/JUN', 'YYYY/MON')</literal>返回一个错误，因为输入字符串中的分隔符数量超过了模板中的分隔符数量。
      </para>
      <para>
       如果指定了<literal>FX</literal>，模板字符串中的分隔符正好与输入字符串中的一个字符匹配。 但要注意的是，输入字符串中的字符不需要与模板字符串中的分隔符相同。例如，<literal>to_timestamp('2000/JUN', 'FXYYYY MON')</literal>可以工作，但是<literal>to_timestamp('2000/JUN', 'FXYYYY&nbsp;&nbsp;MON')</literal>返回错误，因为模板字符串中的第二个空格会消耗掉输入字符串中的字母<literal>J</literal>。
      </para>
     </listitem>

     <listitem>
      <para>
       <literal>TZH</literal>模板模式可以匹配一个有符号的数字。如果没有<literal>FX</literal>选项，减号可能是模糊的，可能被解释为分隔符。这种模棱两可的问题可以通过以下方式解决。 如果模板字符串中<literal>TZH</literal>前的分隔符的数量小于输入字符串中减号前的分隔符数量，则减号被解释为<literal>TZH</literal>的一部分。否则，减号被认为是值之间的分隔符。例如，<literal>to_timestamp(''2000 -10', 'YYY&nbsp;TZH')</literal>与<literal>-10</literal>匹配，但<literal>to_timestamp('2000 -10', 'YYYY&nbsp;&nbsp;TZH')</literal>匹配<literal>10</literal>到<literal>TZH</literal>。
      </para>
     </listitem>

     <listitem>
      <para>
       在<function>to_char</function>模板里可以有普通文本，并且它们会被照字面输出。你可以把一个子串放到双引号里强迫它被解释成一个文本，即使它里面包含模板模式也如此。例如，在 <literal>'"Hello Year "YYYY'</literal>中，<literal>YYYY</literal>将被年份数据代替，但是<literal>Year</literal>中单独的<literal>Y</literal>不会。在<function>to_date</function>、<function>to_number</function>以及<function>to_timestamp</function>中，文本和双引号字符串会导致跳过该字符串中所包含的字符数量，例如<literal>"XX"</literal>会跳过两个输入字符（不管它们是不是<literal>XX</literal>）。
      </para>
      <tip>
        <para>
          在<productname>PostgreSQL</productname> 12之前，可以使用非字母或非数字字符跳过输入字符串中的任意文本。例如，<literal>to_timestamp('2000y6m1d', 'yyyyy-MM-DD')</literal>以前是有效的。 现在，你只能使用字母字符来实现这个目的。 例如，<literal>to_timestamp(''2000y6m1d', 'yyyytMMtDDt')</literal>和<literal>to_timestamp('2000y6m1d', 'yyyyy"y"MM"m"DD"d"')</literal>跳过<literal>y</literal>、<literal>m</literal>和<literal>d</literal>。
        </para>
      </tip>
     </listitem>

     <listitem>
      <para>
       如果你想在输出里有双引号，那么你必须在它们前面放反斜线，例如 <literal>'\"YYYY Month\"'</literal>。<!-- "" font-lock sanity :-) -->不然，在双引号字符串外面的反斜线就不是特殊的。在双引号字符串内，反斜线会导致下一个字符被取其字面形式，不管它是什么字符（但是这没有特殊效果，除非下一个字符是一个双引号或者另一个反斜线）。
      </para>
     </listitem>

     <listitem>
      <para>
       在<function>to_timestamp</function>和<function>to_date</function>中，如果年份格式声明少于四位（如<literal>YYY</literal>）并且提供的年份少于四位，年份将被调整为最接近于 2020 年，例如<literal>95</literal>会变成 1995。
      </para>
     </listitem>

     <listitem>
      <para>
       在<function>to_timestamp</function>和<function>to_date</function>中，负的年份被视为表示BC。
       如果你同时写一个负的年份和一个显式的<literal>BC</literal>字段，你又会得到AD。第0年的输入被视为公元前1年。
      </para>
     </listitem>

     <listitem>
      <para>
       在<function>to_timestamp</function>和<function>to_date</function>中，在处理超过4位数的年份时，<literal>YYYY</literal>转换具有限制。你必须在<literal>YYYY</literal>后面使用一些非数字字符或者模板， 否则年份总是被解释为 4 位数字。例如（对于 20000 年）：<literal>to_date('200001131', 'YYYYMMDD')</literal>将会被解释成一个 4 位数字的年份，而不是在年份后使用一个非数字分隔符，像<literal>to_date('20000-1131', 'YYYY-MMDD')</literal>或<literal>to_date('20000Nov31', 'YYYYMonDD')</literal>。
      </para>
     </listitem>

     <listitem>
      <para>
       在<function>to_timestamp</function>和<function>to_date</function>中，<literal>CC</literal>（世纪）字段会被接受，但是如果有<literal>YYY</literal>、<literal>YYYY</literal>或者<literal>Y,YYY</literal>字段则会忽略它。如果<literal>CC</literal>与<literal>YY</literal>或<literal>Y</literal>一起使用，则结果被计算为指定世纪中的那一年。如果指定了世纪但是没有指定年，则会假定为该世纪的第一年。
      </para>
     </listitem>

     <listitem>
      <para>
       在<function>to_timestamp</function>和<function>to_date</function>中，工作日名称或编号（<literal>DAY</literal>、<literal>D</literal>以及相关的字段类型）会被接受，但会为了计算结果的目的而忽略。季度（<literal>Q</literal>）字段也是一样。
      </para>
     </listitem>

     <listitem>
      <para>
       在<function>to_timestamp</function>和<function>to_date</function>中，一个 ISO 8601 周编号的日期（与一个格里高利日期相区别）可以用两种方法之一被指定为<function>to_timestamp</function>和<function>to_date</function>：
       <itemizedlist>
        <listitem>
         <para>
          年、周编号和工作日：例如<literal>to_date('2006-42-4', 'IYYY-IW-ID')</literal>返回日期<literal>2006-10-19</literal>。如果你忽略工作日，它被假定为 1（周一）。
         </para>
        </listitem>
        <listitem>
         <para>
          年和一年中的日：例如<literal>to_date('2006-291', 'IYYY-IDDD')</literal>也返回<literal>2006-10-19</literal>。
         </para>
        </listitem>
       </itemizedlist>
      </para>
      <para>
       尝试使用一个混合了 ISO 8601 周编号和格里高利日期的域来输入一个日期是无意义的，并且将导致一个错误。在一个 ISO 周编号的年的环境下，一个<quote>月</quote>或<quote>月中的日</quote>的概念没有意义。在一个格里高利年的环境下，ISO 周没有意义。用户应当避免混合格里高利和 ISO 日期声明。
      </para>
      <caution>
       <para>
        虽然<function>to_date</function>将会拒绝混合使用格里高利和 ISO 周编号日期的域，
        <function>to_char</function>却不会，因为<literal>YYYY-MM-DD (IYYY-IDDD)</literal>
        这种输出格式也会有用。但是避免写类似<literal>IYYY-MM-DD</literal>的东西，那会得到在
        起始年附近令人惊讶的结果（详见<xref linkend="functions-datetime-extract"/>）。
       </para>
      </caution>
     </listitem>

     <listitem>
      <para>
       在<function>to_timestamp</function>中，毫秒（<literal>MS</literal>）和微秒（<literal>US</literal>）域都被用作小数点后的秒位。例如<literal>to_timestamp('12.3', 'SS.MS')</literal>不是 3 毫秒, 而是 300，因为该转换把它看做 12 + 0.3 秒。这意味着对于格式<literal>SS.MS</literal>而言，输入值<literal>12.3</literal>、<literal>12.30</literal>和<literal>12.300</literal>指定了相同数目的毫秒。要得到三毫秒，你必须使用 <literal>12.003</literal>，转换会把它看做 12 + 0.003 = 12.003 秒。
      </para>

      <para>
       下面是一个更复杂的例子∶<literal>to_timestamp('15:12:02.020.001230', 'HH24:MI:SS.MS.US')</literal>是 15 小时、12 分钟和 2 秒 + 20 毫秒 + 1230微秒 = 2.021230 秒。
      </para>
     </listitem>

     <listitem>
      <para>
        <function>to_char(..., 'ID')</function>的一周中日的编号匹配<function>extract(isodow from ...)</function>函数，但是<function>to_char(..., 'D')</function>不匹配<function>extract(dow from ...)</function>的日编号。
      </para>
     </listitem>

     <listitem>
      <para>
        <function>to_char(interval)</function>格式化<literal>HH</literal>和<literal>HH12</literal>为显示在一个 12 小时的时钟上，即零小时和 36 小时输出为<literal>12</literal>，而<literal>HH24</literal>会输出完整的小时值，对于间隔它可以超过 23.
      </para>
     </listitem>

    </itemizedlist>
   </para>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="functions-formatting-numeric-table"/> shows the
   template patterns available for formatting numeric values.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="functions-formatting-numeric-table"/>展示了可以用于格式化数字值的模版模式。
  </para>

    <table id="functions-formatting-numeric-table">
<!--==========================orignal english content==========================
     <title>Template Patterns for Numeric Formatting</title>
____________________________________________________________________________-->
     <title>用于数字格式化的模板模式</title>
     <tgroup cols="2">
      <thead>
<!--==========================orignal english content==========================
       <row>
        <entry>Pattern</entry>
        <entry>Description</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>模式</entry>
        <entry>描述</entry>
       </row>
      </thead>
      <tbody>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>9</literal></entry>
        <entry>digit position (can be dropped if insignificant)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>9</literal></entry>
        <entry>数位（如果无意义可以被删除）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>0</literal></entry>
        <entry>digit position (will not be dropped, even if insignificant)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>0</literal></entry>
        <entry>数位（即便没有意义也不会被删除）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>.</literal> (period)</entry>
        <entry>decimal point</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>.</literal> (period)</entry>
        <entry>小数点</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>,</literal> (comma)</entry>
        <entry>group (thousands) separator</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>,</literal> (comma)</entry>
        <entry>分组（千）分隔符</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>PR</literal></entry>
        <entry>negative value in angle brackets</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>PR</literal></entry>
        <entry>尖括号内的负值</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>S</literal></entry>
        <entry>sign anchored to number (uses locale)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>S</literal></entry>
        <entry>带符号的数字（使用区域）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>L</literal></entry>
        <entry>currency symbol (uses locale)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>L</literal></entry>
        <entry>货币符号（使用区域）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>D</literal></entry>
        <entry>decimal point (uses locale)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>D</literal></entry>
        <entry>小数点（使用区域）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>G</literal></entry>
        <entry>group separator (uses locale)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>G</literal></entry>
        <entry>分组分隔符（使用区域）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>MI</literal></entry>
        <entry>minus sign in specified position (if number &lt; 0)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>MI</literal></entry>
        <entry>在指定位置的负号（如果数字 &lt; 0）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>PL</literal></entry>
        <entry>plus sign in specified position (if number &gt; 0)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>PL</literal></entry>
        <entry>在指定位置的正号（如果数字 &gt; 0）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>SG</literal></entry>
        <entry>plus/minus sign in specified position</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>SG</literal></entry>
        <entry>在指定位置的正/负号</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>RN</literal></entry>
        <entry>Roman numeral (input between 1 and 3999)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>RN</literal></entry>
        <entry>罗马数字（输入在 1 和 3999 之间）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>TH</literal> or <literal>th</literal></entry>
        <entry>ordinal number suffix</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>TH</literal> or <literal>th</literal></entry>
        <entry>序数后缀</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>V</literal></entry>
        <entry>shift specified number of digits (see notes)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>V</literal></entry>
        <entry>移动指定位数（参阅注解）</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>EEEE</literal></entry>
        <entry>exponent for scientific notation</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>EEEE</literal></entry>
        <entry>科学记数的指数</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

<!--==========================orignal english content==========================
   <para>
    Usage notes for numeric formatting:

    <itemizedlist>
     <listitem>
      <para>
       <literal>0</literal> specifies a digit position that will always be printed,
       even if it contains a leading/trailing zero.  <literal>9</literal> also
       specifies a digit position, but if it is a leading zero then it will
       be replaced by a space, while if it is a trailing zero and fill mode
       is specified then it will be deleted.  (For <function>to_number()</function>,
       these two pattern characters are equivalent.)
      </para>
     </listitem>

     <listitem>
      <para>
       The pattern characters <literal>S</literal>, <literal>L</literal>, <literal>D</literal>,
       and <literal>G</literal> represent the sign, currency symbol, decimal point,
       and thousands separator characters defined by the current locale
       (see <xref linkend="guc-lc-monetary"/>
       and <xref linkend="guc-lc-numeric"/>).  The pattern characters period
       and comma represent those exact characters, with the meanings of
       decimal point and thousands separator, regardless of locale.
      </para>
     </listitem>

     <listitem>
      <para>
       If no explicit provision is made for a sign
       in <function>to_char()</function>'s pattern, one column will be reserved for
       the sign, and it will be anchored to (appear just left of) the
       number.  If <literal>S</literal> appears just left of some <literal>9</literal>'s,
       it will likewise be anchored to the number.
      </para>
     </listitem>

     <listitem>
      <para>
       A sign formatted using <literal>SG</literal>, <literal>PL</literal>, or
       <literal>MI</literal> is not anchored to
       the number; for example,
       <literal>to_char(-12, 'MI9999')</literal> produces <literal>'-&nbsp;&nbsp;12'</literal>
       but <literal>to_char(-12, 'S9999')</literal> produces <literal>'&nbsp;&nbsp;-12'</literal>.
       (The Oracle implementation does not allow the use of
       <literal>MI</literal> before <literal>9</literal>, but rather
       requires that <literal>9</literal> precede
       <literal>MI</literal>.)
      </para>
     </listitem>

     <listitem>
      <para>
       <literal>TH</literal> does not convert values less than zero
       and does not convert fractional numbers.
      </para>
     </listitem>

     <listitem>
      <para>
       <literal>PL</literal>, <literal>SG</literal>, and
       <literal>TH</literal> are <productname>PostgreSQL</productname>
       extensions.
      </para>
     </listitem>

     <listitem>
      <para>
       In <function>to_number</function>, if non-data template patterns such
       as <literal>L</literal> or <literal>TH</literal> are used, the
       corresponding number of input characters are skipped, whether or not
       they match the template pattern, unless they are data characters
       (that is, digits, sign, decimal point, or comma).  For
       example, <literal>TH</literal> would skip two non-data characters.
      </para>
     </listitem>

     <listitem>
      <para>
       <literal>V</literal> with <function>to_char</function>
       multiplies the input values by
       <literal>10^<replaceable>n</replaceable></literal>, where
       <replaceable>n</replaceable> is the number of digits following
       <literal>V</literal>.  <literal>V</literal> with
       <function>to_number</function> divides in a similar manner.
       <function>to_char</function> and <function>to_number</function>
       do not support the use of
       <literal>V</literal> combined with a decimal point
       (e.g., <literal>99.9V99</literal> is not allowed).
      </para>
     </listitem>

     <listitem>
      <para>
       <literal>EEEE</literal> (scientific notation) cannot be used in
       combination with any of the other formatting patterns or
       modifiers other than digit and decimal point patterns, and must be at the end of the format string
       (e.g., <literal>9.99EEEE</literal> is a valid pattern).
      </para>
     </listitem>
    </itemizedlist>
   </para>
____________________________________________________________________________-->
   <para>
    数字格式化的用法须知：

    <itemizedlist>
     <listitem>
      <para>
       <literal>0</literal>指定一个总是被打印的数位，即便它包含前导/拖尾的零。<literal>9</literal>也指定一个数位，但是如果它是前导零则会被空格替换，而如果是拖尾零并且指定了填充模式则它会被删除（对于<function>to_number()</function>来说，这两种模式字符等效）。
      </para>
     </listitem>

     <listitem>
      <para>
       模式字符<literal>S</literal>、<literal>L</literal>、<literal>D</literal>以及<literal>G</literal>表示当前locale定义的负号、货币符号、小数点以及数字分隔符字符（见<xref linkend="guc-lc-monetary"/>和<xref linkend="guc-lc-numeric"/>）。不管locale是什么，模式字符句号和逗号就表示小数点和数字分隔符。
      </para>
     </listitem>

     <listitem>
      <para>
       对于<function>to_char()</function>的模式中的一个负号，如果没有明确的规定，将为该负号保留一列，并且它将被锚接到（出现在左边）那个数字。如果<literal>S</literal>正好出现在某个<literal>9</literal>的左边，它也将被锚接到那个数字。
      </para>
     </listitem>

     <listitem>
      <para>
       使用<literal>SG</literal>、<literal>PL</literal>或<literal>MI</literal>格式化的符号并不挂在数字上面； 例如，<literal>to_char(-12, 'MI9999')</literal>生成<literal>'-&nbsp;&nbsp;12'</literal>，而<literal>to_char(-12, 'S9999')</literal>生成 <literal>'&nbsp;&nbsp;-12'</literal>。（Oracle 里的实现不允许在<literal>9</literal>前面使用<literal>MI</literal>，而是要求<literal>9</literal>在<literal>MI</literal>前面。）
      </para>
     </listitem>

     <listitem>
      <para>
       <literal>TH</literal>不会转换小于零的数值，也不会转换小数。
      </para>
     </listitem>

     <listitem>
      <para>
       <literal>PL</literal>、<literal>SG</literal>和<literal>TH</literal>是<productname>PostgreSQL</productname>扩展。
      </para>
     </listitem>

     <listitem>
      <para>
       在<function>to_number</function>中，如果没有使用<literal>L</literal>或<literal>TH</literal>之类的非数据模板模式，相应数量的输入字符会被跳过，不管它们是否匹配模板模式，除非它们是数据字符（也就是数位、负号、小数点或者逗号）。例如，<literal>TH</literal>会跳过两个非数据字符。
      </para>
     </listitem>

     <listitem>
      <para>
       带有<function>to_char</function>的<literal>V</literal>会把输入值乘上<literal>10^<replaceable>n</replaceable></literal>，其中<replaceable>n</replaceable>是跟在<literal>V</literal>后面的位数。带有<function>to_number</function>的<literal>V</literal>以类似的方式做除法。<function>to_char</function>和<function>to_number</function>不支持使用结合小数点的<literal>V</literal>（例如，不允许<literal>99.9V99</literal>）。
      </para>
     </listitem>

     <listitem>
      <para>
       <literal>EEEE</literal>（科学记数法）不能和任何其他格式化模式或修饰语（数字和小数点模式除外）组合在一起使用，并且必须位于格式化字符串的最后（例如<literal>9.99EEEE</literal>是一个合法的模式）。
      </para>
     </listitem>
    </itemizedlist>
   </para>

<!--==========================orignal english content==========================
   <para>
    Certain modifiers can be applied to any template pattern to alter its
    behavior.  For example, <literal>FM99.99</literal>
    is the <literal>99.99</literal> pattern with the
    <literal>FM</literal> modifier.
    <xref linkend="functions-formatting-numericmod-table"/> shows the
    modifier patterns for numeric formatting.
   </para>
____________________________________________________________________________-->
   <para>
    某些修饰语可以被应用到任何模板来改变其行为。例如，<literal>FM99.99</literal>是带有<literal>FM</literal>修饰语的<literal>99.99</literal>模式。<xref linkend="functions-formatting-numericmod-table"/>中展示了用于数字格式化模式修饰语。
   </para>

    <table id="functions-formatting-numericmod-table">
<!--==========================orignal english content==========================
     <title>Template Pattern Modifiers for Numeric Formatting</title>
____________________________________________________________________________-->
     <title>用于数字格式化的模板模式修饰语</title>
     <tgroup cols="3">
      <thead>
<!--==========================orignal english content==========================
       <row>
        <entry>Modifier</entry>
        <entry>Description</entry>
        <entry>Example</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>修饰语</entry>
        <entry>描述</entry>
        <entry>例子</entry>
       </row>
      </thead>
      <tbody>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>FM</literal> prefix</entry>
        <entry>fill mode (suppress trailing zeroes and padding blanks)</entry>
        <entry><literal>FM99.99</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>FM</literal> prefix</entry>
        <entry>填充模式（抑制拖尾零和填充的空白）</entry>
        <entry><literal>FM99.99</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>TH</literal> suffix</entry>
        <entry>upper case ordinal number suffix</entry>
        <entry><literal>999TH</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>TH</literal> suffix</entry>
        <entry>大写序数后缀</entry>
        <entry><literal>999TH</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>th</literal> suffix</entry>
        <entry>lower case ordinal number suffix</entry>
        <entry><literal>999th</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>th</literal> suffix</entry>
        <entry>小写序数后缀</entry>
        <entry><literal>999th</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="functions-formatting-examples-table"/> shows some
   examples of the use of the <function>to_char</function> function.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="functions-formatting-examples-table"/>展示了一些使用<function>to_char</function>函数的例子。
  </para>

    <table id="functions-formatting-examples-table">
<!--==========================orignal english content==========================
     <title><function>to_char</function> Examples</title>
____________________________________________________________________________-->
     <title><function>to_char</function>例子</title>
     <tgroup cols="2">
      <thead>
<!--==========================orignal english content==========================
       <row>
        <entry>Expression</entry>
        <entry>Result</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>表达式</entry>
        <entry>结果</entry>
       </row>
      </thead>
      <tbody>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(current_timestamp, 'Day,&nbsp;DD&nbsp;&nbsp;HH12:MI:SS')</literal></entry>
        <entry><literal>'Tuesday&nbsp;&nbsp;,&nbsp;06&nbsp;&nbsp;05:39:18'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(current_timestamp, 'Day,&nbsp;DD&nbsp;&nbsp;HH12:MI:SS')</literal></entry>
        <entry><literal>'Tuesday&nbsp;&nbsp;,&nbsp;06&nbsp;&nbsp;05:39:18'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(current_timestamp, 'FMDay,&nbsp;FMDD&nbsp;&nbsp;HH12:MI:SS')</literal></entry>
        <entry><literal>'Tuesday,&nbsp;6&nbsp;&nbsp;05:39:18'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(current_timestamp, 'FMDay,&nbsp;FMDD&nbsp;&nbsp;HH12:MI:SS')</literal></entry>
        <entry><literal>'Tuesday,&nbsp;6&nbsp;&nbsp;05:39:18'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(-0.1, '99.99')</literal></entry>
        <entry><literal>'&nbsp;&nbsp;-.10'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(-0.1, '99.99')</literal></entry>
        <entry><literal>'&nbsp;&nbsp;-.10'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(-0.1, 'FM9.99')</literal></entry>
        <entry><literal>'-.1'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(-0.1, 'FM9.99')</literal></entry>
        <entry><literal>'-.1'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(-0.1, 'FM90.99')</literal></entry>
        <entry><literal>'-0.1'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(-0.1, 'FM90.99')</literal></entry>
        <entry><literal>'-0.1'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(0.1, '0.9')</literal></entry>
        <entry><literal>'&nbsp;0.1'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(0.1, '0.9')</literal></entry>
        <entry><literal>'&nbsp;0.1'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(12, '9990999.9')</literal></entry>
        <entry><literal>'&nbsp;&nbsp;&nbsp;&nbsp;0012.0'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(12, '9990999.9')</literal></entry>
        <entry><literal>'&nbsp;&nbsp;&nbsp;&nbsp;0012.0'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(12, 'FM9990999.9')</literal></entry>
        <entry><literal>'0012.'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(12, 'FM9990999.9')</literal></entry>
        <entry><literal>'0012.'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(485, '999')</literal></entry>
        <entry><literal>'&nbsp;485'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(485, '999')</literal></entry>
        <entry><literal>'&nbsp;485'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(-485, '999')</literal></entry>
        <entry><literal>'-485'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(-485, '999')</literal></entry>
        <entry><literal>'-485'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(485, '9&nbsp;9&nbsp;9')</literal></entry>
        <entry><literal>'&nbsp;4&nbsp;8&nbsp;5'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(485, '9&nbsp;9&nbsp;9')</literal></entry>
        <entry><literal>'&nbsp;4&nbsp;8&nbsp;5'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(1485, '9,999')</literal></entry>
        <entry><literal>'&nbsp;1,485'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(1485, '9,999')</literal></entry>
        <entry><literal>'&nbsp;1,485'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(1485, '9G999')</literal></entry>
        <entry><literal>'&nbsp;1&nbsp;485'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(1485, '9G999')</literal></entry>
        <entry><literal>'&nbsp;1&nbsp;485'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(148.5, '999.999')</literal></entry>
        <entry><literal>'&nbsp;148.500'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(148.5, '999.999')</literal></entry>
        <entry><literal>'&nbsp;148.500'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(148.5, 'FM999.999')</literal></entry>
        <entry><literal>'148.5'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(148.5, 'FM999.999')</literal></entry>
        <entry><literal>'148.5'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(148.5, 'FM999.990')</literal></entry>
        <entry><literal>'148.500'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(148.5, 'FM999.990')</literal></entry>
        <entry><literal>'148.500'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(148.5, '999D999')</literal></entry>
        <entry><literal>'&nbsp;148,500'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(148.5, '999D999')</literal></entry>
        <entry><literal>'&nbsp;148,500'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(3148.5, '9G999D999')</literal></entry>
        <entry><literal>'&nbsp;3&nbsp;148,500'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(3148.5, '9G999D999')</literal></entry>
        <entry><literal>'&nbsp;3&nbsp;148,500'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(-485, '999S')</literal></entry>
        <entry><literal>'485-'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(-485, '999S')</literal></entry>
        <entry><literal>'485-'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(-485, '999MI')</literal></entry>
        <entry><literal>'485-'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(-485, '999MI')</literal></entry>
        <entry><literal>'485-'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(485, '999MI')</literal></entry>
        <entry><literal>'485&nbsp;'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(485, '999MI')</literal></entry>
        <entry><literal>'485&nbsp;'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(485, 'FM999MI')</literal></entry>
        <entry><literal>'485'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(485, 'FM999MI')</literal></entry>
        <entry><literal>'485'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(485, 'PL999')</literal></entry>
        <entry><literal>'+485'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(485, 'PL999')</literal></entry>
        <entry><literal>'+485'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(485, 'SG999')</literal></entry>
        <entry><literal>'+485'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(485, 'SG999')</literal></entry>
        <entry><literal>'+485'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(-485, 'SG999')</literal></entry>
        <entry><literal>'-485'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(-485, 'SG999')</literal></entry>
        <entry><literal>'-485'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(-485, '9SG99')</literal></entry>
        <entry><literal>'4-85'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(-485, '9SG99')</literal></entry>
        <entry><literal>'4-85'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(-485, '999PR')</literal></entry>
        <entry><literal>'&lt;485&gt;'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(-485, '999PR')</literal></entry>
        <entry><literal>'&lt;485&gt;'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(485, 'L999')</literal></entry>
        <entry><literal>'DM&nbsp;485'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(485, 'L999')</literal></entry>
        <entry><literal>'DM&nbsp;485'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(485, 'RN')</literal></entry>
        <entry><literal>'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDLXXXV'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(485, 'RN')</literal></entry>
        <entry><literal>'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDLXXXV'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(485, 'FMRN')</literal></entry>
        <entry><literal>'CDLXXXV'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(485, 'FMRN')</literal></entry>
        <entry><literal>'CDLXXXV'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(5.2, 'FMRN')</literal></entry>
        <entry><literal>'V'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(5.2, 'FMRN')</literal></entry>
        <entry><literal>'V'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(482, '999th')</literal></entry>
        <entry><literal>'&nbsp;482nd'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(482, '999th')</literal></entry>
        <entry><literal>'&nbsp;482nd'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(485, '"Good&nbsp;number:"999')</literal></entry>
        <entry><literal>'Good&nbsp;number:&nbsp;485'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(485, '"Good&nbsp;number:"999')</literal></entry>
        <entry><literal>'Good&nbsp;number:&nbsp;485'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(485.8, '"Pre:"999"&nbsp;Post:"&nbsp;.999')</literal></entry>
        <entry><literal>'Pre:&nbsp;485&nbsp;Post:&nbsp;.800'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(485.8, '"Pre:"999"&nbsp;Post:"&nbsp;.999')</literal></entry>
        <entry><literal>'Pre:&nbsp;485&nbsp;Post:&nbsp;.800'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(12, '99V999')</literal></entry>
        <entry><literal>'&nbsp;12000'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(12, '99V999')</literal></entry>
        <entry><literal>'&nbsp;12000'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(12.4, '99V999')</literal></entry>
        <entry><literal>'&nbsp;12400'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(12.4, '99V999')</literal></entry>
        <entry><literal>'&nbsp;12400'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(12.45, '99V9')</literal></entry>
        <entry><literal>'&nbsp;125'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(12.45, '99V9')</literal></entry>
        <entry><literal>'&nbsp;125'</literal></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>to_char(0.0004859, '9.99EEEE')</literal></entry>
        <entry><literal>' 4.86e-04'</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>to_char(0.0004859, '9.99EEEE')</literal></entry>
        <entry><literal>' 4.86e-04'</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  </sect1>


  <sect1 id="functions-datetime">
<!--==========================orignal english content==========================
   <title>Date/Time Functions and Operators</title>
____________________________________________________________________________-->
   <title>时间/日期函数和操作符</title>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="functions-datetime-table"/> shows the available
   functions for date/time value processing, with details appearing in
   the following subsections.  <xref
   linkend="operators-datetime-table"/> illustrates the behaviors of
   the basic arithmetic operators (<literal>+</literal>,
   <literal>*</literal>, etc.).  For formatting functions, refer to
   <xref linkend="functions-formatting"/>.  You should be familiar with
   the background information on date/time data types from <xref
   linkend="datatype-datetime"/>.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="functions-datetime-table"/>展示了可用于处理日期/时间值的函数，其细节在随后的小节中描述。<xref linkend="operators-datetime-table"/>演示了基本算术操作符 （<literal>+</literal>、<literal>*</literal>等）的行为。 而与格式化相关的函数，可以参考<xref linkend="functions-formatting"/>。你应该很熟悉<xref linkend="datatype-datetime"/>中的日期/时间数据类型的背景知识。
  </para>

<!--==========================orignal english content==========================
  <para>
   All the functions and operators described below that take <type>time</type> or <type>timestamp</type>
   inputs actually come in two variants: one that takes <type>time with time zone</type> or <type>timestamp
   with time zone</type>, and one that takes <type>time without time zone</type> or <type>timestamp without time zone</type>.
   For brevity, these variants are not shown separately.  Also, the
   <literal>+</literal> and <literal>*</literal> operators come in commutative pairs (for
   example both date + integer and integer + date); we show only one of each
   such pair.
  </para>
____________________________________________________________________________-->
  <para>
   所有下文描述的接受<type>time</type>或<type>timestamp</type>输入的函数和操作符实际上都有两种变体： 一种接收<type>time with time zone</type>或<type>timestamp with time zone</type>， 另外一种接受<type>time without time zone</type>或者 <type>timestamp without time zone</type>。为了简化，这些变种没有被独立地展示。此外，<literal>+</literal>和<literal>*</literal>操作符都是可交换的操作符对（例如，date + integer 和 integer + date）；我们只显示其中一个。
  </para>

    <table id="operators-datetime-table">
<!--==========================orignal english content==========================
     <title>Date/Time Operators</title>
____________________________________________________________________________-->
     <title>日期/时间操作符</title>

     <tgroup cols="1">
      <thead>
<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         Operator
        </para>
        <para>
         Description
        </para>
        <para>
         Example(s)
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         操作符
        </para>
        <para>
         描述
        </para>
        <para>
         例子
        </para></entry>
       </row>
      </thead>

      <tbody>
<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>date</type> <literal>+</literal> <type>integer</type>
         <returnvalue>date</returnvalue>
        </para>
        <para>
         Add a number of days to a date
        </para>
        <para>
         <literal>date '2001-09-28' + 7</literal>
         <returnvalue>2001-10-05</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>date</type> <literal>+</literal> <type>integer</type>
         <returnvalue>date</returnvalue>
        </para>
        <para>
         给日期加上天数
        </para>
        <para>
         <literal>date '2001-09-28' + 7</literal>
         <returnvalue>2001-10-05</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>date</type> <literal>+</literal> <type>interval</type>
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         Add an interval to a date
        </para>
        <para>
         <literal>date '2001-09-28' + interval '1 hour'</literal>
         <returnvalue>2001-09-28 01:00:00</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>date</type> <literal>+</literal> <type>interval</type>
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         为日期添加时间间隔
        </para>
        <para>
         <literal>date '2001-09-28' + interval '1 hour'</literal>
         <returnvalue>2001-09-28 01:00:00</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>date</type> <literal>+</literal> <type>time</type>
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         Add a time-of-day to a date
        </para>
        <para>
         <literal>date '2001-09-28' + time '03:00'</literal>
         <returnvalue>2001-09-28 03:00:00</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>date</type> <literal>+</literal> <type>time</type>
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         在日期中添加一天中的时间
        </para>
        <para>
         <literal>date '2001-09-28' + time '03:00'</literal>
         <returnvalue>2001-09-28 03:00:00</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>interval</type> <literal>+</literal> <type>interval</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         Add intervals
        </para>
        <para>
         <literal>interval '1 day' + interval '1 hour'</literal>
         <returnvalue>1 day 01:00:00</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>interval</type> <literal>+</literal> <type>interval</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         添加时间间隔
        </para>
        <para>
         <literal>interval '1 day' + interval '1 hour'</literal>
         <returnvalue>1 day 01:00:00</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>timestamp</type> <literal>+</literal> <type>interval</type>
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         Add an interval to a timestamp
        </para>
        <para>
         <literal>timestamp '2001-09-28 01:00' + interval '23 hours'</literal>
         <returnvalue>2001-09-29 00:00:00</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>timestamp</type> <literal>+</literal> <type>interval</type>
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         在时间戳中添加一个时间间隔
        </para>
        <para>
         <literal>timestamp '2001-09-28 01:00' + interval '23 hours'</literal>
         <returnvalue>2001-09-29 00:00:00</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>time</type> <literal>+</literal> <type>interval</type>
         <returnvalue>time</returnvalue>
        </para>
        <para>
         Add an interval to a time
        </para>
        <para>
         <literal>time '01:00' + interval '3 hours'</literal>
         <returnvalue>04:00:00</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>time</type> <literal>+</literal> <type>interval</type>
         <returnvalue>time</returnvalue>
        </para>
        <para>
         为时间添加时间间隔
        </para>
        <para>
         <literal>time '01:00' + interval '3 hours'</literal>
         <returnvalue>04:00:00</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <literal>-</literal> <type>interval</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         Negate an interval
        </para>
        <para>
         <literal>- interval '23 hours'</literal>
         <returnvalue>-23:00:00</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <literal>-</literal> <type>interval</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         取否一个时间间隔
        </para>
        <para>
         <literal>- interval '23 hours'</literal>
         <returnvalue>-23:00:00</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>date</type> <literal>-</literal> <type>date</type>
         <returnvalue>integer</returnvalue>
        </para>
        <para>
         Subtract dates, producing the number of days elapsed
        </para>
        <para>
         <literal>date '2001-10-01' - date '2001-09-28'</literal>
         <returnvalue>3</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>date</type> <literal>-</literal> <type>date</type>
         <returnvalue>integer</returnvalue>
        </para>
        <para>
         减去日期，生成经过的天数
        </para>
        <para>
         <literal>date '2001-10-01' - date '2001-09-28'</literal>
         <returnvalue>3</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>date</type> <literal>-</literal> <type>integer</type>
         <returnvalue>date</returnvalue>
        </para>
        <para>
         Subtract a number of days from a date
        </para>
        <para>
         <literal>date '2001-10-01' - 7</literal>
         <returnvalue>2001-09-24</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>date</type> <literal>-</literal> <type>integer</type>
         <returnvalue>date</returnvalue>
        </para>
        <para>
         从日期中减去天数
        </para>
        <para>
         <literal>date '2001-10-01' - 7</literal>
         <returnvalue>2001-09-24</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>date</type> <literal>-</literal> <type>interval</type>
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         Subtract an interval from a date
        </para>
        <para>
         <literal>date '2001-09-28' - interval '1 hour'</literal>
         <returnvalue>2001-09-27 23:00:00</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>date</type> <literal>-</literal> <type>interval</type>
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         从日期中减去时间间隔
        </para>
        <para>
         <literal>date '2001-09-28' - interval '1 hour'</literal>
         <returnvalue>2001-09-27 23:00:00</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>time</type> <literal>-</literal> <type>time</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         Subtract times
        </para>
        <para>
         <literal>time '05:00' - time '03:00'</literal>
         <returnvalue>02:00:00</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>time</type> <literal>-</literal> <type>time</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         减去时间
        </para>
        <para>
         <literal>time '05:00' - time '03:00'</literal>
         <returnvalue>02:00:00</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>time</type> <literal>-</literal> <type>interval</type>
         <returnvalue>time</returnvalue>
        </para>
        <para>
         Subtract an interval from a time
        </para>
        <para>
         <literal>time '05:00' - interval '2 hours'</literal>
         <returnvalue>03:00:00</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>time</type> <literal>-</literal> <type>interval</type>
         <returnvalue>time</returnvalue>
        </para>
        <para>
         从时间中减去时间间隔
        </para>
        <para>
         <literal>time '05:00' - interval '2 hours'</literal>
         <returnvalue>03:00:00</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>timestamp</type> <literal>-</literal> <type>interval</type>
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         Subtract an interval from a timestamp
        </para>
        <para>
         <literal>timestamp '2001-09-28 23:00' - interval '23 hours'</literal>
         <returnvalue>2001-09-28 00:00:00</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>timestamp</type> <literal>-</literal> <type>interval</type>
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         从时间戳中减去时间间隔
        </para>
        <para>
         <literal>timestamp '2001-09-28 23:00' - interval '23 hours'</literal>
         <returnvalue>2001-09-28 00:00:00</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>interval</type> <literal>-</literal> <type>interval</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         Subtract intervals
        </para>
        <para>
         <literal>interval '1 day' - interval '1 hour'</literal>
         <returnvalue>1 day -01:00:00</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>interval</type> <literal>-</literal> <type>interval</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         减去时间间隔
        </para>
        <para>
         <literal>interval '1 day' - interval '1 hour'</literal>
         <returnvalue>1 day -01:00:00</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>timestamp</type> <literal>-</literal> <type>timestamp</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         Subtract timestamps (converting 24-hour intervals into days,
         similarly to <function>justify_hours()</function>)
        </para>
        <para>
         <literal>timestamp '2001-09-29 03:00' - timestamp '2001-07-27 12:00'</literal>
         <returnvalue>63 days 15:00:00</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>timestamp</type> <literal>-</literal> <type>timestamp</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         减去时间戳（将24小时间隔转换为天，类似于<function>justify_hours()</function>）
        </para>
        <para>
         <literal>timestamp '2001-09-29 03:00' - timestamp '2001-07-27 12:00'</literal>
         <returnvalue>63 days 15:00:00</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>interval</type> <literal>*</literal> <type>double precision</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         Multiply an interval by a scalar
        </para>
        <para>
         <literal>interval '1 second' * 900</literal>
         <returnvalue>00:15:00</returnvalue>
        </para>
        <para>
         <literal>interval '1 day' * 21</literal>
         <returnvalue>21 days</returnvalue>
        </para>
        <para>
         <literal>interval '1 hour' * 3.5</literal>
         <returnvalue>03:30:00</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>interval</type> <literal>*</literal> <type>double precision</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         将时间间隔乘以数量
        </para>
        <para>
         <literal>interval '1 second' * 900</literal>
         <returnvalue>00:15:00</returnvalue>
        </para>
        <para>
         <literal>interval '1 day' * 21</literal>
         <returnvalue>21 days</returnvalue>
        </para>
        <para>
         <literal>interval '1 hour' * 3.5</literal>
         <returnvalue>03:30:00</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>interval</type> <literal>/</literal> <type>double precision</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         Divide an interval by a scalar
        </para>
        <para>
         <literal>interval '1 hour' / 1.5</literal>
         <returnvalue>00:40:00</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>interval</type> <literal>/</literal> <type>double precision</type>
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         用时间间隔除以数量
        </para>
        <para>
         <literal>interval '1 hour' / 1.5</literal>
         <returnvalue>00:40:00</returnvalue>
        </para></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <table id="functions-datetime-table">
<!--==========================orignal english content==========================
     <title>Date/Time Functions</title>
____________________________________________________________________________-->
     <title>日期/时间函数</title>
     <tgroup cols="1">
      <thead>
<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         Function
        </para>
        <para>
         Description
        </para>
        <para>
         Example(s)
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         函数
        </para>
        <para>
         描述
        </para>
        <para>
         例子
        </para></entry>
       </row>
      </thead>

      <tbody>
<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>age</primary>
         </indexterm>
         <function>age</function> ( <type>timestamp</type>, <type>timestamp</type> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         Subtract arguments, producing a <quote>symbolic</quote> result that
         uses years and months, rather than just days
        </para>
        <para>
         <literal>age(timestamp '2001-04-10', timestamp '1957-06-13')</literal>
         <returnvalue>43 years 9 mons 27 days</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>age</primary>
         </indexterm>
         <function>age</function> ( <type>timestamp</type>, <type>timestamp</type> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         减去参数，生成一个使用年和月，而不是只用日的<quote>符号化</quote>的结果
        </para>
        <para>
         <literal>age(timestamp '2001-04-10', timestamp '1957-06-13')</literal>
         <returnvalue>43 years 9 mons 27 days</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>age</function> ( <type>timestamp</type> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         Subtract argument from <function>current_date</function> (at midnight)
        </para>
        <para>
         <literal>age(timestamp '1957-06-13')</literal>
         <returnvalue>62 years 6 mons 10 days</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>age</function> ( <type>timestamp</type> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         从 <function>current_date</function> 减去参数(在午夜)
        </para>
        <para>
         <literal>age(timestamp '1957-06-13')</literal>
         <returnvalue>62 years 6 mons 10 days</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>clock_timestamp</primary>
         </indexterm>
         <function>clock_timestamp</function> ( )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         Current date and time (changes during statement execution);
         see <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>clock_timestamp()</literal>
         <returnvalue>2019-12-23 14:39:53.662522-05</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>clock_timestamp</primary>
         </indexterm>
         <function>clock_timestamp</function> ( )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         当前日期和时间（在语句执行期间变化）；参见<xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>clock_timestamp()</literal>
         <returnvalue>2019-12-23 14:39:53.662522-05</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>current_date</primary>
         </indexterm>
         <function>current_date</function>
         <returnvalue>date</returnvalue>
        </para>
        <para>
         Current date; see <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>current_date</literal>
         <returnvalue>2019-12-23</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>current_date</primary>
         </indexterm>
         <function>current_date</function>
         <returnvalue>date</returnvalue>
        </para>
        <para>
         当前日期；参见 <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>current_date</literal>
         <returnvalue>2019-12-23</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>current_time</primary>
         </indexterm>
         <function>current_time</function>
         <returnvalue>time with time zone</returnvalue>
        </para>
        <para>
         Current time of day; see <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>current_time</literal>
         <returnvalue>14:39:53.662522-05</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>current_time</primary>
         </indexterm>
         <function>current_time</function>
         <returnvalue>time with time zone</returnvalue>
        </para>
        <para>
         一天中的当前时间；参见 <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>current_time</literal>
         <returnvalue>14:39:53.662522-05</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>current_time</function> ( <type>integer</type> )
         <returnvalue>time with time zone</returnvalue>
        </para>
        <para>
         Current time of day, with limited precision;
         see <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>current_time(2)</literal>
         <returnvalue>14:39:53.66-05</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>current_time</function> ( <type>integer</type> )
         <returnvalue>time with time zone</returnvalue>
        </para>
        <para>
         一天中的当前时间；有限精度；参见 <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>current_time(2)</literal>
         <returnvalue>14:39:53.66-05</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>current_timestamp</primary>
         </indexterm>
         <function>current_timestamp</function>
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         Current date and time (start of current transaction);
         see <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>current_timestamp</literal>
         <returnvalue>2019-12-23 14:39:53.662522-05</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>current_timestamp</primary>
         </indexterm>
         <function>current_timestamp</function>
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         当前日期和时间 (当前事务的开始)；参见 <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>current_timestamp</literal>
         <returnvalue>2019-12-23 14:39:53.662522-05</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>current_timestamp</function> ( <type>integer</type> )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         Current date and time (start of current transaction), with limited precision;
         see <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>current_timestamp(0)</literal>
         <returnvalue>2019-12-23 14:39:53-05</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>current_timestamp</function> ( <type>integer</type> )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         当前日期和时间 (当前事务的开始)；有限精度；参见 <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>current_timestamp(0)</literal>
         <returnvalue>2019-12-23 14:39:53-05</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>date_part</primary>
         </indexterm>
         <function>date_part</function> ( <type>text</type>, <type>timestamp</type> )
         <returnvalue>double precision</returnvalue>
        </para>
        <para>
         Get timestamp subfield (equivalent to <function>extract</function>);
         see <xref linkend="functions-datetime-extract"/>
        </para>
        <para>
         <literal>date_part('hour', timestamp '2001-02-16 20:38:40')</literal>
         <returnvalue>20</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>date_part</primary>
         </indexterm>
         <function>date_part</function> ( <type>text</type>, <type>timestamp</type> )
         <returnvalue>double precision</returnvalue>
        </para>
        <para>
         获取时间戳字段 （等同于 <function>extract</function>）；参见 <xref linkend="functions-datetime-extract"/>
        </para>
        <para>
         <literal>date_part('hour', timestamp '2001-02-16 20:38:40')</literal>
         <returnvalue>20</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>date_part</function> ( <type>text</type>, <type>interval</type> )
         <returnvalue>double precision</returnvalue>
        </para>
        <para>
         Get interval subfield (equivalent to <function>extract</function>);
         see <xref linkend="functions-datetime-extract"/>
        </para>
        <para>
         <literal>date_part('month', interval '2 years 3 months')</literal>
         <returnvalue>3</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>date_part</function> ( <type>text</type>, <type>interval</type> )
         <returnvalue>double precision</returnvalue>
        </para>
        <para>
         获取时间间隔子字段（等同于 <function>extract</function>）；参见 <xref linkend="functions-datetime-extract"/>
        </para>
        <para>
         <literal>date_part('month', interval '2 years 3 months')</literal>
         <returnvalue>3</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>date_trunc</primary>
         </indexterm>
         <function>date_trunc</function> ( <type>text</type>, <type>timestamp</type> )
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         Truncate to specified precision; see <xref linkend="functions-datetime-trunc"/>
        </para>
        <para>
         <literal>date_trunc('hour', timestamp '2001-02-16 20:38:40')</literal>
         <returnvalue>2001-02-16 20:00:00</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>date_trunc</primary>
         </indexterm>
         <function>date_trunc</function> ( <type>text</type>, <type>timestamp</type> )
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         截断到指定的精度；参见 <xref linkend="functions-datetime-trunc"/>
        </para>
        <para>
         <literal>date_trunc('hour', timestamp '2001-02-16 20:38:40')</literal>
         <returnvalue>2001-02-16 20:00:00</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>date_trunc</function> ( <type>text</type>, <type>timestamp with time zone</type>, <type>text</type> )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         Truncate to specified precision in the specified time zone; see
         <xref linkend="functions-datetime-trunc"/>
        </para>
        <para>
         <literal>date_trunc('day', timestamptz '2001-02-16 20:38:40+00', 'Australia/Sydney')</literal>
         <returnvalue>2001-02-16 13:00:00+00</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>date_trunc</function> ( <type>text</type>, <type>timestamp with time zone</type>, <type>text</type> )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         在规定的时区中截断到指定的精度；参见 <xref linkend="functions-datetime-trunc"/>
        </para>
        <para>
         <literal>date_trunc('day', timestamptz '2001-02-16 20:38:40+00', 'Australia/Sydney')</literal>
         <returnvalue>2001-02-16 13:00:00+00</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>date_trunc</function> ( <type>text</type>, <type>interval</type> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         Truncate to specified precision; see
         <xref linkend="functions-datetime-trunc"/>
        </para>
        <para>
         <literal>date_trunc('hour', interval '2 days 3 hours 40 minutes')</literal>
         <returnvalue>2 days 03:00:00</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>date_trunc</function> ( <type>text</type>, <type>interval</type> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         截断到指定的精度；参见 <xref linkend="functions-datetime-trunc"/>
        </para>
        <para>
         <literal>date_trunc('hour', interval '2 days 3 hours 40 minutes')</literal>
         <returnvalue>2 days 03:00:00</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>extract</primary>
         </indexterm>
         <function>extract</function> ( <parameter>field</parameter> <literal>from</literal> <type>timestamp</type> )
         <returnvalue>double precision</returnvalue>
        </para>
        <para>
         Get timestamp subfield; see <xref linkend="functions-datetime-extract"/>
        </para>
        <para>
         <literal>extract(hour from timestamp '2001-02-16 20:38:40')</literal>
         <returnvalue>20</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>extract</primary>
         </indexterm>
         <function>extract</function> ( <parameter>field</parameter> <literal>from</literal> <type>timestamp</type> )
         <returnvalue>double precision</returnvalue>
        </para>
        <para>
         获取时间戳子字段；参见 <xref linkend="functions-datetime-extract"/>
        </para>
        <para>
         <literal>extract(hour from timestamp '2001-02-16 20:38:40')</literal>
         <returnvalue>20</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>extract</function> ( <parameter>field</parameter> <literal>from</literal> <type>interval</type> )
         <returnvalue>double precision</returnvalue>
        </para>
        <para>
         Get interval subfield; see <xref linkend="functions-datetime-extract"/>
        </para>
        <para>
         <literal>extract(month from interval '2 years 3 months')</literal>
         <returnvalue>3</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>extract</function> ( <parameter>field</parameter> <literal>from</literal> <type>interval</type> )
         <returnvalue>double precision</returnvalue>
        </para>
        <para>
         获取时间间隔子字段；参见 <xref linkend="functions-datetime-extract"/>
        </para>
        <para>
         <literal>extract(month from interval '2 years 3 months')</literal>
         <returnvalue>3</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>isfinite</primary>
         </indexterm>
         <function>isfinite</function> ( <type>date</type> )
         <returnvalue>boolean</returnvalue>
        </para>
        <para>
         Test for finite date (not +/-infinity)
        </para>
        <para>
         <literal>isfinite(date '2001-02-16')</literal>
         <returnvalue>true</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>isfinite</primary>
         </indexterm>
         <function>isfinite</function> ( <type>date</type> )
         <returnvalue>boolean</returnvalue>
        </para>
        <para>
         测试有限日期（不是+/-无限）
        </para>
        <para>
         <literal>isfinite(date '2001-02-16')</literal>
         <returnvalue>true</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>isfinite</function> ( <type>timestamp</type> )
         <returnvalue>boolean</returnvalue>
        </para>
        <para>
         Test for finite timestamp (not +/-infinity)
        </para>
        <para>
         <literal>isfinite(timestamp 'infinity')</literal>
         <returnvalue>false</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>isfinite</function> ( <type>timestamp</type> )
         <returnvalue>boolean</returnvalue>
        </para>
        <para>
         测试有限时间戳（不是+/-无限）
        </para>
        <para>
         <literal>isfinite(timestamp 'infinity')</literal>
         <returnvalue>false</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>isfinite</function> ( <type>interval</type> )
         <returnvalue>boolean</returnvalue>
        </para>
        <para>
         Test for finite interval (currently always true)
        </para>
        <para>
         <literal>isfinite(interval '4 hours')</literal>
         <returnvalue>true</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>isfinite</function> ( <type>interval</type> )
         <returnvalue>boolean</returnvalue>
        </para>
        <para>
         测试有限时间间隔 （当前总是为真）
        </para>
        <para>
         <literal>isfinite(interval '4 hours')</literal>
         <returnvalue>true</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>justify_days</primary>
         </indexterm>
         <function>justify_days</function> ( <type>interval</type> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         Adjust interval so 30-day time periods are represented as months
        </para>
        <para>
         <literal>justify_days(interval '35 days')</literal>
         <returnvalue>1 mon 5 days</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>justify_days</primary>
         </indexterm>
         <function>justify_days</function> ( <type>interval</type> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         调整间隔，使得30天时间周期表示为月
        </para>
        <para>
         <literal>justify_days(interval '35 days')</literal>
         <returnvalue>1 mon 5 days</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>justify_hours</primary>
         </indexterm>
         <function>justify_hours</function> ( <type>interval</type> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         Adjust interval so 24-hour time periods are represented as days
        </para>
        <para>
         <literal>justify_hours(interval '27 hours')</literal>
         <returnvalue>1 day 03:00:00</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>justify_hours</primary>
         </indexterm>
         <function>justify_hours</function> ( <type>interval</type> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         调整时间间隔，使得24小时时间周期表示为日
        </para>
        <para>
         <literal>justify_hours(interval '27 hours')</literal>
         <returnvalue>1 day 03:00:00</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>justify_interval</primary>
         </indexterm>
         <function>justify_interval</function> ( <type>interval</type> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         Adjust interval using <function>justify_days</function>
         and <function>justify_hours</function>, with additional sign
         adjustments
        </para>
        <para>
         <literal>justify_interval(interval '1 mon -1 hour')</literal>
         <returnvalue>29 days 23:00:00</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>justify_interval</primary>
         </indexterm>
         <function>justify_interval</function> ( <type>interval</type> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         使用 <function>justify_days</function> 和 <function>justify_hours</function>调整时间间隔； 通过额外的符号调整
        </para>
        <para>
         <literal>justify_interval(interval '1 mon -1 hour')</literal>
         <returnvalue>29 days 23:00:00</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>localtime</primary>
         </indexterm>
         <function>localtime</function>
         <returnvalue>time</returnvalue>
        </para>
        <para>
         Current time of day;
         see <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>localtime</literal>
         <returnvalue>14:39:53.662522</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>localtime</primary>
         </indexterm>
         <function>localtime</function>
         <returnvalue>time</returnvalue>
        </para>
        <para>
         一天中当前时间；参见 <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>localtime</literal>
         <returnvalue>14:39:53.662522</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>localtime</function> ( <type>integer</type> )
         <returnvalue>time</returnvalue>
        </para>
        <para>
         Current time of day, with limited precision;
         see <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>localtime(0)</literal>
         <returnvalue>14:39:53</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>localtime</function> ( <type>integer</type> )
         <returnvalue>time</returnvalue>
        </para>
        <para>
         一天中的当前时间，有限精度；参见 <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>localtime(0)</literal>
         <returnvalue>14:39:53</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>localtimestamp</primary>
         </indexterm>
         <function>localtimestamp</function>
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         Current date and time (start of current transaction);
         see <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>localtimestamp</literal>
         <returnvalue>2019-12-23 14:39:53.662522</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>localtimestamp</primary>
         </indexterm>
         <function>localtimestamp</function>
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         当前日期和时间（当前事务的开始）；参见 <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>localtimestamp</literal>
         <returnvalue>2019-12-23 14:39:53.662522</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>localtimestamp</function> ( <type>integer</type> )
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         Current date and time (start of current
         transaction), with limited precision;
         see <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>localtimestamp(2)</literal>
         <returnvalue>2019-12-23 14:39:53.66</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <function>localtimestamp</function> ( <type>integer</type> )
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         当前日期和时间（当前事务的开始）；有限精度；参见 <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>localtimestamp(2)</literal>
         <returnvalue>2019-12-23 14:39:53.66</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>make_date</primary>
         </indexterm>
         <function>make_date</function> ( <parameter>year</parameter> <type>int</type>,
         <parameter>month</parameter> <type>int</type>,
         <parameter>day</parameter> <type>int</type> )
         <returnvalue>date</returnvalue>
        </para>
        <para>
         Create date from year, month and day fields
        </para>
        <para>
         <literal>make_date(2013, 7, 15)</literal>
         <returnvalue>2013-07-15</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>make_date</primary>
         </indexterm>
         <function>make_date</function> ( <parameter>year</parameter> <type>int</type>,
         <parameter>month</parameter> <type>int</type>,
         <parameter>day</parameter> <type>int</type> )
         <returnvalue>date</returnvalue>
        </para>
        <para>
         从年、月和日字段创建日期
        </para>
        <para>
         <literal>make_date(2013, 7, 15)</literal>
         <returnvalue>2013-07-15</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature"><indexterm>
          <primary>make_interval</primary>
         </indexterm>
         <function>make_interval</function> ( <optional> <parameter>years</parameter> <type>int</type>
         <optional>, <parameter>months</parameter> <type>int</type>
         <optional>, <parameter>weeks</parameter> <type>int</type>
         <optional>, <parameter>days</parameter> <type>int</type>
         <optional>, <parameter>hours</parameter> <type>int</type>
         <optional>, <parameter>mins</parameter> <type>int</type>
         <optional>, <parameter>secs</parameter> <type>double precision</type>
         </optional></optional></optional></optional></optional></optional></optional> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         Create interval from years, months, weeks, days, hours, minutes and
         seconds fields, each of which can default to zero
        </para>
        <para>
         <literal>make_interval(days =&gt; 10)</literal>
         <returnvalue>10 days</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature"><indexterm>
          <primary>make_interval</primary>
         </indexterm>
         <function>make_interval</function> ( <optional> <parameter>years</parameter> <type>int</type>
         <optional>, <parameter>months</parameter> <type>int</type>
         <optional>, <parameter>weeks</parameter> <type>int</type>
         <optional>, <parameter>days</parameter> <type>int</type>
         <optional>, <parameter>hours</parameter> <type>int</type>
         <optional>, <parameter>mins</parameter> <type>int</type>
         <optional>, <parameter>secs</parameter> <type>double precision</type>
         </optional></optional></optional></optional></optional></optional></optional> )
         <returnvalue>interval</returnvalue>
        </para>
        <para>
         从年、月、周、日、小时、分钟和秒字段创建时间间隔，每个字段默认为0
        </para>
        <para>
         <literal>make_interval(days =&gt; 10)</literal>
         <returnvalue>10 days</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>make_time</primary>
         </indexterm>
         <function>make_time</function> ( <parameter>hour</parameter> <type>int</type>,
         <parameter>min</parameter> <type>int</type>,
         <parameter>sec</parameter> <type>double precision</type> )
         <returnvalue>time</returnvalue>
        </para>
        <para>
         Create time from hour, minute and seconds fields
        </para>
        <para>
         <literal>make_time(8, 15, 23.5)</literal>
         <returnvalue>08:15:23.5</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>make_time</primary>
         </indexterm>
         <function>make_time</function> ( <parameter>hour</parameter> <type>int</type>,
         <parameter>min</parameter> <type>int</type>,
         <parameter>sec</parameter> <type>double precision</type> )
         <returnvalue>time</returnvalue>
        </para>
        <para>
         从小时、分钟和秒字段创建时间
        </para>
        <para>
         <literal>make_time(8, 15, 23.5)</literal>
         <returnvalue>08:15:23.5</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>make_timestamp</primary>
         </indexterm>
         <function>make_timestamp</function> ( <parameter>year</parameter> <type>int</type>,
         <parameter>month</parameter> <type>int</type>,
         <parameter>day</parameter> <type>int</type>,
         <parameter>hour</parameter> <type>int</type>,
         <parameter>min</parameter> <type>int</type>,
         <parameter>sec</parameter> <type>double precision</type> )
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         Create timestamp from year, month, day, hour, minute and seconds fields
        </para>
        <para>
         <literal>make_timestamp(2013, 7, 15, 8, 15, 23.5)</literal>
         <returnvalue>2013-07-15 08:15:23.5</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>make_timestamp</primary>
         </indexterm>
         <function>make_timestamp</function> ( <parameter>year</parameter> <type>int</type>,
         <parameter>month</parameter> <type>int</type>,
         <parameter>day</parameter> <type>int</type>,
         <parameter>hour</parameter> <type>int</type>,
         <parameter>min</parameter> <type>int</type>,
         <parameter>sec</parameter> <type>double precision</type> )
         <returnvalue>timestamp</returnvalue>
        </para>
        <para>
         从年、月、日、小时、分钟和秒字段创建时间戳
        </para>
        <para>
         <literal>make_timestamp(2013, 7, 15, 8, 15, 23.5)</literal>
         <returnvalue>2013-07-15 08:15:23.5</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>make_timestamptz</primary>
         </indexterm>
         <function>make_timestamptz</function> ( <parameter>year</parameter> <type>int</type>,
         <parameter>month</parameter> <type>int</type>,
         <parameter>day</parameter> <type>int</type>,
         <parameter>hour</parameter> <type>int</type>,
         <parameter>min</parameter> <type>int</type>,
         <parameter>sec</parameter> <type>double precision</type>
         <optional>, <parameter>timezone</parameter> <type>text</type> </optional> )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         Create timestamp with time zone from year, month, day, hour, minute
         and seconds fields; if <parameter>timezone</parameter> is not
         specified, the current time zone is used
        </para>
        <para>
         <literal>make_timestamptz(2013, 7, 15, 8, 15, 23.5)</literal>
         <returnvalue>2013-07-15 08:15:23.5+01</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>make_timestamptz</primary>
         </indexterm>
         <function>make_timestamptz</function> ( <parameter>year</parameter> <type>int</type>,
         <parameter>month</parameter> <type>int</type>,
         <parameter>day</parameter> <type>int</type>,
         <parameter>hour</parameter> <type>int</type>,
         <parameter>min</parameter> <type>int</type>,
         <parameter>sec</parameter> <type>double precision</type>
         <optional>, <parameter>timezone</parameter> <type>text</type> </optional> )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         从年，月，日，小时，分钟和秒字段结合时区创建时间戳；如果没有指定<parameter>timezone</parameter>，则使用当前时区
        </para>
        <para>
         <literal>make_timestamptz(2013, 7, 15, 8, 15, 23.5)</literal>
         <returnvalue>2013-07-15 08:15:23.5+01</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>now</primary>
         </indexterm>
         <function>now</function> ( )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         Current date and time (start of current transaction);
         see <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>now()</literal>
         <returnvalue>2019-12-23 14:39:53.662522-05</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>now</primary>
         </indexterm>
         <function>now</function> ( )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         当前日期和时间(当前事务的开始)；参见 <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>now()</literal>
         <returnvalue>2019-12-23 14:39:53.662522-05</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>statement_timestamp</primary>
         </indexterm>
         <function>statement_timestamp</function> ( )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         Current date and time (start of current statement);
         see <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>statement_timestamp()</literal>
         <returnvalue>2019-12-23 14:39:53.662522-05</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>statement_timestamp</primary>
         </indexterm>
         <function>statement_timestamp</function> ( )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         当前日期和时间(当前语句的开始)；参见 <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>statement_timestamp()</literal>
         <returnvalue>2019-12-23 14:39:53.662522-05</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>timeofday</primary>
         </indexterm>
         <function>timeofday</function> ( )
         <returnvalue>text</returnvalue>
        </para>
        <para>
         Current date and time
         (like <function>clock_timestamp</function>, but as a <type>text</type> string);
         see <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>timeofday()</literal>
         <returnvalue>Mon Dec 23 14:39:53.662522 2019 EST</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>timeofday</primary>
         </indexterm>
         <function>timeofday</function> ( )
         <returnvalue>text</returnvalue>
        </para>
        <para>
         当前的日期和时间
         （类似 <function>clock_timestamp</function>, 但是采用 <type>text</type> 字符串）；参见 <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>timeofday()</literal>
         <returnvalue>Mon Dec 23 14:39:53.662522 2019 EST</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>transaction_timestamp</primary>
         </indexterm>
         <function>transaction_timestamp</function> ( )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         Current date and time (start of current transaction);
         see <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>transaction_timestamp()</literal>
         <returnvalue>2019-12-23 14:39:53.662522-05</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>transaction_timestamp</primary>
         </indexterm>
         <function>transaction_timestamp</function> ( )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         当前日期和时间(当前事务的开始)；参见 <xref linkend="functions-datetime-current"/>
        </para>
        <para>
         <literal>transaction_timestamp()</literal>
         <returnvalue>2019-12-23 14:39:53.662522-05</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>to_timestamp</primary>
         </indexterm>
         <function>to_timestamp</function> ( <type>double precision</type> )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         Convert Unix epoch (seconds since 1970-01-01 00:00:00+00) to
         timestamp with time zone
        </para>
        <para>
         <literal>to_timestamp(1284352323)</literal>
         <returnvalue>2010-09-13 04:32:03+00</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>to_timestamp</primary>
         </indexterm>
         <function>to_timestamp</function> ( <type>double precision</type> )
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         将Unix纪元转换为带时区的时间戳(从1970-01-01 00:00:00+00开的的秒)
        </para>
        <para>
         <literal>to_timestamp(1284352323)</literal>
         <returnvalue>2010-09-13 04:32:03+00</returnvalue>
        </para></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

<!--==========================orignal english content==========================
   <para>
    <indexterm>
      <primary>OVERLAPS</primary>
    </indexterm>
    In addition to these functions, the SQL <literal>OVERLAPS</literal> operator is
    supported:
<synopsis>
(<replaceable>start1</replaceable>, <replaceable>end1</replaceable>) OVERLAPS (<replaceable>start2</replaceable>, <replaceable>end2</replaceable>)
(<replaceable>start1</replaceable>, <replaceable>length1</replaceable>) OVERLAPS (<replaceable>start2</replaceable>, <replaceable>length2</replaceable>)
</synopsis>
    This expression yields true when two time periods (defined by their
    endpoints) overlap, false when they do not overlap.  The endpoints
    can be specified as pairs of dates, times, or time stamps; or as
    a date, time, or time stamp followed by an interval.  When a pair
    of values is provided, either the start or the end can be written
    first; <literal>OVERLAPS</literal> automatically takes the earlier value
    of the pair as the start.  Each time period is considered to
    represent the half-open interval <replaceable>start</replaceable> <literal>&lt;=</literal>
    <replaceable>time</replaceable> <literal>&lt;</literal> <replaceable>end</replaceable>, unless
    <replaceable>start</replaceable> and <replaceable>end</replaceable> are equal in which case it
    represents that single time instant.  This means for instance that two
    time periods with only an endpoint in common do not overlap.
   </para>
____________________________________________________________________________-->
   <para>
    <indexterm>
      <primary>OVERLAPS</primary>
    </indexterm>
    除了这些函数以外，还支持 SQL 操作符<literal>OVERLAPS</literal>：
<synopsis>
(<replaceable>start1</replaceable>, <replaceable>end1</replaceable>) OVERLAPS (<replaceable>start2</replaceable>, <replaceable>end2</replaceable>)
(<replaceable>start1</replaceable>, <replaceable>length1</replaceable>) OVERLAPS (<replaceable>start2</replaceable>, <replaceable>length2</replaceable>)
</synopsis>
    这个表达式在两个时间域（用它们的端点定义）重叠的时候得到真，当它们不重叠时得到假。端点可以用一对日期、时间或者时间戳来指定；或者是用一个后面跟着一个间隔的日期、时间或时间戳来指定。当一对值被提供时，起点或终点都可以被写在前面，<literal>OVERLAPS</literal>会自动地把较早的值作为起点。每一个时间段被认为是表示半开的间隔<replaceable>start</replaceable> <literal>&lt;=</literal> <replaceable>time</replaceable> <literal>&lt;</literal> <replaceable>end</replaceable>，除非<replaceable>start</replaceable>和<replaceable>end</replaceable>相等，这种情况下它表示单个时间实例。例如这表示两个只有一个共同端点的时间段不重叠。
   </para>

<!--==========================orignal english content==========================
<screen>
SELECT (DATE '2001-02-16', DATE '2001-12-21') OVERLAPS
       (DATE '2001-10-30', DATE '2002-10-30');
<lineannotation>Result: </lineannotation><computeroutput>true</computeroutput>
SELECT (DATE '2001-02-16', INTERVAL '100 days') OVERLAPS
       (DATE '2001-10-30', DATE '2002-10-30');
<lineannotation>Result: </lineannotation><computeroutput>false</computeroutput>
SELECT (DATE '2001-10-29', DATE '2001-10-30') OVERLAPS
       (DATE '2001-10-30', DATE '2001-10-31');
<lineannotation>Result: </lineannotation><computeroutput>false</computeroutput>
SELECT (DATE '2001-10-30', DATE '2001-10-30') OVERLAPS
       (DATE '2001-10-30', DATE '2001-10-31');
<lineannotation>Result: </lineannotation><computeroutput>true</computeroutput>
</screen>
____________________________________________________________________________-->
<screen>
SELECT (DATE '2001-02-16', DATE '2001-12-21') OVERLAPS
       (DATE '2001-10-30', DATE '2002-10-30');
<lineannotation>结果：</lineannotation><computeroutput>true</computeroutput>
SELECT (DATE '2001-02-16', INTERVAL '100 days') OVERLAPS
       (DATE '2001-10-30', DATE '2002-10-30');
<lineannotation>结果：</lineannotation><computeroutput>false</computeroutput>
SELECT (DATE '2001-10-29', DATE '2001-10-30') OVERLAPS
       (DATE '2001-10-30', DATE '2001-10-31');
<lineannotation>结果：</lineannotation><computeroutput>false</computeroutput>
SELECT (DATE '2001-10-30', DATE '2001-10-30') OVERLAPS
       (DATE '2001-10-30', DATE '2001-10-31');
<lineannotation>结果：</lineannotation><computeroutput>true</computeroutput>
</screen>

<!--==========================orignal english content==========================
  <para>
   When adding an <type>interval</type> value to (or subtracting an
   <type>interval</type> value from) a <type>timestamp with time zone</type>
   value, the days component advances or decrements the date of the
   <type>timestamp with time zone</type> by the indicated number of days,
   keeping the time of day the same.
   Across daylight saving time changes (when the session time zone is set to a
   time zone that recognizes DST), this means <literal>interval '1 day'</literal>
   does not necessarily equal <literal>interval '24 hours'</literal>.
   For example, with the session time zone set
   to <literal>America/Denver</literal>:
<screen>
SELECT timestamp with time zone '2005-04-02 12:00:00-07' + interval '1 day';
<lineannotation>Result: </lineannotation><computeroutput>2005-04-03 12:00:00-06</computeroutput>
SELECT timestamp with time zone '2005-04-02 12:00:00-07' + interval '24 hours';
<lineannotation>Result: </lineannotation><computeroutput>2005-04-03 13:00:00-06</computeroutput>
</screen>
   This happens because an hour was skipped due to a change in daylight saving
   time at <literal>2005-04-03 02:00:00</literal> in time zone
   <literal>America/Denver</literal>.
  </para>
____________________________________________________________________________-->
  <para>
   当把一个<type>interval</type>值添加到<type>timestamp with time zone</type>上（或从中减去）时， 天的部分会按照指定的天数增加或减少<type>timestamp with time zone</type>的日期，保持一天中相同的时间。
   对于横跨夏令时的变化（当会话的时区被设置为可识别DST的时区时），这意味着<literal>interval '1 day'</literal>并 不一定等于<literal>interval '24 hours'</literal>。
   例如，当会话的时区设置为<literal>America/Denver</literal>时：
<screen>
SELECT timestamp with time zone '2005-04-02 12:00:00-07' + interval '1 day';
<lineannotation>Result: </lineannotation><computeroutput>2005-04-03 12:00:00-06</computeroutput>
SELECT timestamp with time zone '2005-04-02 12:00:00-07' + interval '24 hours';
<lineannotation>Result: </lineannotation><computeroutput>2005-04-03 13:00:00-06</computeroutput>
</screen>  
   发生此情况是因为夏令时在<literal>America/Denver</literal>时区的<literal>2005-04-03 02:00:00</literal>的时间发生更改而跳过了一个小时。
  </para>

<!--==========================orignal english content==========================
  <para>
   Note there can be ambiguity in the <literal>months</literal> field returned by
   <function>age</function> because different months have different numbers of
   days.  <productname>PostgreSQL</productname>'s approach uses the month from the
   earlier of the two dates when calculating partial months.  For example,
   <literal>age('2004-06-01', '2004-04-30')</literal> uses April to yield
   <literal>1 mon 1 day</literal>, while using May would yield <literal>1 mon 2
   days</literal> because May has 31 days, while April has only 30.
  </para>
____________________________________________________________________________-->
  <para>
   注意<function>age</function>返回的<literal>月数</literal>域可能有歧义，因为不同的月份有不同的天数。 <productname>PostgreSQL</productname>的方法是当计算部分月数时，采用两个日期中较早的月。例如：<literal>age('2004-06-01', '2004-04-30')</literal>使用4月份得到<literal>1 mon 1 day</literal>，而用5月分时会得到<literal>1 mon 2 days</literal>，因为5月有31天，而4月只有30天。
  </para>

<!--==========================orignal english content==========================
  <para>
   Subtraction of dates and timestamps can also be complex.  One conceptually
   simple way to perform subtraction is to convert each value to a number
   of seconds using <literal>EXTRACT(EPOCH FROM ...)</literal>, then subtract the
   results; this produces the
   number of <emphasis>seconds</emphasis> between the two values.  This will adjust
   for the number of days in each month, timezone changes, and daylight
   saving time adjustments.  Subtraction of date or timestamp
   values with the <quote><literal>-</literal></quote> operator
   returns the number of days (24-hours) and hours/minutes/seconds
   between the values, making the same adjustments.  The <function>age</function>
   function returns years, months, days, and hours/minutes/seconds,
   performing field-by-field subtraction and then adjusting for negative
   field values.  The following queries illustrate the differences in these
   approaches.  The sample results were produced with <literal>timezone
   = 'US/Eastern'</literal>; there is a daylight saving time change between the
   two dates used:
  </para>
____________________________________________________________________________-->
  <para>
   日期和时间戳的减法也可能会很复杂。执行减法的一种概念上很简单的方法是，使用
   <literal>EXTRACT(EPOCH FROM ...)</literal>把每个值都转换成秒数，然后执行减法，
   这样会得到两个值之间的<emphasis>秒</emphasis>数。这种方法将会适应每个月中天数、
   时区改变和夏令时调整。使用<quote><literal>-</literal></quote>操作符的日期或时间
   戳减法会返回值之间的天数（24小时）以及时/分/秒，也会做同样的调整。
   <function>age</function>函数会返回年、月、日以及时/分/秒，执行按域的减法，然后对
   负值域进行调整。下面的查询展示了这些方法的不同。例子中的结果由
   <literal>timezone = 'US/Eastern'</literal>产生，这使得两个使用的日期之间存在着夏令
   时的变化：
  </para>

<!--==========================orignal english content==========================
<screen>
SELECT EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00') -
       EXTRACT(EPOCH FROM timestamptz '2013-03-01 12:00:00');
<lineannotation>Result: </lineannotation><computeroutput>10537200</computeroutput>
SELECT (EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00') -
        EXTRACT(EPOCH FROM timestamptz '2013-03-01 12:00:00'))
        / 60 / 60 / 24;
<lineannotation>Result: </lineannotation><computeroutput>121.958333333333</computeroutput>
SELECT timestamptz '2013-07-01 12:00:00' - timestamptz '2013-03-01 12:00:00';
<lineannotation>Result: </lineannotation><computeroutput>121 days 23:00:00</computeroutput>
SELECT age(timestamptz '2013-07-01 12:00:00', timestamptz '2013-03-01 12:00:00');
<lineannotation>Result: </lineannotation><computeroutput>4 mons</computeroutput>
</screen>
____________________________________________________________________________-->
<screen>
SELECT EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00') -
       EXTRACT(EPOCH FROM timestamptz '2013-03-01 12:00:00');
<lineannotation>Result: </lineannotation><computeroutput>10537200</computeroutput>
SELECT (EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00') -
        EXTRACT(EPOCH FROM timestamptz '2013-03-01 12:00:00'))
        / 60 / 60 / 24;
<lineannotation>Result: </lineannotation><computeroutput>121.958333333333</computeroutput>
SELECT timestamptz '2013-07-01 12:00:00' - timestamptz '2013-03-01 12:00:00';
<lineannotation>Result: </lineannotation><computeroutput>121 days 23:00:00</computeroutput>
SELECT age(timestamptz '2013-07-01 12:00:00', timestamptz '2013-03-01 12:00:00');
<lineannotation>Result: </lineannotation><computeroutput>4 mons</computeroutput>
</screen>

  <sect2 id="functions-datetime-extract">
<!--==========================orignal english content==========================
   <title><function>EXTRACT</function>, <function>date_part</function></title>
____________________________________________________________________________-->
   <title><function>EXTRACT</function>, <function>date_part</function></title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>date_part</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>date_part</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>extract</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>extract</primary>
   </indexterm>

<!--==========================orignal english content==========================
<synopsis>
EXTRACT(<replaceable>field</replaceable> FROM <replaceable>source</replaceable>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
EXTRACT(<replaceable>field</replaceable> FROM <replaceable>source</replaceable>)
</synopsis>

<!--==========================orignal english content==========================
   <para>
    The <function>extract</function> function retrieves subfields
    such as year or hour from date/time values.
    <replaceable>source</replaceable> must be a value expression of
    type <type>timestamp</type>, <type>time</type>, or <type>interval</type>.
    (Expressions of type <type>date</type> are
    cast to <type>timestamp</type> and can therefore be used as
    well.)  <replaceable>field</replaceable> is an identifier or
    string that selects what field to extract from the source value.
    The <function>extract</function> function returns values of type
    <type>double precision</type>.
    The following are valid field names:

    <!-&minus; alphabetical -&minus;>
    <variablelist>
     <varlistentry>
      <term><literal>century</literal></term>
      <listitem>
       <para>
        The century
       </para>

<screen>
SELECT EXTRACT(CENTURY FROM TIMESTAMP '2000-12-16 12:21:13');
<lineannotation>Result: </lineannotation><computeroutput>20</computeroutput>
SELECT EXTRACT(CENTURY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>21</computeroutput>
</screen>

       <para>
        The first century starts at 0001-01-01 00:00:00 AD, although
        they did not know it at the time. This definition applies to all
        Gregorian calendar countries. There is no century number 0,
        you go from -1 century to 1 century.

        If you disagree with this, please write your complaint to:
        Pope, Cathedral Saint-Peter of Roma, Vatican.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>day</literal></term>
      <listitem>
       <para>
        For <type>timestamp</type> values, the day (of the month) field
        (1&ndash;31) ; for <type>interval</type> values, the number of days
       </para>

<screen>
SELECT EXTRACT(DAY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>16</computeroutput>

SELECT EXTRACT(DAY FROM INTERVAL '40 days 1 minute');
<lineannotation>Result: </lineannotation><computeroutput>40</computeroutput>
</screen>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>decade</literal></term>
      <listitem>
       <para>
        The year field divided by 10
       </para>

<screen>
SELECT EXTRACT(DECADE FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>200</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>dow</literal></term>
      <listitem>
       <para>
        The day of the week as Sunday (<literal>0</literal>) to
        Saturday (<literal>6</literal>)
       </para>

<screen>
SELECT EXTRACT(DOW FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>5</computeroutput>
</screen>
       <para>
        Note that <function>extract</function>'s day of the week numbering
        differs from that of the <function>to_char(...,
        'D')</function> function.
       </para>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>doy</literal></term>
      <listitem>
       <para>
        The day of the year (1&ndash;365/366)
       </para>

<screen>
SELECT EXTRACT(DOY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>47</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>epoch</literal></term>
      <listitem>
       <para>
        For <type>timestamp with time zone</type> values, the
        number of seconds since 1970-01-01 00:00:00 UTC (can be negative);
        for <type>date</type> and <type>timestamp</type> values, the
        number of seconds since 1970-01-01 00:00:00 local time;
        for <type>interval</type> values, the total number
        of seconds in the interval
       </para>

<screen>
SELECT EXTRACT(EPOCH FROM TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40.12-08');
<lineannotation>Result: </lineannotation><computeroutput>982384720.12</computeroutput>

SELECT EXTRACT(EPOCH FROM INTERVAL '5 days 3 hours');
<lineannotation>Result: </lineannotation><computeroutput>442800</computeroutput>
</screen>

       <para>
        You can convert an epoch value back to a time stamp
        with <function>to_timestamp</function>:
       </para>
<screen>
SELECT to_timestamp(982384720.12);
<lineannotation>Result: </lineannotation><computeroutput>2001-02-17 04:38:40.12+00</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>hour</literal></term>
      <listitem>
       <para>
        The hour field (0&ndash;23)
       </para>

<screen>
SELECT EXTRACT(HOUR FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>20</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>isodow</literal></term>
      <listitem>
       <para>
        The day of the week as Monday (<literal>1</literal>) to
        Sunday (<literal>7</literal>)
       </para>

<screen>
SELECT EXTRACT(ISODOW FROM TIMESTAMP '2001-02-18 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>7</computeroutput>
</screen>
       <para>
        This is identical to <literal>dow</literal> except for Sunday.  This
        matches the <acronym>ISO</acronym> 8601 day of the week numbering.
       </para>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>isoyear</literal></term>
      <listitem>
       <para>
        The <acronym>ISO</acronym> 8601 week-numbering year that the date
        falls in (not applicable to intervals)
       </para>

<screen>
SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-01');
<lineannotation>Result: </lineannotation><computeroutput>2005</computeroutput>
SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-02');
<lineannotation>Result: </lineannotation><computeroutput>2006</computeroutput>
</screen>

       <para>
        Each <acronym>ISO</acronym> 8601 week-numbering year begins with the
        Monday of the week containing the 4th of January, so in early
        January or late December the <acronym>ISO</acronym> year may be
        different from the Gregorian year.  See the <literal>week</literal>
        field for more information.
       </para>
       <para>
        This field is not available in PostgreSQL releases prior to 8.3.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>microseconds</literal></term>
      <listitem>
       <para>
        The seconds field, including fractional parts, multiplied by 1
        000 000;  note that this includes full seconds
       </para>

<screen>
SELECT EXTRACT(MICROSECONDS FROM TIME '17:12:28.5');
<lineannotation>Result: </lineannotation><computeroutput>28500000</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>millennium</literal></term>
      <listitem>
       <para>
        The millennium
       </para>

<screen>
SELECT EXTRACT(MILLENNIUM FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>3</computeroutput>
</screen>

       <para>
        Years in the 1900s are in the second millennium.
        The third millennium started January 1, 2001.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>milliseconds</literal></term>
      <listitem>
       <para>
        The seconds field, including fractional parts, multiplied by
        1000.  Note that this includes full seconds.
       </para>

<screen>
SELECT EXTRACT(MILLISECONDS FROM TIME '17:12:28.5');
<lineannotation>Result: </lineannotation><computeroutput>28500</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>minute</literal></term>
      <listitem>
       <para>
        The minutes field (0&ndash;59)
       </para>

<screen>
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>38</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>month</literal></term>
      <listitem>
       <para>
        For <type>timestamp</type> values, the number of the month
        within the year (1&ndash;12) ; for <type>interval</type> values,
        the number of months, modulo 12 (0&ndash;11)
       </para>

<screen>
SELECT EXTRACT(MONTH FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>2</computeroutput>

SELECT EXTRACT(MONTH FROM INTERVAL '2 years 3 months');
<lineannotation>Result: </lineannotation><computeroutput>3</computeroutput>

SELECT EXTRACT(MONTH FROM INTERVAL '2 years 13 months');
<lineannotation>Result: </lineannotation><computeroutput>1</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>quarter</literal></term>
      <listitem>
       <para>
        The quarter of the year (1&ndash;4) that the date is in
       </para>

<screen>
SELECT EXTRACT(QUARTER FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>1</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>second</literal></term>
      <listitem>
       <para>
        The seconds field, including any fractional seconds
       </para>

<screen>
SELECT EXTRACT(SECOND FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>40</computeroutput>

SELECT EXTRACT(SECOND FROM TIME '17:12:28.5');
<lineannotation>Result: </lineannotation><computeroutput>28.5</computeroutput>
</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>timezone</literal></term>
      <listitem>
       <para>
        The time zone offset from UTC, measured in seconds.  Positive values
        correspond to time zones east of UTC, negative values to
        zones west of UTC.  (Technically,
        <productname>PostgreSQL</productname> does not use UTC because
        leap seconds are not handled.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>timezone_hour</literal></term>
      <listitem>
       <para>
        The hour component of the time zone offset
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>timezone_minute</literal></term>
      <listitem>
       <para>
        The minute component of the time zone offset
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>week</literal></term>
      <listitem>
       <para>
        The number of the <acronym>ISO</acronym> 8601 week-numbering week of
        the year.  By definition, ISO weeks start on Mondays and the first
        week of a year contains January 4 of that year.  In other words, the
        first Thursday of a year is in week 1 of that year.
       </para>
       <para>
        In the ISO week-numbering system, it is possible for early-January
        dates to be part of the 52nd or 53rd week of the previous year, and for
        late-December dates to be part of the first week of the next year.
        For example, <literal>2005-01-01</literal> is part of the 53rd week of year
        2004, and <literal>2006-01-01</literal> is part of the 52nd week of year
        2005, while <literal>2012-12-31</literal> is part of the first week of 2013.
        It's recommended to use the <literal>isoyear</literal> field together with
        <literal>week</literal> to get consistent results.
       </para>

<screen>
SELECT EXTRACT(WEEK FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>7</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>year</literal></term>
      <listitem>
       <para>
        The year field.  Keep in mind there is no <literal>0 AD</literal>, so subtracting
        <literal>BC</literal> years from <literal>AD</literal> years should be done with care.
       </para>

<screen>
SELECT EXTRACT(YEAR FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>2001</computeroutput>
</screen>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
    <function>extract</function>函数从日期/时间值中抽取子域，例如年或者小时等。<replaceable>source</replaceable>必须是一个类型 <type>timestamp</type>、<type>time</type>或<type>interval</type>的值表达式（类型为<type>date</type>的表达式将被造型为 <type>timestamp</type>，并且因此也可以被同样使用）。<replaceable>field</replaceable>是一个标识符或者字符串，它指定从源值中抽取的域。<function>extract</function>函数返回类型为<type>double precision</type>的值。 下列值是有效的域名字∶

    <!-- alphabetical -->
    <variablelist>
     <varlistentry>
      <term><literal>century</literal></term>
      <listitem>
       <para>
        世纪
       </para>

<screen>
SELECT EXTRACT(CENTURY FROM TIMESTAMP '2000-12-16 12:21:13');
<lineannotation>结果：</lineannotation><computeroutput>20</computeroutput>
SELECT EXTRACT(CENTURY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>21</computeroutput>
</screen>

       <para>
        第一个世纪从 0001-01-01 00:00:00 AD 开始， 尽管那时候人们还不知道这是第一个世纪。这个定义适用于所有使用格里高利历法的国家。其中没有 0 世纪，我们直接从公元前 1 世纪到公元 1 世纪。
        
        如果你认为这个不合理，那么请把抱怨发给：罗马圣彼得教堂，梵蒂冈，教皇收。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>day</literal></term>
      <listitem>
       <para>
        对于<type>timestamp</type>值，是（月份）里的日域（1&ndash;31）；对于<type>interval</type>值，是日数
       </para>

<screen>
SELECT EXTRACT(DAY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>16</computeroutput>

SELECT EXTRACT(DAY FROM INTERVAL '40 days 1 minute');
<lineannotation>结果：</lineannotation><computeroutput>40</computeroutput>
</screen>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>decade</literal></term>
      <listitem>
       <para>
        年份域除以10
       </para>

<screen>
SELECT EXTRACT(DECADE FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>200</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>dow</literal></term>
      <listitem>
       <para>
        一周中的日，从周日（<literal>0</literal>）到周六（<literal>6</literal>）
       </para>

<screen>
SELECT EXTRACT(DOW FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>5</computeroutput>
</screen>
       <para>
        请注意，<function>extract</function>的一周中的日和<function>to_char(..., 'D')</function>函数不同。
       </para>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>doy</literal></term>
      <listitem>
       <para>
        一年的第几天（1&ndash;365/366）
       </para>

<screen>
SELECT EXTRACT(DOY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>47</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>epoch</literal></term>
      <listitem>
       <para>
        对于<type>timestamp with time zone</type>值， 是自 1970-01-01 00:00:00 UTC 以来的秒数（结果可能是负数）； 对于<type>date</type> and <type>timestamp</type>值，是自本地时间 1970-01-01 00:00:00 以来的描述；对于<type>interval</type>值，它是时间间隔的总秒数。
       </para>

<screen>
SELECT EXTRACT(EPOCH FROM TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40.12-08');
<lineannotation>结果：</lineannotation><computeroutput>982384720.12</computeroutput>

SELECT EXTRACT(EPOCH FROM INTERVAL '5 days 3 hours');
<lineannotation>结果：</lineannotation><computeroutput>442800</computeroutput>
</screen>

       <para>
        不能用<function>to_timestamp</function>把一个 epoch 值转换回成时间戳：
       </para>
<screen>
SELECT to_timestamp(982384720.12);
<lineannotation>Result: </lineannotation><computeroutput>2001-02-17 04:38:40.12+00</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>hour</literal></term>
      <listitem>
       <para>
        小时域（0&ndash;23）
       </para>

<screen>
SELECT EXTRACT(HOUR FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>20</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>isodow</literal></term>
      <listitem>
       <para>
        一周中的日，从周一（<literal>1</literal>）到周日（<literal>7</literal>）
       </para>

<screen>
SELECT EXTRACT(ISODOW FROM TIMESTAMP '2001-02-18 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>7</computeroutput>
</screen>
       <para>
        除了周日，这和<literal>dow</literal>相同。这符合<acronym>ISO</acronym> 8601 中一周中的日的编号。
       </para>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>isoyear</literal></term>
      <listitem>
       <para>
        日期所落在的<acronym>ISO</acronym> 8601 周编号的年（不适用于间隔）
       </para>

<screen>
SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-01');
<lineannotation>结果：</lineannotation><computeroutput>2005</computeroutput>
SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-02');
<lineannotation>结果：</lineannotation><computeroutput>2006</computeroutput>
</screen>

       <para>
        每一个<acronym>ISO</acronym> 8601 周编号的年都开始于包含1月4日的那一周的周一，在早的1月或迟的12月中<acronym>ISO</acronym>年可能和格里高利年不同。更多信息见<literal>week</literal>域。
       </para>
       <para>
        这个域不能用于 PostgreSQL 8.3之前的版本。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>microseconds</literal></term>
      <listitem>
       <para>
        秒域，包括小数部分，乘以 1,000,000。请注意它包括全部的秒
       </para>

<screen>
SELECT EXTRACT(MICROSECONDS FROM TIME '17:12:28.5');
<lineannotation>结果：</lineannotation><computeroutput>28500000</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>millennium</literal></term>
      <listitem>
       <para>
        千年
       </para>

<screen>
SELECT EXTRACT(MILLENNIUM FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>3</computeroutput>
</screen>

       <para>
        19xx的年份在第二个千年里。第三个千年从 2001 年 1 月 1 日开始。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>milliseconds</literal></term>
      <listitem>
       <para>
        秒域，包括小数部分，乘以 1000。请注意它包括完整的秒。
       </para>

<screen>
SELECT EXTRACT(MILLISECONDS FROM TIME '17:12:28.5');
<lineannotation>结果：</lineannotation><computeroutput>28500</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>minute</literal></term>
      <listitem>
       <para>
        分钟域（0&ndash;59）
       </para>

<screen>
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>38</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>month</literal></term>
      <listitem>
       <para>
        对于<type>timestamp</type>值，它是一年里的月份数（1&ndash;12）； 对于<type>interval</type>值，它是月的数目，然后对 12 取模（0&ndash;11）
       </para>

<screen>
SELECT EXTRACT(MONTH FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>2</computeroutput>

SELECT EXTRACT(MONTH FROM INTERVAL '2 years 3 months');
<lineannotation>结果：</lineannotation><computeroutput>3</computeroutput>

SELECT EXTRACT(MONTH FROM INTERVAL '2 years 13 months');
<lineannotation>结果：</lineannotation><computeroutput>1</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>quarter</literal></term>
      <listitem>
       <para>
        该天所在的该年的季度（1&ndash;4）
       </para>

<screen>
SELECT EXTRACT(QUARTER FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>1</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>second</literal></term>
      <listitem>
       <para>
        秒字段，包括任何小数秒。
       </para>

<screen>
SELECT EXTRACT(SECOND FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>40</computeroutput>

SELECT EXTRACT(SECOND FROM TIME '17:12:28.5');
<lineannotation>结果：</lineannotation><computeroutput>28.5</computeroutput>
</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>timezone</literal></term>
      <listitem>
       <para>
        与 UTC 的时区偏移，以秒记。正数对应 UTC 东边的时区，负数对应 UTC 西边的时区（从技术上来看，<productname>PostgreSQL</productname>不使用 UTC，因为其中不处理闰秒）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>timezone_hour</literal></term>
      <listitem>
       <para>
        时区偏移的小时部分。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>timezone_minute</literal></term>
      <listitem>
       <para>
        时区偏移的分钟部分。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>week</literal></term>
      <listitem>
       <para>
        该天在所在的<acronym>ISO</acronym> 8601 周编号的年份里是第几周。根据定义， 一年的第一周包含该年的 1月 4 日并且 ISO 周从星期一开始。换句话说，一年的第一个星期四在第一周。
       </para>
       <para>
        在 ISO 周编号系统中，早的 1 月的日期可能位于前一年的第五十二或者第五十三周，而迟的 12 月的日期可能位于下一年的第一周。例如， <literal>2005-01-01</literal>位于 2004 年的第五十三周，并且<literal>2006-01-01</literal>位于 2005 年的第五十二周，而<literal>2012-12-31</literal>位于 2013 年的第一周。我们推荐把<literal>isoyear</literal>域和<literal>week</literal>一起使用来得到一致的结果。
       </para>

<screen>
SELECT EXTRACT(WEEK FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>7</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>year</literal></term>
      <listitem>
       <para>
        年份域。要记住这里没有<literal>0 AD</literal>，所以从<literal>AD</literal>年里抽取<literal>BC</literal>年应该小心处理。
       </para>

<screen>
SELECT EXTRACT(YEAR FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>2001</computeroutput>
</screen>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     When the input value is +/-Infinity, <function>extract</function> returns
     +/-Infinity for monotonically-increasing fields (<literal>epoch</literal>,
     <literal>julian</literal>, <literal>year</literal>, <literal>isoyear</literal>,
     <literal>decade</literal>, <literal>century</literal>, and <literal>millennium</literal>).
     For other fields, NULL is returned.  <productname>PostgreSQL</productname>
     versions before 9.6 returned zero for all cases of infinite input.
    </para>
____________________________________________________________________________-->
    <para>
     当输入值为 +/-Infinity 时，<function>extract</function>对于单调增的域（<literal>epoch</literal>、<literal>julian</literal>、<literal>year</literal>、<literal>isoyear</literal>、<literal>decade</literal>、<literal>century</literal>以及<literal>millennium</literal>）返回 +/-Infinity。对于其他域返回 NULL。<productname>PostgreSQL</productname> 9.6 之前的版本对所有输入无穷的情况都返回零。
    </para>
   </note>

<!--==========================orignal english content==========================
   <para>
    The <function>extract</function> function is primarily intended
    for computational processing.  For formatting date/time values for
    display, see <xref linkend="functions-formatting"/>.
   </para>
____________________________________________________________________________-->
   <para>
    <function>extract</function>函数主要的用途是做计算性处理。对于用于显示的日期/时间值格式化，参阅<xref linkend="functions-formatting"/>。
   </para>

<!--==========================orignal english content==========================
   <para>
    The <function>date_part</function> function is modeled on the traditional
    <productname>Ingres</productname> equivalent to the
    <acronym>SQL</acronym>-standard function <function>extract</function>:
<synopsis>
date_part('<replaceable>field</replaceable>', <replaceable>source</replaceable>)
</synopsis>
    Note that here the <replaceable>field</replaceable> parameter needs to
    be a string value, not a name.  The valid field names for
    <function>date_part</function> are the same as for
    <function>extract</function>.
   </para>
____________________________________________________________________________-->
   <para>
    在传统的<productname>Ingres</productname>上建模的<function>date_part</function>函数等价于<acronym>SQL</acronym>标准函数<function>extract</function>：
<synopsis>
date_part('<replaceable>field</replaceable>', <replaceable>source</replaceable>)
</synopsis>
    请注意这里的<replaceable>field</replaceable>参数必须是一个串值，而不是一个名字。有效的<function>date_part</function>域名 和<function>extract</function>相同。
   </para>

<!--==========================orignal english content==========================
<screen>
SELECT date_part('day', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>16</computeroutput>

SELECT date_part('hour', INTERVAL '4 hours 3 minutes');
<lineannotation>Result: </lineannotation><computeroutput>4</computeroutput>
</screen>
____________________________________________________________________________-->
<screen>
SELECT date_part('day', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>16</computeroutput>

SELECT date_part('hour', INTERVAL '4 hours 3 minutes');
<lineannotation>结果：</lineannotation><computeroutput>4</computeroutput>
</screen>

  </sect2>

  <sect2 id="functions-datetime-trunc">
<!--==========================orignal english content==========================
   <title><function>date_trunc</function></title>
____________________________________________________________________________-->
   <title><function>date_trunc</function></title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>date_trunc</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>date_trunc</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    The function <function>date_trunc</function> is conceptually
    similar to the <function>trunc</function> function for numbers.
   </para>
____________________________________________________________________________-->
   <para>
    <function>date_trunc</function>函数在概念上和用于数字的<function>trunc</function>函数类似。
   </para>

<!--==========================orignal english content==========================
   <para>
<synopsis>
date_trunc(<replaceable>field</replaceable>, <replaceable>source</replaceable> [, <replaceable>time_zone</replaceable> ])
</synopsis>
    <replaceable>source</replaceable> is a value expression of type
    <type>timestamp</type>, <type>timestamp with time zone</type>,
    or <type>interval</type>.
    (Values of type <type>date</type> and
    <type>time</type> are cast automatically to <type>timestamp</type> or
    <type>interval</type>, respectively.)
    <replaceable>field</replaceable> selects to which precision to
    truncate the input value.  The return value is likewise of type
    <type>timestamp</type>, <type>timestamp with time zone</type>,
    or <type>interval</type>,
    and it has all fields that are less significant than the
    selected one set to zero (or one, for day and month).
   </para>
____________________________________________________________________________-->
   <para>
<synopsis>
date_trunc(<replaceable>field</replaceable>, <replaceable>source</replaceable> [, <replaceable>time_zone</replaceable> ])
</synopsis>
    <replaceable>source</replaceable>是类型<type>timestamp</type>或<type>interval</type>的值表达式（类型<type>date</type>和 <type>time</type>的值都分别被自动转换成<type>timestamp</type>, <type>timestamp with time zone</type>,或者<type>interval</type>）。<replaceable>field</replaceable>选择对输入值选用什么样的精度进行截断。返回的值是<type>timestamp</type>, <type>timestamp with time zone</type>,类型或者所有小于选定的 精度的域都设置为零（或者一，对于日期和月份）的<type>interval</type>。
   </para>

<!--==========================orignal english content==========================
   <para>
    Valid values for <replaceable>field</replaceable> are:
    <simplelist>
     <member><literal>microseconds</literal></member>
     <member><literal>milliseconds</literal></member>
     <member><literal>second</literal></member>
     <member><literal>minute</literal></member>
     <member><literal>hour</literal></member>
     <member><literal>day</literal></member>
     <member><literal>week</literal></member>
     <member><literal>month</literal></member>
     <member><literal>quarter</literal></member>
     <member><literal>year</literal></member>
     <member><literal>decade</literal></member>
     <member><literal>century</literal></member>
     <member><literal>millennium</literal></member>
    </simplelist>
   </para>
____________________________________________________________________________-->
   <para>
    <replaceable>field</replaceable>的有效值是∶
    <simplelist>
     <member><literal>microseconds</literal></member>
     <member><literal>milliseconds</literal></member>
     <member><literal>second</literal></member>
     <member><literal>minute</literal></member>
     <member><literal>hour</literal></member>
     <member><literal>day</literal></member>
     <member><literal>week</literal></member>
     <member><literal>month</literal></member>
     <member><literal>quarter</literal></member>
     <member><literal>year</literal></member>
     <member><literal>decade</literal></member>
     <member><literal>century</literal></member>
     <member><literal>millennium</literal></member>
    </simplelist>
   </para>

<!--==========================orignal english content==========================
   <para>
    When the input value is of type <type>timestamp with time zone</type>,
    the truncation is performed with respect to a particular time zone;
    for example, truncation to <literal>day</literal> produces a value that
    is midnight in that zone.  By default, truncation is done with respect
    to the current <xref linkend="guc-timezone"/> setting, but the
    optional <replaceable>time_zone</replaceable> argument can be provided
    to specify a different time zone.  The time zone name can be specified
    in any of the ways described in <xref linkend="datatype-timezones"/>.
   </para>
____________________________________________________________________________-->
   <para>
    当输入值的类型为<type>timestamp with time zone</type>时。截断是针对特定时区进行的。 例如，截断为<literal>day</literal>，产生的值是 是该区域的午夜。 默认情况下，截断是在以下方面进行的  到当前的<xref linkend="guc-timezone"/>设置，但在当前的 可以提供可选的<replaceable>time_zone</replaceable>参数。以指定不同的时区。 可以指定时区名称 <xref linkend="datatype-timezones"/>中描述的任何一种方式。
   </para>

<!--==========================orignal english content==========================
   <para>
    A time zone cannot be specified when processing <type>timestamp without
    time zone</type> or <type>interval</type> inputs.  These are always
    taken at face value.
   </para>
____________________________________________________________________________-->
   <para>
    当处理<type>timestamp without time zone</type> 或<type>interval</type>输入时，不能指定时区。 这些总是按表面值来处理。
   </para>

<!--==========================orignal english content==========================
   <para>
    Examples (assuming the local time zone is <literal>America/New_York</literal>):
<screen>
SELECT date_trunc('hour', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 20:00:00</computeroutput>

SELECT date_trunc('year', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>2001-01-01 00:00:00</computeroutput>

SELECT date_trunc('day', TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40+00');
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 00:00:00-05</computeroutput>

SELECT date_trunc('day', TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40+00', 'Australia/Sydney');
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 08:00:00-05</computeroutput>

SELECT date_trunc('hour', INTERVAL '3 days 02:47:33');
<lineannotation>Result: </lineannotation><computeroutput>3 days 02:00:00</computeroutput>
</screen>
   </para>
____________________________________________________________________________-->
   <para>
    示例  (假设当地时区为 <literal>America/New_York</literal>):
<screen>
SELECT date_trunc('hour', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>2001-02-16 20:00:00</computeroutput>

SELECT date_trunc('year', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>结果：</lineannotation><computeroutput>2001-01-01 00:00:00</computeroutput>

SELECT date_trunc('day', TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40+00');
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 00:00:00-05</computeroutput>

SELECT date_trunc('day', TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40+00', 'Australia/Sydney');
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 08:00:00-05</computeroutput>

SELECT date_trunc('hour', INTERVAL '3 days 02:47:33');
<lineannotation>Result: </lineannotation><computeroutput>3 days 02:00:00</computeroutput>
</screen>
   </para>
  </sect2>

  <sect2 id="functions-datetime-zoneconvert">
<!--==========================orignal english content==========================
   <title><literal>AT TIME ZONE</literal></title>
____________________________________________________________________________-->
   <title><literal>AT TIME ZONE</literal></title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>time zone</primary>
    <secondary>conversion</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>time zone</primary>
    <secondary>conversion</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>AT TIME ZONE</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>AT TIME ZONE</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    The <literal>AT TIME ZONE</literal> operator converts time
    stamp <emphasis>without</emphasis> time zone to/from
    time stamp <emphasis>with</emphasis> time zone, and
    <type>time with time zone</type> values to different time
    zones. <xref linkend="functions-datetime-zoneconvert-table"/> shows its
    variants.
   </para>
____________________________________________________________________________-->
   <para>
    <literal>AT TIME ZONE</literal>把时间戳<emphasis>without</emphasis>时区转换成时间戳<emphasis>with</emphasis>时区或者反过来，并且把<type>time with time zone</type>值转换成不同的时区。<xref linkend="functions-datetime-zoneconvert-table"/>展示了它的变体。
   </para>

    <table id="functions-datetime-zoneconvert-table">
<!--==========================orignal english content==========================
     <title><literal>AT TIME ZONE</literal> Variants</title>
____________________________________________________________________________-->
     <title><literal>AT TIME ZONE</literal>变体</title>
     <tgroup cols="1">
      <thead>
<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         Operator
        </para>
        <para>
         Description
        </para>
        <para>
         Example(s)
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         操作符
        </para>
        <para>
         描述
        </para>
        <para>
         例子
        </para></entry>
       </row>
      </thead>

      <tbody>
<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>timestamp without time zone</type> <literal>AT TIME ZONE</literal> <replaceable>zone</replaceable>
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         Converts given time stamp <emphasis>without</emphasis> time zone to
         time stamp <emphasis>with</emphasis> time zone, assuming the given
         value is in the named time zone.
        </para>
        <para>
         <literal>timestamp '2001-02-16 20:38:40' at time zone 'America/Denver'</literal>
         <returnvalue>2001-02-17 03:38:40+00</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>timestamp without time zone</type> <literal>AT TIME ZONE</literal> <replaceable>zone</replaceable>
         <returnvalue>timestamp with time zone</returnvalue>
        </para>
        <para>
         将给定的时间戳<emphasis>without</emphasis>时区转换为时间戳<emphasis>with</emphasis>时区，假设给定的值在指定的时区内。
        </para>
        <para>
         <literal>timestamp '2001-02-16 20:38:40' at time zone 'America/Denver'</literal>
         <returnvalue>2001-02-17 03:38:40+00</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>timestamp with time zone</type> <literal>AT TIME ZONE</literal> <replaceable>zone</replaceable>
         <returnvalue>timestamp without time zone</returnvalue>
        </para>
        <para>
         Converts given time stamp <emphasis>with</emphasis> time zone to
         time stamp <emphasis>without</emphasis> time zone, as the time would
         appear in that zone.
        </para>
        <para>
         <literal>timestamp with time zone '2001-02-16 20:38:40-05' at time zone 'America/Denver'</literal>
         <returnvalue>2001-02-16 18:38:40</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>timestamp with time zone</type> <literal>AT TIME ZONE</literal> <replaceable>zone</replaceable>
         <returnvalue>timestamp without time zone</returnvalue>
        </para>
        <para>
         将给定的时间戳<emphasis>with</emphasis>时区转换为时间戳<emphasis>without</emphasis>时区，因为时间将出现在该时区中
        </para>
        <para>
         <literal>timestamp with time zone '2001-02-16 20:38:40-05' at time zone 'America/Denver'</literal>
         <returnvalue>2001-02-16 18:38:40</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>time with time zone</type> <literal>AT TIME ZONE</literal> <replaceable>zone</replaceable>
         <returnvalue>time with time zone</returnvalue>
        </para>
        <para>
         Converts given time <emphasis>with</emphasis> time zone to a new time
         zone.  Since no date is supplied, this uses the currently active UTC
         offset for the named destination zone.
        </para>
        <para>
         <literal>time with time zone '05:34:17-05' at time zone 'UTC'</literal>
         <returnvalue>10:34:17+00</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>time with time zone</type> <literal>AT TIME ZONE</literal> <replaceable>zone</replaceable>
         <returnvalue>time with time zone</returnvalue>
        </para>
        <para>
         将给定的时间<emphasis>with</emphasis>时区转换为新的时区。由于没有提供日期，这将使用指定目的区域的当前活动UTC偏移量。
        </para>
        <para>
         <literal>time with time zone '05:34:17-05' at time zone 'UTC'</literal>
         <returnvalue>10:34:17+00</returnvalue>
        </para></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

<!--==========================orignal english content==========================
   <para>
    In these expressions, the desired time zone <replaceable>zone</replaceable> can be
    specified either as a text value (e.g., <literal>'America/Los_Angeles'</literal>)
    or as an interval (e.g., <literal>INTERVAL '-08:00'</literal>).
    In the text case, a time zone name can be specified in any of the ways
    described in <xref linkend="datatype-timezones"/>.
    The interval case is only useful for zones that have fixed offsets from
    UTC, so it is not very common in practice.
   </para>
____________________________________________________________________________-->
   <para>
    在这些表达式里，我们需要的时区<replaceable>zone</replaceable>可以指定为文本值（例如，<literal>'America/Los_Angeles'</literal>）或者一个间隔 （例如，<literal>INTERVAL '-08:00'</literal>）。
    在文本情况下，可用的时区名字可以用<xref linkend="datatype-timezones"/>中描述的任何方式指定。
    时间区间只适用于与UTC有固定偏移量的区域，因此在实践中并不常见。
   </para>

<!--==========================orignal english content==========================
   <para>
    Examples (assuming the current <xref linkend="guc-timezone"/> setting
    is <literal>America/Los_Angeles</literal>):
<screen>
SELECT TIMESTAMP '2001-02-16 20:38:40' AT TIME ZONE 'America/Denver';
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 19:38:40-08</computeroutput>

SELECT TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40-05' AT TIME ZONE 'America/Denver';
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 18:38:40</computeroutput>

SELECT TIMESTAMP '2001-02-16 20:38:40' AT TIME ZONE 'Asia/Tokyo' AT TIME ZONE 'America/Chicago';
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 05:38:40</computeroutput>
</screen>
    The first example adds a time zone to a value that lacks it, and
    displays the value using the current <varname>TimeZone</varname>
    setting.  The second example shifts the time stamp with time zone value
    to the specified time zone, and returns the value without a time zone.
    This allows storage and display of values different from the current
    <varname>TimeZone</varname> setting.  The third example converts
    Tokyo time to Chicago time.
   </para>
____________________________________________________________________________-->
   <para>
    例子 （假设当前 <xref linkend="guc-timezone"/> 设置为 <literal>America/Los_Angeles</literal>）:
<screen>
SELECT TIMESTAMP '2001-02-16 20:38:40' AT TIME ZONE 'America/Denver';
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 19:38:40-08</computeroutput>

SELECT TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40-05' AT TIME ZONE 'America/Denver';
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 18:38:40</computeroutput>

SELECT TIMESTAMP '2001-02-16 20:38:40' AT TIME ZONE 'Asia/Tokyo' AT TIME ZONE 'America/Chicago';
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 05:38:40</computeroutput>
</screen>
    第一个例子给缺少时区的值加上了时区，并且显示了使用当前<varname>TimeZone</varname>设置的值。
    第二个例子把带有时区值的时间戳移动到指定的时区，并且返回不带时区的值。
    这允许存储和显示不同于当前<varname>TimeZone</varname>设置的值。第三个例子把东京时间转换成芝加哥时间。
   </para>

<!--==========================orignal english content==========================
   <para>
    The function <literal><function>timezone</function>(<replaceable>zone</replaceable>,
    <replaceable>timestamp</replaceable>)</literal> is equivalent to the SQL-conforming construct
    <literal><replaceable>timestamp</replaceable> AT TIME ZONE
    <replaceable>zone</replaceable></literal>.
   </para>
____________________________________________________________________________-->
   <para>
    函数<literal><function>timezone</function>(<replaceable>zone</replaceable>, <replaceable>timestamp</replaceable>)</literal>等效于 SQL 兼容的结构<literal><replaceable>timestamp</replaceable> AT TIME ZONE <replaceable>zone</replaceable></literal>。
   </para>
  </sect2>

  <sect2 id="functions-datetime-current">
<!--==========================orignal english content==========================
   <title>Current Date/Time</title>
____________________________________________________________________________-->
   <title>当前日期/时间</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>date</primary>
    <secondary>current</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>date</primary>
    <secondary>current</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>time</primary>
    <secondary>current</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>time</primary>
    <secondary>current</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    <productname>PostgreSQL</productname> provides a number of functions
    that return values related to the current date and time.  These
    SQL-standard functions all return values based on the start time of
    the current transaction:
<synopsis>
CURRENT_DATE
CURRENT_TIME
CURRENT_TIMESTAMP
CURRENT_TIME(<replaceable>precision</replaceable>)
CURRENT_TIMESTAMP(<replaceable>precision</replaceable>)
LOCALTIME
LOCALTIMESTAMP
LOCALTIME(<replaceable>precision</replaceable>)
LOCALTIMESTAMP(<replaceable>precision</replaceable>)
</synopsis>
    </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>提供了许多返回当前日期和时间的函数。这些 SQL 标准的函数全部都按照当前事务的开始时刻返回值：
<synopsis>
CURRENT_DATE
CURRENT_TIME
CURRENT_TIMESTAMP
CURRENT_TIME(<replaceable>precision</replaceable>)
CURRENT_TIMESTAMP(<replaceable>precision</replaceable>)
LOCALTIME
LOCALTIMESTAMP
LOCALTIME(<replaceable>precision</replaceable>)
LOCALTIMESTAMP(<replaceable>precision</replaceable>)
</synopsis>
    </para>

<!--==========================orignal english content==========================
    <para>
     <function>CURRENT_TIME</function> and
     <function>CURRENT_TIMESTAMP</function> deliver values with time zone;
     <function>LOCALTIME</function> and
     <function>LOCALTIMESTAMP</function> deliver values without time zone.
    </para>
____________________________________________________________________________-->
    <para>
     <function>CURRENT_TIME</function>和<function>CURRENT_TIMESTAMP</function>传递带有时区的值；<function>LOCALTIME</function>和<function>LOCALTIMESTAMP</function>传递的值不带时区。
    </para>

<!--==========================orignal english content==========================
    <para>
     <function>CURRENT_TIME</function>,
     <function>CURRENT_TIMESTAMP</function>,
     <function>LOCALTIME</function>, and
     <function>LOCALTIMESTAMP</function>
     can optionally take
     a precision parameter, which causes the result to be rounded
     to that many fractional digits in the seconds field.  Without a precision parameter,
     the result is given to the full available precision.
    </para>
____________________________________________________________________________-->
    <para>
     <function>CURRENT_TIME</function>、<function>CURRENT_TIMESTAMP</function>、<function>LOCALTIME</function>和 <function>LOCALTIMESTAMP</function>可以有选择地接受一个精度参数， 该精度导致结果的秒域被园整为指定小数位。如果没有精度参数，结果将被给予所能得到的全部精度。
    </para>

<!--==========================orignal english content==========================
   <para>
    Some examples:
<screen>
SELECT CURRENT_TIME;
<lineannotation>Result: </lineannotation><computeroutput>14:39:53.662522-05</computeroutput>

SELECT CURRENT_DATE;
<lineannotation>Result: </lineannotation><computeroutput>2019-12-23</computeroutput>

SELECT CURRENT_TIMESTAMP;
<lineannotation>Result: </lineannotation><computeroutput>2019-12-23 14:39:53.662522-05</computeroutput>

SELECT CURRENT_TIMESTAMP(2);
<lineannotation>Result: </lineannotation><computeroutput>2019-12-23 14:39:53.66-05</computeroutput>

SELECT LOCALTIMESTAMP;
<lineannotation>Result: </lineannotation><computeroutput>2019-12-23 14:39:53.662522</computeroutput>
</screen>
   </para>
____________________________________________________________________________-->
   <para>
    一些例子：
<screen>
SELECT CURRENT_TIME;
<lineannotation>结果: </lineannotation><computeroutput>14:39:53.662522-05</computeroutput>

SELECT CURRENT_DATE;
<lineannotation>结果: </lineannotation><computeroutput>2019-12-23</computeroutput>

SELECT CURRENT_TIMESTAMP;
<lineannotation>结果: </lineannotation><computeroutput>2019-12-23 14:39:53.662522-05</computeroutput>

SELECT CURRENT_TIMESTAMP(2);
<lineannotation>结果: </lineannotation><computeroutput>2019-12-23 14:39:53.66-05</computeroutput>

SELECT LOCALTIMESTAMP;
<lineannotation>结果: </lineannotation><computeroutput>2019-12-23 14:39:53.662522</computeroutput>
</screen>
   </para>

<!--==========================orignal english content==========================
   <para>
    Since these functions return
    the start time of the current transaction, their values do not
    change during the transaction. This is considered a feature:
    the intent is to allow a single transaction to have a consistent
    notion of the <quote>current</quote> time, so that multiple
    modifications within the same transaction bear the same
    time stamp.
   </para>
____________________________________________________________________________-->
   <para>
    因为这些函数全部都按照当前事务的开始时刻返回结果，所以它们的值在事务运行的整个期间内都不改变。 我们认为这是一个特性：目的是为了允许一个事务在<quote>当前</quote>时间上有一致的概念， 这样在同一个事务里的多个修改可以保持同样的时间戳。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     Other database systems might advance these values more
     frequently.
    </para>
____________________________________________________________________________-->
    <para>
     许多其它数据库系统可能会更频繁地推进这些值。
    </para>
   </note>

<!--==========================orignal english content==========================
   <para>
    <productname>PostgreSQL</productname> also provides functions that
    return the start time of the current statement, as well as the actual
    current time at the instant the function is called.  The complete list
    of non-SQL-standard time functions is:
<synopsis>
transaction_timestamp()
statement_timestamp()
clock_timestamp()
timeofday()
now()
</synopsis>
   </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>还提供了返回当前语句的开始时间以及
    调用该函数时的实际当前时间的函数。这些非 SQL 标准的函数列表如下：
<synopsis>
transaction_timestamp()
statement_timestamp()
clock_timestamp()
timeofday()
now()
</synopsis>
   </para>

<!--==========================orignal english content==========================
   <para>
    <function>transaction_timestamp()</function> is equivalent to
    <function>CURRENT_TIMESTAMP</function>, but is named to clearly reflect
    what it returns.
    <function>statement_timestamp()</function> returns the start time of the current
    statement (more specifically, the time of receipt of the latest command
    message from the client).
    <function>statement_timestamp()</function> and <function>transaction_timestamp()</function>
    return the same value during the first command of a transaction, but might
    differ during subsequent commands.
    <function>clock_timestamp()</function> returns the actual current time, and
    therefore its value changes even within a single SQL command.
    <function>timeofday()</function> is a historical
    <productname>PostgreSQL</productname> function.  Like
    <function>clock_timestamp()</function>, it returns the actual current time,
    but as a formatted <type>text</type> string rather than a <type>timestamp
    with time zone</type> value.
    <function>now()</function> is a traditional <productname>PostgreSQL</productname>
    equivalent to <function>transaction_timestamp()</function>.
   </para>
____________________________________________________________________________-->
   <para>
    <function>transaction_timestamp()</function>等价于<function>CURRENT_TIMESTAMP</function>，但是其命名清楚地反映了它的返回值。<function>statement_timestamp()</function>返回当前语句的开始时刻（更准确的说是收到 客户端最后一条命令的时间）。<function>statement_timestamp()</function>和<function>transaction_timestamp()</function>在一个事务的第一条命令期间返回值相同，但是在随后的命令中却不一定相同。 <function>clock_timestamp()</function>返回真正的当前时间，因此它的值甚至在同一条 SQL 命令中都会变化。<function>timeofday()</function>是一个有历史原因的<productname>PostgreSQL</productname>函数。和<function>clock_timestamp()</function>相似，<function>timeofday()</function>也返回真实的当前时间，但是它的结果是一个格式化的<type>text</type>串，而不是<type>timestamp with time zone</type>值。<function>now()</function>是<productname>PostgreSQL</productname>的一个传统，等效于<function>transaction_timestamp()</function>。
   </para>

<!--==========================orignal english content==========================
   <para>
    All the date/time data types also accept the special literal value
    <literal>now</literal> to specify the current date and time (again,
    interpreted as the transaction start time).  Thus,
    the following three all return the same result:
<programlisting>
SELECT CURRENT_TIMESTAMP;
SELECT now();
SELECT TIMESTAMP 'now';  -&minus; but see tip below
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    所有日期/时间类型还接受特殊的文字值<literal>now</literal>，用于指定当前的日期和时间（重申，被解释为当前事务的开始时刻）。 因此，下面三个都返回相同的结果：
<programlisting>
SELECT CURRENT_TIMESTAMP;
SELECT now();
SELECT TIMESTAMP 'now';  -- 但请参阅下面的提示
</programlisting>
   </para>

    <tip>
<!--==========================orignal english content==========================
     <para>
      Do not use the third form when specifying a value to be evaluated later,
      for example in a <literal>DEFAULT</literal> clause for a table column.
      The system will convert <literal>now</literal>
      to a <type>timestamp</type> as soon as the constant is parsed, so that when
      the default value is needed,
      the time of the table creation would be used!  The first two
      forms will not be evaluated until the default value is used,
      because they are function calls.  Thus they will give the desired
      behavior of defaulting to the time of row insertion.
      (See also <xref linkend="datatype-datetime-special-values"/>.)
     </para>
____________________________________________________________________________-->
     <para>
      当指定以后要计算的值时，不要使用第三种形式，例如在表列的<literal>DEFAULT</literal>子句中。
      系统将在分析这个常量的时候把<literal>now</literal>转换为一个<type>timestamp</type>， 这样需要默认值时就会得到创建表的时间！而前两种形式要到实际使用缺省值的时候才被计算， 因为它们是函数调用。因此它们可以给出每次插入行的时刻。
      （参见 <xref linkend="datatype-datetime-special-values"/>。）
     </para>
    </tip>
  </sect2>

  <sect2 id="functions-datetime-delay">
<!--==========================orignal english content==========================
   <title>Delaying Execution</title>
____________________________________________________________________________-->
   <title>延时执行</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_sleep</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_sleep</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_sleep_for</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_sleep_for</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_sleep_until</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_sleep_until</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>sleep</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>sleep</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>delay</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>delay</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    The following functions are available to delay execution of the server
    process:
<synopsis>
pg_sleep ( <type>double precision</type> )
pg_sleep_for ( <type>interval</type> )
pg_sleep_until ( <type>timestamp with time zone</type> )
</synopsis>

    <function>pg_sleep</function> makes the current session's process
    sleep until the given number of seconds have
    elapsed.  Fractional-second delays can be specified.
    <function>pg_sleep_for</function> is a convenience function to
    allow the sleep time to be specified as an <type>interval</type>.
    <function>pg_sleep_until</function> is a convenience function for when
    a specific wake-up time is desired.
    For example:

<programlisting>
SELECT pg_sleep(1.5);
SELECT pg_sleep_for('5 minutes');
SELECT pg_sleep_until('tomorrow 03:00');
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    下面的这些函数可以用于让服务器进程延时执行：
<synopsis>
pg_sleep ( <type>double precision</type> )
pg_sleep_for ( <type>interval</type> )
pg_sleep_until ( <type>timestamp with time zone</type> )
</synopsis>

    <function>pg_sleep</function>使当前会话的进程休眠，直到过去给定的秒数。可以指定几分之一秒的延迟。
	<function>pg_sleep_for</function>是一个方便的函数，允许将睡眠时间指定为时间间隔。
	<function>pg_sleep_until</function>是一个方便的函数，用于需要特定的唤醒时间。例如：

<programlisting>
SELECT pg_sleep(1.5);
SELECT pg_sleep_for('5 minutes');
SELECT pg_sleep_until('tomorrow 03:00');
</programlisting>
   </para>

   <note>
<!--==========================orignal english content==========================
     <para>
      The effective resolution of the sleep interval is platform-specific;
      0.01 seconds is a common value.  The sleep delay will be at least as long
      as specified. It might be longer depending on factors such as server load.
      In particular, <function>pg_sleep_until</function> is not guaranteed to
      wake up exactly at the specified time, but it will not wake up any earlier.
     </para>
____________________________________________________________________________-->
     <para>
      有效的休眠时间间隔精度是平台相关的，通常 0.01 秒是通用值。休眠延迟将至少持续指
      定的时长， 也有可能由于服务器负荷而比指定的时间长。特别地，
      <function>pg_sleep_until</function>并不保证能刚好在指定的时刻被唤醒，但它不会
      在比指定时刻早的时候醒来。
     </para>
   </note>

   <warning>
<!--==========================orignal english content==========================
     <para>
      Make sure that your session does not hold more locks than necessary
      when calling <function>pg_sleep</function> or its variants.  Otherwise
      other sessions might have to wait for your sleeping process, slowing down
      the entire system.
     </para>
____________________________________________________________________________-->
     <para>
      请确保在调用<function>pg_sleep</function>或者其变体时，你的会话没有持有不必要
      的锁。否则其它会话可能必须等待你的休眠会话，因而减慢整个系统速度。
     </para>
   </warning>
  </sect2>

 </sect1>


 <sect1 id="functions-enum">
<!--==========================orignal english content==========================
  <title>Enum Support Functions</title>
____________________________________________________________________________-->
  <title>枚举支持函数</title>

<!--==========================orignal english content==========================
  <para>
   For enum types (described in <xref linkend="datatype-enum"/>),
   there are several functions that allow cleaner programming without
   hard-coding particular values of an enum type.
   These are listed in <xref linkend="functions-enum-table"/>. The examples
   assume an enum type created as:

<programlisting>
CREATE TYPE rainbow AS ENUM ('red', 'orange', 'yellow', 'green', 'blue', 'purple');
</programlisting>

  </para>
____________________________________________________________________________-->
  <para>
   对于枚举类型(在<xref linkend="datatype-enum"/>中描述）， 有一些函数允许更清洁的编码，而不需要为一个枚举类型硬写特定的值。它们被列在<xref linkend="functions-enum-table"/>中。本例假定一个枚举类型被创建为：

<programlisting>
CREATE TYPE rainbow AS ENUM ('red', 'orange', 'yellow', 'green', 'blue', 'purple');
</programlisting>

  </para>

  <table id="functions-enum-table">
<!--==========================orignal english content==========================
    <title>Enum Support Functions</title>
____________________________________________________________________________-->
    <title>枚举支持函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>enum_first</primary>
        </indexterm>
        <function>enum_first</function> ( <type>anyenum</type> )
        <returnvalue>anyenum</returnvalue>
       </para>
       <para>
        Returns the first value of the input enum type.
       </para>
       <para>
        <literal>enum_first(null::rainbow)</literal>
        <returnvalue>red</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>enum_first</primary>
        </indexterm>
        <function>enum_first</function> ( <type>anyenum</type> )
        <returnvalue>anyenum</returnvalue>
       </para>
       <para>
        返回输入枚举类型的第一个值。
       </para>
       <para>
        <literal>enum_first(null::rainbow)</literal>
        <returnvalue>red</returnvalue>
       </para></entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>enum_last</primary>
        </indexterm>
        <function>enum_last</function> ( <type>anyenum</type> )
        <returnvalue>anyenum</returnvalue>
       </para>
       <para>
        Returns the last value of the input enum type.
       </para>
       <para>
        <literal>enum_last(null::rainbow)</literal>
        <returnvalue>purple</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>enum_last</primary>
        </indexterm>
        <function>enum_last</function> ( <type>anyenum</type> )
        <returnvalue>anyenum</returnvalue>
       </para>
       <para>
        返回输入枚举类型的最后一个值。
       </para>
       <para>
        <literal>enum_last(null::rainbow)</literal>
        <returnvalue>purple</returnvalue>
       </para></entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>enum_range</primary>
        </indexterm>
        <function>enum_range</function> ( <type>anyenum</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        Returns all values of the input enum type in an ordered array.
       </para>
       <para>
        <literal>enum_range(null::rainbow)</literal>
        <returnvalue>{red,orange,yellow,&zwsp;green,blue,purple}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>enum_range</primary>
        </indexterm>
        <function>enum_range</function> ( <type>anyenum</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        将输入枚举类型的所有值作为一个有序的数组返回。
       </para>
       <para>
        <literal>enum_range(null::rainbow)</literal>
        <returnvalue>{red,orange,yellow,&zwsp;green,blue,purple}</returnvalue>
       </para></entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>enum_range</function> ( <type>anyenum</type>, <type>anyenum</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        Returns the range between the two given enum values, as an ordered
        array. The values must be from the same enum type. If the first
        parameter is null, the result will start with the first value of
        the enum type.
        If the second parameter is null, the result will end with the last
        value of the enum type.
       </para>
       <para>
        <literal>enum_range('orange'::rainbow, 'green'::rainbow)</literal>
        <returnvalue>{orange,yellow,green}</returnvalue>
       </para>
       <para>
        <literal>enum_range(NULL, 'green'::rainbow)</literal>
        <returnvalue>{red,orange,&zwsp;yellow,green}</returnvalue>
       </para>
       <para>
        <literal>enum_range('orange'::rainbow, NULL)</literal>
        <returnvalue>{orange,yellow,green,&zwsp;blue,purple}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>enum_range</function> ( <type>anyenum</type>, <type>anyenum</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        以一个数组返回在给定两个枚举值之间的范围。值必须来自相同的枚举类型。 
        如果第一个参数为空，其结果将从枚举类型的第一个值开始。如果第二参数为空，其结果将以枚举类型的最后一个值结束。
       </para>
       <para>
        <literal>enum_range('orange'::rainbow, 'green'::rainbow)</literal>
        <returnvalue>{orange,yellow,green}</returnvalue>
       </para>
       <para>
        <literal>enum_range(NULL, 'green'::rainbow)</literal>
        <returnvalue>{red,orange,&zwsp;yellow,green}</returnvalue>
       </para>
       <para>
        <literal>enum_range('orange'::rainbow, NULL)</literal>
        <returnvalue>{orange,yellow,green,&zwsp;blue,purple}</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    Notice that except for the two-argument form of <function>enum_range</function>,
    these functions disregard the specific value passed to them; they care
    only about its declared data type.  Either null or a specific value of
    the type can be passed, with the same result.  It is more common to
    apply these functions to a table column or function argument than to
    a hardwired type name as used in the examples.
   </para>
____________________________________________________________________________-->
   <para>
    请注意，除了双参数形式的<function>enum_range</function>外， 这些函数忽略传递给它们的具体值，它们只关心声明的数据类型。 
    空值或类型的一个特定值可以通过，并得到相同的结果。这些函数更多地被用于一个表列或函数参数，而不是一个硬写的类型名，如例子中所使用。
   </para>
 </sect1>

 <sect1 id="functions-geometry">
<!--==========================orignal english content==========================
  <title>Geometric Functions and Operators</title>
____________________________________________________________________________-->
  <title>几何函数和操作符</title>

<!--==========================orignal english content==========================
   <para>
    The geometric types <type>point</type>, <type>box</type>,
    <type>lseg</type>, <type>line</type>, <type>path</type>,
    <type>polygon</type>, and <type>circle</type> have a large set of
    native support functions and operators, shown in <xref
    linkend="functions-geometry-op-table"/>, <xref
    linkend="functions-geometry-func-table"/>, and <xref
    linkend="functions-geometry-conv-table"/>.
   </para>
____________________________________________________________________________-->
   <para>
    几何类型<type>point</type>、<type>box</type>、
    <type>lseg</type>、<type>line</type>、<type>path</type>、
    <type>polygon</type>和<type>circle</type>有一大堆本地支持函数和操作符，如<xref linkend="functions-geometry-op-table"/>、<xref linkend="functions-geometry-func-table"/>和<xref linkend="functions-geometry-conv-table"/>中所示。
   </para>

   <table id="functions-geometry-op-table">
<!--==========================orignal english content==========================
    <title>Geometric Operators</title>
____________________________________________________________________________-->
    <title>几何操作符</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Operator
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        操作符
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>+</literal> <type>point</type>
        <returnvalue><replaceable>geometric_type</replaceable></returnvalue>
       </para>
       <para>
        Adds the coordinates of the second <type>point</type> to those of each
        point of the first argument, thus performing translation.
        Available for <type>point</type>, <type>box</type>, <type>path</type>,
        <type>circle</type>.
       </para>
       <para>
        <literal>box '(1,1),(0,0)' + point '(2,0)'</literal>
        <returnvalue>(3,1),(2,0)</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>+</literal> <type>point</type>
        <returnvalue><replaceable>geometric_type</replaceable></returnvalue>
       </para>
       <para>
        将第二个<type>point</type>的坐标添加到第一个参数的每个点的坐标中，从而执行翻译。
        适用于 <type>point</type>、<type>box</type>、<type>path</type>、<type>circle</type>。
       </para>
       <para>
        <literal>box '(1,1),(0,0)' + point '(2,0)'</literal>
        <returnvalue>(3,1),(2,0)</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>path</type> <literal>+</literal> <type>path</type>
        <returnvalue>path</returnvalue>
       </para>
       <para>
        Concatenates two open paths (returns NULL if either path is closed).
       </para>
       <para>
        <literal>path '[(0,0),(1,1)]' + path '[(2,2),(3,3),(4,4)]'</literal>
        <returnvalue>[(0,0),(1,1),(2,2),(3,3),(4,4)]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>path</type> <literal>+</literal> <type>path</type>
        <returnvalue>path</returnvalue>
       </para>
       <para>
        连接两个打开的路径(如果其中一个路径是关闭的，则返回NULL)。
       </para>
       <para>
        <literal>path '[(0,0),(1,1)]' + path '[(2,2),(3,3),(4,4)]'</literal>
        <returnvalue>[(0,0),(1,1),(2,2),(3,3),(4,4)]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>-</literal> <type>point</type>
        <returnvalue><replaceable>geometric_type</replaceable></returnvalue>
       </para>
       <para>
        Subtracts the coordinates of the second <type>point</type> from those
        of each point of the first argument, thus performing translation.
        Available for <type>point</type>, <type>box</type>, <type>path</type>,
        <type>circle</type>.
       </para>
       <para>
        <literal>box '(1,1),(0,0)' - point '(2,0)'</literal>
        <returnvalue>(-1,1),(-2,0)</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>-</literal> <type>point</type>
        <returnvalue><replaceable>geometric_type</replaceable></returnvalue>
       </para>
       <para>
        从第一个参数的每个点的坐标中减去第二个<type>point</type>的坐标，从而执行翻译。
        适用于 <type>point</type>、 <type>box</type>、 <type>path</type>、<type>circle</type>。
       </para>
       <para>
        <literal>box '(1,1),(0,0)' - point '(2,0)'</literal>
        <returnvalue>(-1,1),(-2,0)</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>*</literal> <type>point</type>
        <returnvalue><replaceable>geometric_type</replaceable></returnvalue>
       </para>
       <para>
        Multiplies each point of the first argument by the second
        <type>point</type> (treating a point as being a complex number
        represented by real and imaginary parts, and performing standard
        complex multiplication).  If one interprets
        the second <type>point</type> as a vector, this is equivalent to
        scaling the object's size and distance from the origin by the length
        of the vector, and rotating it counterclockwise around the origin by
        the vector's angle from the <replaceable>x</replaceable> axis.
        Available for <type>point</type>, <type>box</type>,<footnote
        id="functions-geometry-rotation-fn"><para><quote>Rotating</quote> a
        box with these operators only moves its corner points: the box is
        still considered to have sides parallel to the axes.  Hence the box's
        size is not preserved, as a true rotation would do.</para></footnote>
        <type>path</type>, <type>circle</type>.
       </para>
       <para>
        <literal>path '((0,0),(1,0),(1,1))' * point '(3.0,0)'</literal>
        <returnvalue>((0,0),(3,0),(3,3))</returnvalue>
       </para>
       <para>
        <literal>path '((0,0),(1,0),(1,1))' * point(cosd(45), sind(45))</literal>
        <returnvalue>((0,0),&zwsp;(0.7071067811865475,0.7071067811865475),&zwsp;(0,1.414213562373095))</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>*</literal> <type>point</type>
        <returnvalue><replaceable>geometric_type</replaceable></returnvalue>
       </para>
       <para>
        将第一个参数的每个点乘上第二个point(将点视为由实部和虚部表示的复数，并执行标准的复数乘法)。
        如果将第二个<type>point</type>解释为向量，这等价于将对象的大小和到原点的距离按向量的长度缩放，并以向量与<replaceable>x</replaceable>轴的夹角绕原点逆时针旋转。
        适用于<type>point</type>, <type>box</type>,<footnote
        id="functions-geometry-rotation-fn"><para><quote>Rotating</quote> 用这些操作符“旋转”一个盒子，只会移动它的角点:这个盒子仍然被认为有平行于轴的边。
        因此，盒子的大小并没有像真正的旋转那样得到保留。</para></footnote>
        <type>path</type>, <type>circle</type>.。
       </para>
       <para>
        <literal>path '((0,0),(1,0),(1,1))' * point '(3.0,0)'</literal>
        <returnvalue>((0,0),(3,0),(3,3))</returnvalue>
       </para>
       <para>
        <literal>path '((0,0),(1,0),(1,1))' * point(cosd(45), sind(45))</literal>
        <returnvalue>((0,0),&zwsp;(0.7071067811865475,0.7071067811865475),&zwsp;(0,1.414213562373095))</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>/</literal> <type>point</type>
        <returnvalue><replaceable>geometric_type</replaceable></returnvalue>
       </para>
       <para>
        Divides each point of the first argument by the second
        <type>point</type> (treating a point as being a complex number
        represented by real and imaginary parts, and performing standard
        complex division).  If one interprets
        the second <type>point</type> as a vector, this is equivalent to
        scaling the object's size and distance from the origin down by the
        length of the vector, and rotating it clockwise around the origin by
        the vector's angle from the <replaceable>x</replaceable> axis.
        Available for <type>point</type>, <type>box</type>,<footnoteref
        linkend="functions-geometry-rotation-fn"/> <type>path</type>,
        <type>circle</type>.
       </para>
       <para>
        <literal>path '((0,0),(1,0),(1,1))' / point '(2.0,0)'</literal>
        <returnvalue>((0,0),(0.5,0),(0.5,0.5))</returnvalue>
       </para>
       <para>
        <literal>path '((0,0),(1,0),(1,1))' / point(cosd(45), sind(45))</literal>
        <returnvalue>((0,0),&zwsp;(0.7071067811865476,-0.7071067811865476),&zwsp;(1.4142135623730951,0))</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>/</literal> <type>point</type>
        <returnvalue><replaceable>geometric_type</replaceable></returnvalue>
       </para>
       <para>
        将第一个参数的每个点除以第二个<type>point</type>(将点视为由实部和虚部表示的复数，并执行标准的复数除法)。
        如果将第二个<type>point</type>解释为向量，这等价于将物体的大小和到原点的距离按向量的长度向下缩放，并以向量与<replaceable>x</replaceable>轴的夹角围绕原点顺时针旋转。
        适用于 <type>point</type>, <type>box</type>,<footnoteref linkend="functions-geometry-rotation-fn"/> <type>path</type>,<type>circle</type>。
       </para>
       <para>
        <literal>path '((0,0),(1,0),(1,1))' / point '(2.0,0)'</literal>
        <returnvalue>((0,0),(0.5,0),(0.5,0.5))</returnvalue>
       </para>
       <para>
        <literal>path '((0,0),(1,0),(1,1))' / point(cosd(45), sind(45))</literal>
        <returnvalue>((0,0),&zwsp;(0.7071067811865476,-0.7071067811865476),&zwsp;(1.4142135623730951,0))</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>@-@</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the total length.
        Available for <type>lseg</type>, <type>path</type>.
       </para>
       <para>
        <literal>@-@ path '[(0,0),(1,0),(1,1)]'</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>@-@</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算总长度。适用于 <type>lseg</type>, <type>path</type>.
       </para>
       <para>
        <literal>@-@ path '[(0,0),(1,0),(1,1)]'</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>@@</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>point</returnvalue>
       </para>
       <para>
        Computes the center point.
        Available for <type>box</type>, <type>lseg</type>, <type>path</type>,
        <type>polygon</type>, <type>circle</type>.
       </para>
       <para>
        <literal>@@ box '(2,2),(0,0)'</literal>
        <returnvalue>(1,1)</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>@@</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>point</returnvalue>
       </para>
       <para>
        计算中心点。适用于 <type>box</type>, <type>lseg</type>, <type>path</type>,
        <type>polygon</type>, <type>circle</type>.
       </para>
       <para>
        <literal>@@ box '(2,2),(0,0)'</literal>
        <returnvalue>(1,1)</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>#</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the number of points.
        Available for <type>path</type>, <type>polygon</type>.
       </para>
       <para>
        <literal># path '((1,0),(0,1),(-1,0))'</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>#</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回点的数量。适用于 <type>path</type>, <type>polygon</type>。
       </para>
       <para>
        <literal># path '((1,0),(0,1),(-1,0))'</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>#</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>point</returnvalue>
       </para>
       <para>
        Computes the point of intersection, or NULL if there is none.
        Available for <type>lseg</type>, <type>line</type>.
       </para>
       <para>
        <literal>lseg '[(0,0),(1,1)]' # lseg '[(1,0),(0,1)]'</literal>
        <returnvalue>(0.5,0.5)</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>#</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>point</returnvalue>
       </para>
       <para>
        计算交点，如果没有则为NULL。适用于 <type>lseg</type>, <type>line</type>。
       </para>
       <para>
        <literal>lseg '[(0,0),(1,1)]' # lseg '[(1,0),(0,1)]'</literal>
        <returnvalue>(0.5,0.5)</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>box</type> <literal>#</literal> <type>box</type>
        <returnvalue>box</returnvalue>
       </para>
       <para>
        Computes the intersection of two boxes, or NULL if there is none.
       </para>
       <para>
        <literal>box '(2,2),(-1,-1)' # box '(1,1),(-2,-2)'</literal>
        <returnvalue>(1,1),(-1,-1)</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>box</type> <literal>#</literal> <type>box</type>
        <returnvalue>box</returnvalue>
       </para>
       <para>
        计算两个方框的交集，如果没有则为NULL。
       </para>
       <para>
        <literal>box '(2,2),(-1,-1)' # box '(1,1),(-2,-2)'</literal>
        <returnvalue>(1,1),(-1,-1)</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>##</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>point</returnvalue>
       </para>
       <para>
        Computes the closest point to the first object on the second object.
        Available for these pairs of types:
        (<type>point</type>, <type>box</type>),
        (<type>point</type>, <type>lseg</type>),
        (<type>point</type>, <type>line</type>),
        (<type>lseg</type>, <type>box</type>),
        (<type>lseg</type>, <type>lseg</type>),
        (<type>lseg</type>, <type>line</type>),
        (<type>line</type>, <type>box</type>),
        (<type>line</type>, <type>lseg</type>).
       </para>
       <para>
        <literal>point '(0,0)' ## lseg '[(2,0),(0,2)]'</literal>
        <returnvalue>(1,1)</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>##</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>point</returnvalue>
       </para>
       <para>
        计算第二个对象上离第一个对象最近的点。适用于这些类型对：
        (<type>point</type>, <type>box</type>),
        (<type>point</type>, <type>lseg</type>),
        (<type>point</type>, <type>line</type>),
        (<type>lseg</type>, <type>box</type>),
        (<type>lseg</type>, <type>lseg</type>),
        (<type>lseg</type>, <type>line</type>),
        (<type>line</type>, <type>box</type>),
        (<type>line</type>, <type>lseg</type>).
       </para>
       <para>
        <literal>point '(0,0)' ## lseg '[(2,0),(0,2)]'</literal>
        <returnvalue>(1,1)</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&lt;-&gt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the distance between the objects.
        Available for all seven geometric types, for all combinations
        of <type>point</type> with another geometric type, and for
        these additional pairs of types:
        (<type>box</type>, <type>lseg</type>),
        (<type>box</type>, <type>line</type>),
        (<type>lseg</type>, <type>line</type>),
        (<type>polygon</type>, <type>circle</type>)
        (and the commutator cases).
       </para>
       <para>
        <literal>circle '&lt;(0,0),1&gt;' &lt;-&gt; circle '&lt;(5,0),1&gt;'</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&lt;-&gt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算对象之间的距离。适用于所有七种几何类型，适用于<type>point</type>与另一种几何类型的所有组合，以及这些额外的类型对:
        (<type>box</type>, <type>lseg</type>),
        (<type>box</type>, <type>line</type>),
        (<type>lseg</type>, <type>line</type>),
        (<type>polygon</type>, <type>circle</type>)
        (以及易子情况下).
       </para>
       <para>
        <literal>circle '&lt;(0,0),1&gt;' &lt;-&gt; circle '&lt;(5,0),1&gt;'</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>@&gt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does first object contain second?
        Available for these pairs of types:
        (<literal>box</literal>, <literal>point</literal>),
        (<literal>box</literal>, <literal>box</literal>),
        (<literal>path</literal>, <literal>point</literal>),
        (<literal>polygon</literal>, <literal>point</literal>),
        (<literal>polygon</literal>, <literal>polygon</literal>),
        (<literal>circle</literal>, <literal>point</literal>),
        (<literal>circle</literal>, <literal>circle</literal>).
       </para>
       <para>
        <literal>circle '&lt;(0,0),2&gt;' @&gt; point '(1,1)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>@&gt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个对象包含第二个对象吗? 适用于这些类型对：
        (<literal>box</literal>, <literal>point</literal>),
        (<literal>box</literal>, <literal>box</literal>),
        (<literal>path</literal>, <literal>point</literal>),
        (<literal>polygon</literal>, <literal>point</literal>),
        (<literal>polygon</literal>, <literal>polygon</literal>),
        (<literal>circle</literal>, <literal>point</literal>),
        (<literal>circle</literal>, <literal>circle</literal>).
       </para>
       <para>
        <literal>circle '&lt;(0,0),2&gt;' @&gt; point '(1,1)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&lt;@</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is first object contained in or on second?
        Available for these pairs of types:
        (<literal>point</literal>, <literal>box</literal>),
        (<literal>point</literal>, <literal>lseg</literal>),
        (<literal>point</literal>, <literal>line</literal>),
        (<literal>point</literal>, <literal>path</literal>),
        (<literal>point</literal>, <literal>polygon</literal>),
        (<literal>point</literal>, <literal>circle</literal>),
        (<literal>box</literal>, <literal>box</literal>),
        (<literal>lseg</literal>, <literal>box</literal>),
        (<literal>lseg</literal>, <literal>line</literal>),
        (<literal>polygon</literal>, <literal>polygon</literal>),
        (<literal>circle</literal>, <literal>circle</literal>).
       </para>
       <para>
        <literal>point '(1,1)' &lt;@ circle '&lt;(0,0),2&gt;'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&lt;@</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个对象包含在第二个对象之中还是在第二个对象之上? 适用于这些类型对：
        (<literal>point</literal>, <literal>box</literal>),
        (<literal>point</literal>, <literal>lseg</literal>),
        (<literal>point</literal>, <literal>line</literal>),
        (<literal>point</literal>, <literal>path</literal>),
        (<literal>point</literal>, <literal>polygon</literal>),
        (<literal>point</literal>, <literal>circle</literal>),
        (<literal>box</literal>, <literal>box</literal>),
        (<literal>lseg</literal>, <literal>box</literal>),
        (<literal>lseg</literal>, <literal>line</literal>),
        (<literal>polygon</literal>, <literal>polygon</literal>),
        (<literal>circle</literal>, <literal>circle</literal>).
       </para>
       <para>
        <literal>point '(1,1)' &lt;@ circle '&lt;(0,0),2&gt;'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&amp;&amp;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Do these objects overlap?  (One point in common makes this true.)
        Available for <type>box</type>, <type>polygon</type>,
        <type>circle</type>.
       </para>
       <para>
        <literal>box '(1,1),(0,0)' &amp;&amp; box '(2,2),(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&amp;&amp;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        这些对象有重叠吗?(一个共同点使之为真。)
        适用于 <type>box</type>、<type>polygon</type>、<type>circle</type>。
       </para>
       <para>
        <literal>box '(1,1),(0,0)' &amp;&amp; box '(2,2),(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&lt;&lt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is first object strictly left of second?
        Available for <type>point</type>, <type>box</type>,
        <type>polygon</type>, <type>circle</type>.
       </para>
       <para>
        <literal>circle '&lt;(0,0),1&gt;' &lt;&lt; circle '&lt;(5,0),1&gt;'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&lt;&lt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个对象完全位于第二个对象的左边吗?
        适用于 <type>point</type>, <type>box</type>, <type>polygon</type>, <type>circle</type>。
       </para>
       <para>
        <literal>circle '&lt;(0,0),1&gt;' &lt;&lt; circle '&lt;(5,0),1&gt;'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&gt;&gt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is first object strictly right of second?
        Available for <type>point</type>, <type>box</type>,
        <type>polygon</type>, <type>circle</type>.
       </para>
       <para>
        <literal>circle '&lt;(5,0),1&gt;' &gt;&gt; circle '&lt;(0,0),1&gt;'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&gt;&gt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个对象完全位于第二个对象的右边吗?
        适用于 <type>point</type>, <type>box</type>, <type>polygon</type>, <type>circle</type>。
       </para>
       <para>
        <literal>circle '&lt;(5,0),1&gt;' &gt;&gt; circle '&lt;(0,0),1&gt;'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&amp;&lt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does first object not extend to the right of second?
        Available for <type>box</type>, <type>polygon</type>,
        <type>circle</type>.
       </para>
       <para>
        <literal>box '(1,1),(0,0)' &amp;&lt; box '(2,2),(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&amp;&lt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个对象没有延伸到第二个对象的右侧吗?
        适用于 <type>box</type>, <type>polygon</type>, <type>circle</type>。
       </para>
       <para>
        <literal>box '(1,1),(0,0)' &amp;&lt; box '(2,2),(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&amp;&gt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does first object not extend to the left of second?
        Available for <type>box</type>, <type>polygon</type>,
        <type>circle</type>.
       </para>
       <para>
        <literal>box '(3,3),(0,0)' &amp;&gt; box '(2,2),(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&amp;&gt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个对象没有延伸到第二个对象的左侧吗?
        适用于 <type>box</type>, <type>polygon</type>, <type>circle</type>。
       </para>
       <para>
        <literal>box '(3,3),(0,0)' &amp;&gt; box '(2,2),(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&lt;&lt;|</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is first object strictly below second?
        Available for <type>box</type>, <type>polygon</type>,
        <type>circle</type>.
       </para>
       <para>
        <literal>box '(3,3),(0,0)' &lt;&lt;| box '(5,5),(3,4)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&lt;&lt;|</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个对象是否确定位于第二个对象下面?
        适用于 <type>box</type>, <type>polygon</type>, <type>circle</type>。
       </para>
       <para>
        <literal>box '(3,3),(0,0)' &lt;&lt;| box '(5,5),(3,4)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>|&gt;&gt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is first object strictly above second?
        Available for <type>box</type>, <type>polygon</type>,
        <type>circle</type>.
       </para>
       <para>
        <literal>box '(5,5),(3,4)' |&gt;&gt; box '(3,3),(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>|&gt;&gt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个对象是否确定位于第二个对象上面?
        适用于 <type>box</type>, <type>polygon</type>, <type>circle</type>.
       </para>
       <para>
        <literal>box '(5,5),(3,4)' |&gt;&gt; box '(3,3),(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&amp;&lt;|</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does first object not extend above second?
        Available for <type>box</type>, <type>polygon</type>,
        <type>circle</type>.
       </para>
       <para>
        <literal>box '(1,1),(0,0)' &amp;&lt;| box '(2,2),(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>&amp;&lt;|</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个对象是否没有扩展到第二个对象上面?
        适用于 <type>box</type>, <type>polygon</type>, <type>circle</type>.
       </para>
       <para>
        <literal>box '(1,1),(0,0)' &amp;&lt;| box '(2,2),(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>|&amp;&gt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does first object not extend below second?
        Available for <type>box</type>, <type>polygon</type>,
        <type>circle</type>.
       </para>
       <para>
        <literal>box '(3,3),(0,0)' |&amp;&gt; box '(2,2),(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>|&amp;&gt;</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个对象是否没有扩展到第二个对象下面?
        适用于 <type>box</type>, <type>polygon</type>, <type>circle</type>.
       </para>
       <para>
        <literal>box '(3,3),(0,0)' |&amp;&gt; box '(2,2),(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>box</type> <literal>&lt;^</literal> <type>box</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is first object below second (allows edges to touch)?
       </para>
       <para>
        <literal>box '((1,1),(0,0))' &lt;^ box '((2,2),(1,1))'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>box</type> <literal>&lt;^</literal> <type>box</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个对象是否位于第二个对象下面(允许边缘相切)?
       </para>
       <para>
        <literal>box '((1,1),(0,0))' &lt;^ box '((2,2),(1,1))'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>point</type> <literal>&lt;^</literal> <type>point</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is first object strictly below second?
        (This operator is misnamed; it should be <literal>&lt;&lt;|</literal>.)
       </para>
       <para>
        <literal>point '(1,0)' &lt;^ point '(1,1)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>point</type> <literal>&lt;^</literal> <type>point</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个对象是否确定位于第二个对象下面？
        (这个操作符命名错误; 它应该是 <literal>&lt;&lt;|</literal>.)
       </para>
       <para>
        <literal>point '(1,0)' &lt;^ point '(1,1)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>box</type> <literal>&gt;^</literal> <type>box</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is first object above second (allows edges to touch)?
       </para>
       <para>
        <literal>box '((2,2),(1,1))' &gt;^ box '((1,1),(0,0))'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>box</type> <literal>&gt;^</literal> <type>box</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个对象是否位于第二个对象上面(允许边缘相切)?
       </para>
       <para>
        <literal>box '((2,2),(1,1))' &gt;^ box '((1,1),(0,0))'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>point</type> <literal>&gt;^</literal> <type>point</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is first object strictly above second?
        (This operator is misnamed; it should be <literal>|&gt;&gt;</literal>.)
       </para>
       <para>
        <literal>point '(1,1)' &gt;^ point '(1,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>point</type> <literal>&gt;^</literal> <type>point</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个对象是否确定位于第二个对象上面？
        (这个操作符命名错误; 它应该是 <literal>|&gt;&gt;</literal>.)
       </para>
       <para>
        <literal>point '(1,1)' &gt;^ point '(1,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>?#</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Do these objects intersect?
        Available for these pairs of types:
        (<type>box</type>, <type>box</type>),
        (<type>lseg</type>, <type>box</type>),
        (<type>lseg</type>, <type>lseg</type>),
        (<type>lseg</type>, <type>line</type>),
        (<type>line</type>, <type>box</type>),
        (<type>line</type>, <type>line</type>),
        (<type>path</type>, <type>path</type>).
       </para>
       <para>
        <literal>lseg '[(-1,0),(1,0)]' ?# box '(2,2),(-2,-2)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>?#</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        这些对象是否相交? 适用于这些类型对:
        (<type>box</type>, <type>box</type>),
        (<type>lseg</type>, <type>box</type>),
        (<type>lseg</type>, <type>lseg</type>),
        (<type>lseg</type>, <type>line</type>),
        (<type>line</type>, <type>box</type>),
        (<type>line</type>, <type>line</type>),
        (<type>path</type>, <type>path</type>).
       </para>
       <para>
        <literal>lseg '[(-1,0),(1,0)]' ?# box '(2,2),(-2,-2)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>?-</literal> <type>line</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <literal>?-</literal> <type>lseg</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is line horizontal?
       </para>
       <para>
        <literal>?- lseg '[(-1,0),(1,0)]'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>?-</literal> <type>line</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <literal>?-</literal> <type>lseg</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        线是水平的?
       </para>
       <para>
        <literal>?- lseg '[(-1,0),(1,0)]'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>point</type> <literal>?-</literal> <type>point</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Are points horizontally aligned (that is, have same y coordinate)?
       </para>
       <para>
        <literal>point '(1,0)' ?- point '(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>point</type> <literal>?-</literal> <type>point</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        点是否水平对齐(即具有相同的y坐标)?
       </para>
       <para>
        <literal>point '(1,0)' ?- point '(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>?|</literal> <type>line</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <literal>?|</literal> <type>lseg</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is line vertical?
       </para>
       <para>
        <literal>?| lseg '[(-1,0),(1,0)]'</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>?|</literal> <type>line</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <literal>?|</literal> <type>lseg</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        线是纵向的的？
       </para>
       <para>
        <literal>?| lseg '[(-1,0),(1,0)]'</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>point</type> <literal>?|</literal> <type>point</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Are points vertically aligned (that is, have same x coordinate)?
       </para>
       <para>
        <literal>point '(0,1)' ?| point '(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>point</type> <literal>?|</literal> <type>point</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        点是否垂直对齐(即具有相同的x坐标)?
       </para>
       <para>
        <literal>point '(0,1)' ?| point '(0,0)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>line</type> <literal>?-|</literal> <type>line</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <type>lseg</type> <literal>?-|</literal> <type>lseg</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Are lines perpendicular?
       </para>
       <para>
        <literal>lseg '[(0,0),(0,1)]' ?-| lseg '[(0,0),(1,0)]'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>line</type> <literal>?-|</literal> <type>line</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <type>lseg</type> <literal>?-|</literal> <type>lseg</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        线是垂直的？
       </para>
       <para>
        <literal>lseg '[(0,0),(0,1)]' ?-| lseg '[(0,0),(1,0)]'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>line</type> <literal>?||</literal> <type>line</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <type>lseg</type> <literal>?||</literal> <type>lseg</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Are lines parallel?
       </para>
       <para>
        <literal>lseg '[(-1,0),(1,0)]' ?|| lseg '[(-1,2),(1,2)]'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>line</type> <literal>?||</literal> <type>line</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <type>lseg</type> <literal>?||</literal> <type>lseg</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        线是平行的？
       </para>
       <para>
        <literal>lseg '[(-1,0),(1,0)]' ?|| lseg '[(-1,2),(1,2)]'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>~=</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Are these objects the same?
        Available for <type>point</type>, <type>box</type>,
        <type>polygon</type>, <type>circle</type>.
       </para>
       <para>
        <literal>polygon '((0,0),(1,1))' ~= polygon '((1,1),(0,0))'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>geometric_type</replaceable> <literal>~=</literal> <replaceable>geometric_type</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        这些对象是相同的吗?
        适用于 <type>point</type>, <type>box</type>, <type>polygon</type>, <type>circle</type>.
       </para>
       <para>
        <literal>polygon '((0,0),(1,1))' ~= polygon '((1,1),(0,0))'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <caution>
<!--==========================orignal english content==========================
    <para>
     Note that the <quote>same as</quote> operator, <literal>~=</literal>,
     represents the usual notion of equality for the <type>point</type>,
     <type>box</type>, <type>polygon</type>, and <type>circle</type> types.
     Some of the geometric types also have an <literal>=</literal> operator, but
     <literal>=</literal> compares for equal <emphasis>areas</emphasis> only.
     The other scalar comparison operators (<literal>&lt;=</literal> and so
     on), where available for these types, likewise compare areas.
    </para>
____________________________________________________________________________-->
    <para>
     请注意<quote>same as</quote>操作符（<literal>~=</literal>），表示<type>point</type>、<type>box</type>、<type>polygon</type>和<type>circle</type>类型的一般相等概念。
     这些类型中的某些还有一个<literal>=</literal>操作符，但是<literal>=</literal>只比较相同的<emphasis>面积</emphasis>。
     其它的标量比较操作符 （<literal>&lt;=</literal>等等），在这些类型可用的地方，同样比较区域。
    </para>
   </caution>

   <note>
<!--==========================orignal english content==========================
    <para>
     Before <productname>PostgreSQL</productname> 8.2, the containment
     operators <literal>@&gt;</literal> and <literal>&lt;@</literal> were respectively
     called <literal>~</literal> and <literal>@</literal>.  These names are still
     available, but are deprecated and will eventually be removed.
    </para>
____________________________________________________________________________-->
    <para>
     在<productname>PostgreSQL</productname>之前，包含操作符<literal>@&gt;</literal>和<literal>&lt;@</literal>被分别称为<literal>~</literal>和<literal>@</literal>。 这些名字仍然可以使用，但是已被废除并且最终将被移除。
    </para>
   </note>

   <table id="functions-geometry-func-table">
<!--==========================orignal english content==========================
    <title>Geometric Functions</title>
____________________________________________________________________________-->
    <title>几何函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>area</primary>
        </indexterm>
        <function>area</function> ( <replaceable>geometric_type</replaceable> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes area.
        Available for <type>box</type>, <type>path</type>, <type>circle</type>.
        A <type>path</type> input must be closed, else NULL is returned.
        Also, if the <type>path</type> is self-intersecting, the result may be
        meaningless.
       </para>
       <para>
        <literal>area(box '(2,2),(0,0)')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>area</primary>
        </indexterm>
        <function>area</function> ( <replaceable>geometric_type</replaceable> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算面积。适用于 <type>box</type>, <type>path</type>, <type>circle</type>。
        <type>path</type> 输入必须封闭，否则返回NULL。同样，如果 <type>path</type> 是自交叉的，结果可能是没有意义的。
       </para>
       <para>
        <literal>area(box '(2,2),(0,0)')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>center</primary>
        </indexterm>
        <function>center</function> ( <replaceable>geometric_type</replaceable> )
        <returnvalue>point</returnvalue>
       </para>
       <para>
        Computes center point.
        Available for <type>box</type>, <type>circle</type>.
       </para>
       <para>
        <literal>center(box '(1,2),(0,0)')</literal>
        <returnvalue>(0.5,1)</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>center</primary>
        </indexterm>
        <function>center</function> ( <replaceable>geometric_type</replaceable> )
        <returnvalue>point</returnvalue>
       </para>
       <para>
        计算中心点。适用于 <type>box</type>, <type>circle</type>。
       </para>
       <para>
        <literal>center(box '(1,2),(0,0)')</literal>
        <returnvalue>(0.5,1)</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>diagonal</primary>
        </indexterm>
        <function>diagonal</function> ( <type>box</type> )
        <returnvalue>lseg</returnvalue>
       </para>
       <para>
        Extracts box's diagonal as a line segment
        (same as <function>lseg(box)</function>).
       </para>
       <para>
        <literal>diagonal(box '(1,2),(0,0)')</literal>
        <returnvalue>[(1,2),(0,0)]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>diagonal</primary>
        </indexterm>
        <function>diagonal</function> ( <type>box</type> )
        <returnvalue>lseg</returnvalue>
       </para>
       <para>
        提取框的对角线作为线段（与 <function>lseg(box)</function>相同）。
       </para>
       <para>
        <literal>diagonal(box '(1,2),(0,0)')</literal>
        <returnvalue>[(1,2),(0,0)]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>diameter</primary>
        </indexterm>
        <function>diameter</function> ( <type>circle</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes diameter of circle.
       </para>
       <para>
        <literal>diameter(circle '&lt;(0,0),2&gt;')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>diameter</primary>
        </indexterm>
        <function>diameter</function> ( <type>circle</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算圆的直径。
       </para>
       <para>
        <literal>diameter(circle '&lt;(0,0),2&gt;')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>height</primary>
        </indexterm>
        <function>height</function> ( <type>box</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes vertical size of box.
       </para>
       <para>
        <literal>height(box '(1,2),(0,0)')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>height</primary>
        </indexterm>
        <function>height</function> ( <type>box</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算框的垂直尺寸。
       </para>
       <para>
        <literal>height(box '(1,2),(0,0)')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>isclosed</primary>
        </indexterm>
        <function>isclosed</function> ( <type>path</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is path closed?
       </para>
       <para>
        <literal>isclosed(path '((0,0),(1,1),(2,0))')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>isclosed</primary>
        </indexterm>
        <function>isclosed</function> ( <type>path</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        路径是否封闭?
       </para>
       <para>
        <literal>isclosed(path '((0,0),(1,1),(2,0))')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>isopen</primary>
        </indexterm>
        <function>isopen</function> ( <type>path</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is path open?
       </para>
       <para>
        <literal>isopen(path '[(0,0),(1,1),(2,0)]')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>isopen</primary>
        </indexterm>
        <function>isopen</function> ( <type>path</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        路径是否开放?
       </para>
       <para>
        <literal>isopen(path '[(0,0),(1,1),(2,0)]')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>length</primary>
        </indexterm>
        <function>length</function> ( <replaceable>geometric_type</replaceable> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the total length.
        Available for <type>lseg</type>, <type>path</type>.
       </para>
       <para>
        <literal>length(path '((-1,0),(1,0))')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>length</primary>
        </indexterm>
        <function>length</function> ( <replaceable>geometric_type</replaceable> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算总长度。适用于 <type>lseg</type>, <type>path</type>。
       </para>
       <para>
        <literal>length(path '((-1,0),(1,0))')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>npoints</primary>
        </indexterm>
        <function>npoints</function> ( <replaceable>geometric_type</replaceable> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the number of points.
        Available for <type>path</type>, <type>polygon</type>.
       </para>
       <para>
        <literal>npoints(path '[(0,0),(1,1),(2,0)]')</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>npoints</primary>
        </indexterm>
        <function>npoints</function> ( <replaceable>geometric_type</replaceable> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回点的数量。适用于 <type>path</type>, <type>polygon</type>。
       </para>
       <para>
        <literal>npoints(path '[(0,0),(1,1),(2,0)]')</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pclose</primary>
        </indexterm>
        <function>pclose</function> ( <type>path</type> )
        <returnvalue>path</returnvalue>
       </para>
       <para>
        Converts path to closed form.
       </para>
       <para>
        <literal>pclose(path '[(0,0),(1,1),(2,0)]')</literal>
        <returnvalue>((0,0),(1,1),(2,0))</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pclose</primary>
        </indexterm>
        <function>pclose</function> ( <type>path</type> )
        <returnvalue>path</returnvalue>
       </para>
       <para>
        将路径转换为封闭形式。
       </para>
       <para>
        <literal>pclose(path '[(0,0),(1,1),(2,0)]')</literal>
        <returnvalue>((0,0),(1,1),(2,0))</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>popen</primary>
        </indexterm>
        <function>popen</function> ( <type>path</type> )
        <returnvalue>path</returnvalue>
       </para>
       <para>
        Converts path to open form.
       </para>
       <para>
        <literal>popen(path '((0,0),(1,1),(2,0))')</literal>
        <returnvalue>[(0,0),(1,1),(2,0)]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>popen</primary>
        </indexterm>
        <function>popen</function> ( <type>path</type> )
        <returnvalue>path</returnvalue>
       </para>
       <para>
        将路径转换为开放形式。
       </para>
       <para>
        <literal>popen(path '((0,0),(1,1),(2,0))')</literal>
        <returnvalue>[(0,0),(1,1),(2,0)]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>radius</primary>
        </indexterm>
        <function>radius</function> ( <type>circle</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes radius of circle.
       </para>
       <para>
        <literal>radius(circle '&lt;(0,0),2&gt;')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>radius</primary>
        </indexterm>
        <function>radius</function> ( <type>circle</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算圆的半径。
       </para>
       <para>
        <literal>radius(circle '&lt;(0,0),2&gt;')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>slope</primary>
        </indexterm>
        <function>slope</function> ( <type>point</type>, <type>point</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes slope of a line drawn through the two points.
       </para>
       <para>
        <literal>slope(point '(0,0)', point '(2,1)')</literal>
        <returnvalue>0.5</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>slope</primary>
        </indexterm>
        <function>slope</function> ( <type>point</type>, <type>point</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算通过两点所画直线的斜率。
       </para>
       <para>
        <literal>slope(point '(0,0)', point '(2,1)')</literal>
        <returnvalue>0.5</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>width</primary>
        </indexterm>
        <function>width</function> ( <type>box</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes horizontal size of box.
       </para>
       <para>
        <literal>width(box '(1,2),(0,0)')</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>width</primary>
        </indexterm>
        <function>width</function> ( <type>box</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算框的水平大小。
       </para>
       <para>
        <literal>width(box '(1,2),(0,0)')</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <table id="functions-geometry-conv-table">
<!--==========================orignal english content==========================
    <title>Geometric Type Conversion Functions</title>
____________________________________________________________________________-->
    <title>几何类型转换函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>
     <tbody>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>box</primary>
        </indexterm>
        <function>box</function> ( <type>circle</type> )
        <returnvalue>box</returnvalue>
       </para>
       <para>
        Computes box inscribed within the circle.
       </para>
       <para>
        <literal>box(circle '&lt;(0,0),2&gt;')</literal>
        <returnvalue>(1.414213562373095,1.414213562373095),&zwsp;(-1.414213562373095,-1.414213562373095)</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>box</primary>
        </indexterm>
        <function>box</function> ( <type>circle</type> )
        <returnvalue>box</returnvalue>
       </para>
       <para>
        计算框中内刻的圆形。
       </para>
       <para>
        <literal>box(circle '&lt;(0,0),2&gt;')</literal>
        <returnvalue>(1.414213562373095,1.414213562373095),&zwsp;(-1.414213562373095,-1.414213562373095)</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>box</function> ( <type>point</type> )
        <returnvalue>box</returnvalue>
       </para>
       <para>
        Converts point to empty box.
       </para>
       <para>
        <literal>box(point '(1,0)')</literal>
        <returnvalue>(1,0),(1,0)</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>box</function> ( <type>point</type> )
        <returnvalue>box</returnvalue>
       </para>
       <para>
        将点转换为空框。
       </para>
       <para>
        <literal>box(point '(1,0)')</literal>
        <returnvalue>(1,0),(1,0)</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>box</function> ( <type>point</type>, <type>point</type> )
        <returnvalue>box</returnvalue>
       </para>
       <para>
        Converts any two corner points to box.
       </para>
       <para>
        <literal>box(point '(0,1)', point '(1,0)')</literal>
        <returnvalue>(1,1),(0,0)</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>box</function> ( <type>point</type>, <type>point</type> )
        <returnvalue>box</returnvalue>
       </para>
       <para>
        将任意两个角点转换为框。
       </para>
       <para>
        <literal>box(point '(0,1)', point '(1,0)')</literal>
        <returnvalue>(1,1),(0,0)</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>box</function> ( <type>polygon</type> )
        <returnvalue>box</returnvalue>
       </para>
       <para>
        Computes bounding box of polygon.
       </para>
       <para>
        <literal>box(polygon '((0,0),(1,1),(2,0))')</literal>
        <returnvalue>(2,1),(0,0)</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>box</function> ( <type>polygon</type> )
        <returnvalue>box</returnvalue>
       </para>
       <para>
        计算多边形的边界框。
       </para>
       <para>
        <literal>box(polygon '((0,0),(1,1),(2,0))')</literal>
        <returnvalue>(2,1),(0,0)</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bound_box</primary>
        </indexterm>
        <function>bound_box</function> ( <type>box</type>, <type>box</type> )
        <returnvalue>box</returnvalue>
       </para>
       <para>
        Computes bounding box of two boxes.
       </para>
       <para>
        <literal>bound_box(box '(1,1),(0,0)', box '(4,4),(3,3)')</literal>
        <returnvalue>(4,4),(0,0)</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bound_box</primary>
        </indexterm>
        <function>bound_box</function> ( <type>box</type>, <type>box</type> )
        <returnvalue>box</returnvalue>
       </para>
       <para>
        计算两个方框的边界框。
       </para>
       <para>
        <literal>bound_box(box '(1,1),(0,0)', box '(4,4),(3,3)')</literal>
        <returnvalue>(4,4),(0,0)</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>circle</primary>
        </indexterm>
        <function>circle</function> ( <type>box</type> )
        <returnvalue>circle</returnvalue>
       </para>
       <para>
        Computes smallest circle enclosing box.
       </para>
       <para>
        <literal>circle(box '(1,1),(0,0)')</literal>
        <returnvalue>&lt;(0.5,0.5),0.7071067811865476&gt;</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>circle</primary>
        </indexterm>
        <function>circle</function> ( <type>box</type> )
        <returnvalue>circle</returnvalue>
       </para>
       <para>
        计算最小的圆形包围框。
       </para>
       <para>
        <literal>circle(box '(1,1),(0,0)')</literal>
        <returnvalue>&lt;(0.5,0.5),0.7071067811865476&gt;</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>circle</function> ( <type>point</type>, <type>double precision</type> )
        <returnvalue>circle</returnvalue>
       </para>
       <para>
        Constructs circle from center and radius.
       </para>
       <para>
        <literal>circle(point '(0,0)', 2.0)</literal>
        <returnvalue>&lt;(0,0),2&gt;</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>circle</function> ( <type>point</type>, <type>double precision</type> )
        <returnvalue>circle</returnvalue>
       </para>
       <para>
        从圆心和半径构造圆。
       </para>
       <para>
        <literal>circle(point '(0,0)', 2.0)</literal>
        <returnvalue>&lt;(0,0),2&gt;</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>circle</function> ( <type>polygon</type> )
        <returnvalue>circle</returnvalue>
       </para>
       <para>
        Converts polygon to circle.  The circle's center is the mean of the
        positions of the polygon's points, and the radius is the average
        distance of the polygon's points from that center.
       </para>
       <para>
        <literal>circle(polygon '((0,0),(1,3),(2,0))')</literal>
        <returnvalue>&lt;(1,1),1.6094757082487299&gt;</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>circle</function> ( <type>polygon</type> )
        <returnvalue>circle</returnvalue>
       </para>
       <para>
        将多边形转换为圆。圆心是多边形各点位置的平均值，半径是多边形各点到圆心的平均距离。
       </para>
       <para>
        <literal>circle(polygon '((0,0),(1,3),(2,0))')</literal>
        <returnvalue>&lt;(1,1),1.6094757082487299&gt;</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>line</primary>
        </indexterm>
        <function>line</function> ( <type>point</type>, <type>point</type> )
        <returnvalue>line</returnvalue>
       </para>
       <para>
        Converts two points to the line through them.
       </para>
       <para>
        <literal>line(point '(-1,0)', point '(1,0)')</literal>
        <returnvalue>{0,-1,0}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>line</primary>
        </indexterm>
        <function>line</function> ( <type>point</type>, <type>point</type> )
        <returnvalue>line</returnvalue>
       </para>
       <para>
        将两个点转换成通过它们的直线。
       </para>
       <para>
        <literal>line(point '(-1,0)', point '(1,0)')</literal>
        <returnvalue>{0,-1,0}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lseg</primary>
        </indexterm>
        <function>lseg</function> ( <type>box</type> )
        <returnvalue>lseg</returnvalue>
       </para>
       <para>
        Extracts box's diagonal as a line segment.
       </para>
       <para>
        <literal>lseg(box '(1,0),(-1,0)')</literal>
        <returnvalue>[(1,0),(-1,0)]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lseg</primary>
        </indexterm>
        <function>lseg</function> ( <type>box</type> )
        <returnvalue>lseg</returnvalue>
       </para>
       <para>
        提取框的对角线作为线段。
       </para>
       <para>
        <literal>lseg(box '(1,0),(-1,0)')</literal>
        <returnvalue>[(1,0),(-1,0)]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>lseg</function> ( <type>point</type>, <type>point</type> )
        <returnvalue>lseg</returnvalue>
       </para>
       <para>
        Constructs line segment from two endpoints.
       </para>
       <para>
        <literal>lseg(point '(-1,0)', point '(1,0)')</literal>
        <returnvalue>[(-1,0),(1,0)]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>lseg</function> ( <type>point</type>, <type>point</type> )
        <returnvalue>lseg</returnvalue>
       </para>
       <para>
        从两个端点构造线段。
       </para>
       <para>
        <literal>lseg(point '(-1,0)', point '(1,0)')</literal>
        <returnvalue>[(-1,0),(1,0)]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>path</primary>
        </indexterm>
        <function>path</function> ( <type>polygon</type> )
        <returnvalue>path</returnvalue>
       </para>
       <para>
        Converts polygon to a closed path with the same list of points.
       </para>
       <para>
        <literal>path(polygon '((0,0),(1,1),(2,0))')</literal>
        <returnvalue>((0,0),(1,1),(2,0))</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>path</primary>
        </indexterm>
        <function>path</function> ( <type>polygon</type> )
        <returnvalue>path</returnvalue>
       </para>
       <para>
        将多边形转换为具有点的相同列表的封闭路径。
       </para>
       <para>
        <literal>path(polygon '((0,0),(1,1),(2,0))')</literal>
        <returnvalue>((0,0),(1,1),(2,0))</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>point</primary>
        </indexterm>
        <function>point</function> ( <type>double precision</type>, <type>double precision</type> )
        <returnvalue>point</returnvalue>
       </para>
       <para>
        Constructs point from its coordinates.
       </para>
       <para>
        <literal>point(23.4, -44.5)</literal>
        <returnvalue>(23.4,-44.5)</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>point</primary>
        </indexterm>
        <function>point</function> ( <type>double precision</type>, <type>double precision</type> )
        <returnvalue>point</returnvalue>
       </para>
       <para>
        从它的坐标构造点。
       </para>
       <para>
        <literal>point(23.4, -44.5)</literal>
        <returnvalue>(23.4,-44.5)</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>point</function> ( <type>box</type> )
        <returnvalue>point</returnvalue>
       </para>
       <para>
        Computes center of box.
       </para>
       <para>
        <literal>point(box '(1,0),(-1,0)')</literal>
        <returnvalue>(0,0)</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>point</function> ( <type>box</type> )
        <returnvalue>point</returnvalue>
       </para>
       <para>
        计算框的中心。
       </para>
       <para>
        <literal>point(box '(1,0),(-1,0)')</literal>
        <returnvalue>(0,0)</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>point</function> ( <type>circle</type> )
        <returnvalue>point</returnvalue>
       </para>
       <para>
        Computes center of circle.
       </para>
       <para>
        <literal>point(circle '&lt;(0,0),2&gt;')</literal>
        <returnvalue>(0,0)</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>point</function> ( <type>circle</type> )
        <returnvalue>point</returnvalue>
       </para>
       <para>
        计算圆心。
       </para>
       <para>
        <literal>point(circle '&lt;(0,0),2&gt;')</literal>
        <returnvalue>(0,0)</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>point</function> ( <type>lseg</type> )
        <returnvalue>point</returnvalue>
       </para>
       <para>
        Computes center of line segment.
       </para>
       <para>
        <literal>point(lseg '[(-1,0),(1,0)]')</literal>
        <returnvalue>(0,0)</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>point</function> ( <type>lseg</type> )
        <returnvalue>point</returnvalue>
       </para>
       <para>
        计算线段的中心。
       </para>
       <para>
        <literal>point(lseg '[(-1,0),(1,0)]')</literal>
        <returnvalue>(0,0)</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>point</function> ( <type>polygon</type> )
        <returnvalue>point</returnvalue>
       </para>
       <para>
        Computes center of polygon (the mean of the
        positions of the polygon's points).
       </para>
       <para>
        <literal>point(polygon '((0,0),(1,1),(2,0))')</literal>
        <returnvalue>(1,0.3333333333333333)</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>point</function> ( <type>polygon</type> )
        <returnvalue>point</returnvalue>
       </para>
       <para>
        计算多边形的中心（多边形的点位置的平均值）。
       </para>
       <para>
        <literal>point(polygon '((0,0),(1,1),(2,0))')</literal>
        <returnvalue>(1,0.3333333333333333)</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>polygon</primary>
        </indexterm>
        <function>polygon</function> ( <type>box</type> )
        <returnvalue>polygon</returnvalue>
       </para>
       <para>
        Converts box to a 4-point polygon.
       </para>
       <para>
        <literal>polygon(box '(1,1),(0,0)')</literal>
        <returnvalue>((0,0),(0,1),(1,1),(1,0))</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>polygon</primary>
        </indexterm>
        <function>polygon</function> ( <type>box</type> )
        <returnvalue>polygon</returnvalue>
       </para>
       <para>
        将框转换为4点多边形。
       </para>
       <para>
        <literal>polygon(box '(1,1),(0,0)')</literal>
        <returnvalue>((0,0),(0,1),(1,1),(1,0))</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>polygon</function> ( <type>circle</type> )
        <returnvalue>polygon</returnvalue>
       </para>
       <para>
        Converts circle to a 12-point polygon.
       </para>
       <para>
        <literal>polygon(circle '&lt;(0,0),2&gt;')</literal>
        <returnvalue>((-2,0),&zwsp;(-1.7320508075688774,0.9999999999999999),&zwsp;(-1.0000000000000002,1.7320508075688772),&zwsp;(-1.2246063538223773e-16,2),&zwsp;(0.9999999999999996,1.7320508075688774),&zwsp;(1.732050807568877,1.0000000000000007),&zwsp;(2,2.4492127076447545e-16),&zwsp;(1.7320508075688776,-0.9999999999999994),&zwsp;(1.0000000000000009,-1.7320508075688767),&zwsp;(3.673819061467132e-16,-2),&zwsp;(-0.9999999999999987,-1.732050807568878),&zwsp;(-1.7320508075688767,-1.0000000000000009))</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>polygon</function> ( <type>circle</type> )
        <returnvalue>polygon</returnvalue>
       </para>
       <para>
        将圆转换为12点多边形。
       </para>
       <para>
        <literal>polygon(circle '&lt;(0,0),2&gt;')</literal>
        <returnvalue>((-2,0),&zwsp;(-1.7320508075688774,0.9999999999999999),&zwsp;(-1.0000000000000002,1.7320508075688772),&zwsp;(-1.2246063538223773e-16,2),&zwsp;(0.9999999999999996,1.7320508075688774),&zwsp;(1.732050807568877,1.0000000000000007),&zwsp;(2,2.4492127076447545e-16),&zwsp;(1.7320508075688776,-0.9999999999999994),&zwsp;(1.0000000000000009,-1.7320508075688767),&zwsp;(3.673819061467132e-16,-2),&zwsp;(-0.9999999999999987,-1.732050807568878),&zwsp;(-1.7320508075688767,-1.0000000000000009))</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>polygon</function> ( <type>integer</type>, <type>circle</type> )
        <returnvalue>polygon</returnvalue>
       </para>
       <para>
        Converts circle to an <replaceable>n</replaceable>-point polygon.
       </para>
       <para>
        <literal>polygon(4, circle '&lt;(3,0),1&gt;')</literal>
        <returnvalue>((2,0),&zwsp;(3,1),&zwsp;(4,1.2246063538223773e-16),&zwsp;(3,-1))</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>polygon</function> ( <type>integer</type>, <type>circle</type> )
        <returnvalue>polygon</returnvalue>
       </para>
       <para>
        将圆转换为<replaceable>n</replaceable>点多边形。
       </para>
       <para>
        <literal>polygon(4, circle '&lt;(3,0),1&gt;')</literal>
        <returnvalue>((2,0),&zwsp;(3,1),&zwsp;(4,1.2246063538223773e-16),&zwsp;(3,-1))</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>polygon</function> ( <type>path</type> )
        <returnvalue>polygon</returnvalue>
       </para>
       <para>
        Converts closed path to a polygon with the same list of points.
       </para>
       <para>
        <literal>polygon(path '((0,0),(1,1),(2,0))')</literal>
        <returnvalue>((0,0),(1,1),(2,0))</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>polygon</function> ( <type>path</type> )
        <returnvalue>polygon</returnvalue>
       </para>
       <para>
        将封闭路径转换为具有点的相同列表的多边形。
       </para>
       <para>
        <literal>polygon(path '((0,0),(1,1),(2,0))')</literal>
        <returnvalue>((0,0),(1,1),(2,0))</returnvalue>
       </para></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
    <para>
     It is possible to access the two component numbers of a <type>point</type>
     as though the point were an array with indexes 0 and 1.  For example, if
     <literal>t.p</literal> is a <type>point</type> column then
     <literal>SELECT p[0] FROM t</literal> retrieves the X coordinate and
     <literal>UPDATE t SET p[1] = ...</literal> changes the Y coordinate.
     In the same way, a value of type <type>box</type> or <type>lseg</type> can be treated
     as an array of two <type>point</type> values.
    </para>
____________________________________________________________________________-->
    <para>
     我们可以把一个<type>point</type>的两个组成数字当作具有索引 0 和 1 的数组访问。例如，如果<literal>t.p</literal>是一个<type>point</type>列，那么<literal>SELECT p[0] FROM t</literal>检索 X 座标而 <literal>UPDATE t SET p[1] = ...</literal>改变 Y 座标。同样，<type>box</type>或者<type>lseg</type>类型的值可以当作两个<type>point</type>值的数组值看待。
    </para>

  </sect1>

 <sect1 id="functions-net">
<!--==========================orignal english content==========================
  <title>Network Address Functions and Operators</title>
____________________________________________________________________________-->
  <title>网络地址函数和操作符</title>

<!--==========================orignal english content==========================
  <para>
   The IP network address types, <type>cidr</type> and <type>inet</type>,
   support the usual comparison operators shown in
   <xref linkend="functions-comparison-op-table"/>
   as well as the specialized operators and functions shown in
   <xref linkend="cidr-inet-operators-table"/> and
   <xref linkend="cidr-inet-functions-table"/>.
  </para>
____________________________________________________________________________-->
  <para>
   IP网络地址类型，<type>cidr</type>和<type>inet</type>，支持<xref linkend="functions-comparison-op-table"/>所示的常用比较操作符，
   以及<xref linkend="cidr-inet-operators-table"/> 和 <xref linkend="cidr-inet-functions-table"/>所示的专用操作符和函数。
  </para>

<!--==========================orignal english content==========================
  <para>
   Any <type>cidr</type> value can be cast to <type>inet</type> implicitly;
   therefore, the operators and functions shown below as operating on
   <type>inet</type> also work on <type>cidr</type> values.  (Where there are
   separate functions for <type>inet</type> and <type>cidr</type>, it is
   because the behavior should be different for the two cases.)
   Also, it is permitted to cast an <type>inet</type> value
   to <type>cidr</type>.  When this is done, any bits to the right of the
   netmask are silently zeroed to create a valid <type>cidr</type> value.
  </para>
____________________________________________________________________________-->
  <para>
   任何<type>cidr</type> 值都可以隐式地转换到<type>inet</type>；因此，下面在<type>inet</type>上操作的操作符和函数也可以在<type>cidr</type>值上工作。
   (对于<type>inet</type>和<type>cidr</type>有单独的函数，这是因为这两种情况的行为应该是不同的。)
   此外，它允许将<type>inet</type>值转换为<type>cidr</type>。
   当这样做的时候，子网掩码右边的任何位都被静默地置零，以创建一个有效的<type>cidr</type>值。
  </para>

   <table id="cidr-inet-operators-table">
<!--==========================orignal english content==========================
    <title>IP Address Operators</title>
____________________________________________________________________________-->
    <title>IP地址操作符</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Operator
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        操作符
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>&lt;&lt;</literal> <type>inet</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is subnet strictly contained by subnet?
        This operator, and the next four, test for subnet inclusion.  They
        consider only the network parts of the two addresses (ignoring any
        bits to the right of the netmasks) and determine whether one network
        is identical to or a subnet of the other.
       </para>
       <para>
        <literal>inet '192.168.1.5' &lt;&lt; inet '192.168.1/24'</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>inet '192.168.0.5' &lt;&lt; inet '192.168.1/24'</literal>
        <returnvalue>f</returnvalue>
       </para>
       <para>
        <literal>inet '192.168.1/24' &lt;&lt; inet '192.168.1/24'</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>&lt;&lt;</literal> <type>inet</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        子网是否严格包含在子网中?这个操作符和后续的四个操作符测试子网包含情况。
        它们只考虑两个地址的网络部分(忽略网络掩码右侧的任何位)，并确定一个网络与另一个网络相同或者是相同的子网。
       </para>
       <para>
        <literal>inet '192.168.1.5' &lt;&lt; inet '192.168.1/24'</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>inet '192.168.0.5' &lt;&lt; inet '192.168.1/24'</literal>
        <returnvalue>f</returnvalue>
       </para>
       <para>
        <literal>inet '192.168.1/24' &lt;&lt; inet '192.168.1/24'</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>&lt;&lt;=</literal> <type>inet</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is subnet contained by or equal to subnet?
       </para>
       <para>
        <literal>inet '192.168.1/24' &lt;&lt;= inet '192.168.1/24'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>&lt;&lt;=</literal> <type>inet</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        子网是否包含或等于子网?
       </para>
       <para>
        <literal>inet '192.168.1/24' &lt;&lt;= inet '192.168.1/24'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>&gt;&gt;</literal> <type>inet</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does subnet strictly contain subnet?
       </para>
       <para>
        <literal>inet '192.168.1/24' &gt;&gt; inet '192.168.1.5'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>&gt;&gt;</literal> <type>inet</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        子网是否严格包含子网?
       </para>
       <para>
        <literal>inet '192.168.1/24' &gt;&gt; inet '192.168.1.5'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>&gt;&gt;=</literal> <type>inet</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does subnet contain or equal subnet?
       </para>
       <para>
        <literal>inet '192.168.1/24' &gt;&gt;= inet '192.168.1/24'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>&gt;&gt;=</literal> <type>inet</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        子网是否包含或等于子网?
       </para>
       <para>
        <literal>inet '192.168.1/24' &gt;&gt;= inet '192.168.1/24'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>&amp;&amp;</literal> <type>inet</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does either subnet contain or equal the other?
       </para>
       <para>
        <literal>inet '192.168.1/24' &amp;&amp; inet '192.168.1.80/28'</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>inet '192.168.1/24' &amp;&amp; inet '192.168.2.0/28'</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>&amp;&amp;</literal> <type>inet</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        其中一个子网包含或等于另一个子网?
       </para>
       <para>
        <literal>inet '192.168.1/24' &amp;&amp; inet '192.168.1.80/28'</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>inet '192.168.1/24' &amp;&amp; inet '192.168.2.0/28'</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>~</literal> <type>inet</type>
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        Computes bitwise NOT.
       </para>
       <para>
        <literal>~ inet '192.168.1.6'</literal>
        <returnvalue>63.87.254.249</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>~</literal> <type>inet</type>
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        计算位 NOT.
       </para>
       <para>
        <literal>~ inet '192.168.1.6'</literal>
        <returnvalue>63.87.254.249</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>&amp;</literal> <type>inet</type>
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        Computes bitwise AND.
       </para>
       <para>
        <literal>inet '192.168.1.6' &amp; inet '0.0.0.255'</literal>
        <returnvalue>0.0.0.6</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>&amp;</literal> <type>inet</type>
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        计算位 AND.
       </para>
       <para>
        <literal>inet '192.168.1.6' &amp; inet '0.0.0.255'</literal>
        <returnvalue>0.0.0.6</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>|</literal> <type>inet</type>
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        Computes bitwise OR.
       </para>
       <para>
        <literal>inet '192.168.1.6' | inet '0.0.0.255'</literal>
        <returnvalue>192.168.1.255</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>|</literal> <type>inet</type>
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        计算位 OR.
       </para>
       <para>
        <literal>inet '192.168.1.6' | inet '0.0.0.255'</literal>
        <returnvalue>192.168.1.255</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>+</literal> <type>bigint</type>
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        Adds an offset to an address.
       </para>
       <para>
        <literal>inet '192.168.1.6' + 25</literal>
        <returnvalue>192.168.1.31</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>+</literal> <type>bigint</type>
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        向地址添加偏移量。
       </para>
       <para>
        <literal>inet '192.168.1.6' + 25</literal>
        <returnvalue>192.168.1.31</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bigint</type> <literal>+</literal> <type>inet</type>
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        Adds an offset to an address.
       </para>
       <para>
        <literal>200 + inet '::ffff:fff0:1'</literal>
        <returnvalue>::ffff:255.240.0.201</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bigint</type> <literal>+</literal> <type>inet</type>
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        向地址添加偏移量。
       </para>
       <para>
        <literal>200 + inet '::ffff:fff0:1'</literal>
        <returnvalue>::ffff:255.240.0.201</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>-</literal> <type>bigint</type>
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        Subtracts an offset from an address.
       </para>
       <para>
        <literal>inet '192.168.1.43' - 36</literal>
        <returnvalue>192.168.1.7</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>-</literal> <type>bigint</type>
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        从地址中减去偏移量。
       </para>
       <para>
        <literal>inet '192.168.1.43' - 36</literal>
        <returnvalue>192.168.1.7</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>-</literal> <type>inet</type>
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Computes the difference of two addresses.
       </para>
       <para>
        <literal>inet '192.168.1.43' - inet '192.168.1.19'</literal>
        <returnvalue>24</returnvalue>
       </para>
       <para>
        <literal>inet '::1' - inet '::ffff:1'</literal>
        <returnvalue>-4294901760</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>inet</type> <literal>-</literal> <type>inet</type>
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        计算两个地址的差值。
       </para>
       <para>
        <literal>inet '192.168.1.43' - inet '192.168.1.19'</literal>
        <returnvalue>24</returnvalue>
       </para>
       <para>
        <literal>inet '::1' - inet '::ffff:1'</literal>
        <returnvalue>-4294901760</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <table id="cidr-inet-functions-table">
<!--==========================orignal english content==========================
    <title>IP Address Functions</title>
____________________________________________________________________________-->
    <title>IP地址的函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>abbrev</primary>
        </indexterm>
        <function>abbrev</function> ( <type>inet</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Creates an abbreviated display format as text.
        (The result is the same as the <type>inet</type> output function
        produces; it is <quote>abbreviated</quote> only in comparison to the
        result of an explicit cast to <type>text</type>, which for historical
        reasons will never suppress the netmask part.)
       </para>
       <para>
        <literal>abbrev(inet '10.1.0.0/32')</literal>
        <returnvalue>10.1.0.0</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>abbrev</primary>
        </indexterm>
        <function>abbrev</function> ( <type>inet</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        创建缩略的文本显示格式。
        (结果与<type>inet</type>输出函数产生的结果相同;它只是在与显式转换为<type>text</type>的结果比较时才被<quote>abbreviated</quote>，
        由于历史原因，它永远不会抑制子网掩码部分。)
       </para>
       <para>
        <literal>abbrev(inet '10.1.0.0/32')</literal>
        <returnvalue>10.1.0.0</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>abbrev</function> ( <type>cidr</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Creates an abbreviated display format as text.
        (The abbreviation consists of dropping all-zero octets to the right
        of the netmask; more examples are in
        <xref linkend="datatype-net-cidr-table"/>.)
       </para>
       <para>
        <literal>abbrev(cidr '10.1.0.0/16')</literal>
        <returnvalue>10.1/16</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>abbrev</function> ( <type>cidr</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        创建缩写的文本显示格式。(缩写包括在子网掩码的右侧删除所有零字节;更多的例子请见 <xref linkend="datatype-net-cidr-table"/>。)
       </para>
       <para>
        <literal>abbrev(cidr '10.1.0.0/16')</literal>
        <returnvalue>10.1/16</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>broadcast</primary>
        </indexterm>
        <function>broadcast</function> ( <type>inet</type> )
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        Computes the broadcast address for the address's network.
       </para>
       <para>
        <literal>broadcast(inet '192.168.1.5/24')</literal>
        <returnvalue>192.168.1.255/24</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>broadcast</primary>
        </indexterm>
        <function>broadcast</function> ( <type>inet</type> )
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        为地址的网络计算广播地址。
       </para>
       <para>
        <literal>broadcast(inet '192.168.1.5/24')</literal>
        <returnvalue>192.168.1.255/24</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>family</primary>
        </indexterm>
        <function>family</function> ( <type>inet</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the address's family: <literal>4</literal> for IPv4,
        <literal>6</literal> for IPv6.
       </para>
       <para>
        <literal>family(inet '::1')</literal>
        <returnvalue>6</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>family</primary>
        </indexterm>
        <function>family</function> ( <type>inet</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回地址的系列: <literal>4</literal> 对应 IPv4, <literal>6</literal> 对应 IPv6。
       </para>
       <para>
        <literal>family(inet '::1')</literal>
        <returnvalue>6</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>host</primary>
        </indexterm>
        <function>host</function> ( <type>inet</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the IP address as text, ignoring the netmask.
       </para>
       <para>
        <literal>host(inet '192.168.1.0/24')</literal>
        <returnvalue>192.168.1.0</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>host</primary>
        </indexterm>
        <function>host</function> ( <type>inet</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回IP地址文本，忽略子网掩码。
       </para>
       <para>
        <literal>host(inet '192.168.1.0/24')</literal>
        <returnvalue>192.168.1.0</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>hostmask</primary>
        </indexterm>
        <function>hostmask</function> ( <type>inet</type> )
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        Computes the host mask for the address's network.
       </para>
       <para>
        <literal>hostmask(inet '192.168.23.20/30')</literal>
        <returnvalue>0.0.0.3</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>hostmask</primary>
        </indexterm>
        <function>hostmask</function> ( <type>inet</type> )
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        为地址的网络计算主机掩码。
       </para>
       <para>
        <literal>hostmask(inet '192.168.23.20/30')</literal>
        <returnvalue>0.0.0.3</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>inet_merge</primary>
        </indexterm>
        <function>inet_merge</function> ( <type>inet</type>, <type>inet</type> )
        <returnvalue>cidr</returnvalue>
       </para>
       <para>
        Computes the smallest network that includes both of the given networks.
       </para>
       <para>
        <literal>inet_merge(inet '192.168.1.5/24', inet '192.168.2.5/24')</literal>
        <returnvalue>192.168.0.0/22</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>inet_merge</primary>
        </indexterm>
        <function>inet_merge</function> ( <type>inet</type>, <type>inet</type> )
        <returnvalue>cidr</returnvalue>
       </para>
       <para>
        计算包含两个给定网络的最小网络。
       </para>
       <para>
        <literal>inet_merge(inet '192.168.1.5/24', inet '192.168.2.5/24')</literal>
        <returnvalue>192.168.0.0/22</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>inet_same_family</primary>
        </indexterm>
        <function>inet_same_family</function> ( <type>inet</type>, <type>inet</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Tests whether the addresses belong to the same IP family.
       </para>
       <para>
        <literal>inet_same_family(inet '192.168.1.5/24', inet '::1')</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>inet_same_family</primary>
        </indexterm>
        <function>inet_same_family</function> ( <type>inet</type>, <type>inet</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试地址是否属于同一IP族。
       </para>
       <para>
        <literal>inet_same_family(inet '192.168.1.5/24', inet '::1')</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>masklen</primary>
        </indexterm>
        <function>masklen</function> ( <type>inet</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the netmask length in bits.
       </para>
       <para>
        <literal>masklen(inet '192.168.1.5/24')</literal>
        <returnvalue>24</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>masklen</primary>
        </indexterm>
        <function>masklen</function> ( <type>inet</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        以比特位返回子网掩码长度。
       </para>
       <para>
        <literal>masklen(inet '192.168.1.5/24')</literal>
        <returnvalue>24</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>netmask</primary>
        </indexterm>
        <function>netmask</function> ( <type>inet</type> )
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        Computes the network mask for the address's network.
       </para>
       <para>
        <literal>netmask(inet '192.168.1.5/24')</literal>
        <returnvalue>255.255.255.0</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>netmask</primary>
        </indexterm>
        <function>netmask</function> ( <type>inet</type> )
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        为地址的网络计算网络掩码。
       </para>
       <para>
        <literal>netmask(inet '192.168.1.5/24')</literal>
        <returnvalue>255.255.255.0</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>network</primary>
        </indexterm>
        <function>network</function> ( <type>inet</type> )
        <returnvalue>cidr</returnvalue>
       </para>
       <para>
        Returns the network part of the address, zeroing out
        whatever is to the right of the netmask.
        (This is equivalent to casting the value to <type>cidr</type>.)
       </para>
       <para>
        <literal>network(inet '192.168.1.5/24')</literal>
        <returnvalue>192.168.1.0/24</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>network</primary>
        </indexterm>
        <function>network</function> ( <type>inet</type> )
        <returnvalue>cidr</returnvalue>
       </para>
       <para>
        返回地址的网络部分，将子网掩码右边的部分归零。(这相当于将值转换为<type>cidr</type>。)
       </para>
       <para>
        <literal>network(inet '192.168.1.5/24')</literal>
        <returnvalue>192.168.1.0/24</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>set_masklen</primary>
        </indexterm>
        <function>set_masklen</function> ( <type>inet</type>, <type>integer</type> )
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        Sets the netmask length for an <type>inet</type> value.
        The address part does not change.
       </para>
       <para>
        <literal>set_masklen(inet '192.168.1.5/24', 16)</literal>
        <returnvalue>192.168.1.5/16</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>set_masklen</primary>
        </indexterm>
        <function>set_masklen</function> ( <type>inet</type>, <type>integer</type> )
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        设置<type>inet</type>值的子网掩码长度。地址部分不改变。
       </para>
       <para>
        <literal>set_masklen(inet '192.168.1.5/24', 16)</literal>
        <returnvalue>192.168.1.5/16</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>set_masklen</function> ( <type>cidr</type>, <type>integer</type> )
        <returnvalue>cidr</returnvalue>
       </para>
       <para>
        Sets the netmask length for a <type>cidr</type> value.
        Address bits to the right of the new netmask are set to zero.
       </para>
       <para>
        <literal>set_masklen(cidr '192.168.1.0/24', 16)</literal>
        <returnvalue>192.168.0.0/16</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>set_masklen</function> ( <type>cidr</type>, <type>integer</type> )
        <returnvalue>cidr</returnvalue>
       </para>
       <para>
        设置<type>cidr</type>值的子网掩码长度。新子网掩码右侧的地址位设置为零。
       </para>
       <para>
        <literal>set_masklen(cidr '192.168.1.0/24', 16)</literal>
        <returnvalue>192.168.0.0/16</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>text</primary>
        </indexterm>
        <function>text</function> ( <type>inet</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the unabbreviated IP address and netmask length as text.
        (This has the same result as an explicit cast to <type>text</type>.)
       </para>
       <para>
        <literal>text(inet '192.168.1.5')</literal>
        <returnvalue>192.168.1.5/32</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>text</primary>
        </indexterm>
        <function>text</function> ( <type>inet</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        以文本形式返回未缩写的IP地址和子网掩码长度。(这与显式转换为<type>text</type>的结果相同。)
       </para>
       <para>
        <literal>text(inet '192.168.1.5')</literal>
        <returnvalue>192.168.1.5/32</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <tip>
<!--==========================orignal english content==========================
   <para>
    The <function>abbrev</function>, <function>host</function>,
    and <function>text</function> functions are primarily intended to offer
    alternative display formats for IP addresses.
   </para>
____________________________________________________________________________-->
   <para>
    <function>abbrev</function>、<function>host</function>和<function>text</function>函数主要用于为IP地址提供另一种显示格式。
   </para>
  </tip>

<!--==========================orignal english content==========================
  <para>
   The MAC address types, <type>macaddr</type> and <type>macaddr8</type>,
   support the usual comparison operators shown in
   <xref linkend="functions-comparison-op-table"/>
   as well as the specialized functions shown in
   <xref linkend="macaddr-functions-table"/>.
   In addition, they support the bitwise logical operators
   <literal>~</literal>, <literal>&amp;</literal> and <literal>|</literal>
   (NOT, AND and OR), just as shown above for IP addresses.
  </para>
____________________________________________________________________________-->
  <para>
   MAC地址类型， <type>macaddr</type> 和<type>macaddr8</type>，支持<xref linkend="functions-comparison-op-table"/>中所示的常用比较操作符以及<xref linkend="macaddr-functions-table"/>中所示的特殊函数。
   此外，它们支持位元逻辑操作符<literal>~</literal>, <literal>&amp;</literal> 和 <literal>|</literal> (NOT, AND 和 OR)，就像上面对IP地址所示的那样。
  </para>

   <table id="macaddr-functions-table">
<!--==========================orignal english content==========================
    <title>MAC Address Functions</title>
____________________________________________________________________________-->
    <title>MAC 地址函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>trunc</primary>
        </indexterm>
        <function>trunc</function> ( <type>macaddr</type> )
        <returnvalue>macaddr</returnvalue>
       </para>
       <para>
        Sets the last 3 bytes of the address to zero.  The remaining prefix
        can be associated with a particular manufacturer (using data not
        included in <productname>PostgreSQL</productname>).
       </para>
       <para>
        <literal>trunc(macaddr '12:34:56:78:90:ab')</literal>
        <returnvalue>12:34:56:00:00:00</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>trunc</primary>
        </indexterm>
        <function>trunc</function> ( <type>macaddr</type> )
        <returnvalue>macaddr</returnvalue>
       </para>
       <para>
        将地址的最后3个字节设置为零。其余的前缀可以与特定的制造商关联(使用<productname>PostgreSQL</productname>中没有包含的数据)。
       </para>
       <para>
        <literal>trunc(macaddr '12:34:56:78:90:ab')</literal>
        <returnvalue>12:34:56:00:00:00</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>trunc</function> ( <type>macaddr8</type> )
        <returnvalue>macaddr8</returnvalue>
       </para>
       <para>
        Sets the last 5 bytes of the address to zero.  The remaining prefix
        can be associated with a particular manufacturer (using data not
        included in <productname>PostgreSQL</productname>).
       </para>
       <para>
        <literal>trunc(macaddr8 '12:34:56:78:90:ab:cd:ef')</literal>
        <returnvalue>12:34:56:00:00:00:00:00</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>trunc</function> ( <type>macaddr8</type> )
        <returnvalue>macaddr8</returnvalue>
       </para>
       <para>
        将地址的最后5个字节设置为零。其余的前缀可以与特定的制造商关联(使用<productname>PostgreSQL</productname>中没有包含的数据)。
       </para>
       <para>
        <literal>trunc(macaddr8 '12:34:56:78:90:ab:cd:ef')</literal>
        <returnvalue>12:34:56:00:00:00:00:00</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>macaddr8_set7bit</primary>
        </indexterm>
        <function>macaddr8_set7bit</function> ( <type>macaddr8</type> )
        <returnvalue>macaddr8</returnvalue>
       </para>
       <para>
        Sets the 7th bit of the address to one, creating what is known as
        modified EUI-64, for inclusion in an IPv6 address.
       </para>
       <para>
        <literal>macaddr8_set7bit(macaddr8 '00:34:56:ab:cd:ef')</literal>
        <returnvalue>02:34:56:ff:fe:ab:cd:ef</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>macaddr8_set7bit</primary>
        </indexterm>
        <function>macaddr8_set7bit</function> ( <type>macaddr8</type> )
        <returnvalue>macaddr8</returnvalue>
       </para>
       <para>
        将地址的第7位设置为1，创建所谓的modified EUI-64，用于包含在IPv6地址中。
       </para>
       <para>
        <literal>macaddr8_set7bit(macaddr8 '00:34:56:ab:cd:ef')</literal>
        <returnvalue>02:34:56:ff:fe:ab:cd:ef</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  </sect1>


 <sect1 id="functions-textsearch">
<!--==========================orignal english content==========================
  <title>Text Search Functions and Operators</title>
____________________________________________________________________________-->
  <title>文本搜索函数和操作符</title>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-textsearch">
    <primary>full text search</primary>
    <secondary>functions and operators</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-textsearch">
    <primary>全文搜索</primary>
    <secondary>函数和操作符</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-textsearch">
    <primary>text search</primary>
    <secondary>functions and operators</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-textsearch">
    <primary>文本搜索</primary>
    <secondary>函数和操作符</secondary>
   </indexterm>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="textsearch-operators-table"/>,
   <xref linkend="textsearch-functions-table"/> and
   <xref linkend="textsearch-functions-debug-table"/>
   summarize the functions and operators that are provided
   for full text searching.  See <xref linkend="textsearch"/> for a detailed
   explanation of <productname>PostgreSQL</productname>'s text search
   facility.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="textsearch-operators-table"/>,
   <xref linkend="textsearch-functions-table"/> and
   <xref linkend="textsearch-functions-debug-table"/>
   总结了为全文搜索提供的函数和操作符。<productname>PostgreSQL</productname>的文本搜索功能的详细解释可参考<xref linkend="textsearch"/>。
  </para>

   <table id="textsearch-operators-table">
<!--==========================orignal english content==========================
    <title>Text Search Operators</title>
____________________________________________________________________________-->
    <title>文本搜索操作符</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Operator
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        操作符
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsvector</type> <literal>@@</literal> <type>tsquery</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <type>tsquery</type> <literal>@@</literal> <type>tsvector</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does <type>tsvector</type> match <type>tsquery</type>?
        (The arguments can be given in either order.)
       </para>
       <para>
        <literal>to_tsvector('fat cats ate rats') @@ to_tsquery('cat &amp; rat')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsvector</type> <literal>@@</literal> <type>tsquery</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <type>tsquery</type> <literal>@@</literal> <type>tsvector</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        <type>tsvector</type>匹配<type>tsquery</type>吗?(参数可以按任意顺序给出。)
       </para>
       <para>
        <literal>to_tsvector('fat cats ate rats') @@ to_tsquery('cat &amp; rat')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>@@</literal> <type>tsquery</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does text string, after implicit invocation
        of <function>to_tsvector()</function>, match <type>tsquery</type>?
       </para>
       <para>
        <literal>'fat cats ate rats' @@ to_tsquery('cat &amp; rat')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>@@</literal> <type>tsquery</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        隐式调用<function>to_tsvector()</function>后的文本字符串匹配<type>tsquery</type>么 ?
       </para>
       <para>
        <literal>'fat cats ate rats' @@ to_tsquery('cat &amp; rat')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsvector</type> <literal>@@@</literal> <type>tsquery</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <type>tsquery</type> <literal>@@@</literal> <type>tsvector</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        This is a deprecated synonym for <literal>@@</literal>.
       </para>
       <para>
        <literal>to_tsvector('fat cats ate rats') @@@ to_tsquery('cat &amp; rat')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsvector</type> <literal>@@@</literal> <type>tsquery</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <type>tsquery</type> <literal>@@@</literal> <type>tsvector</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        这是<literal>@@</literal>已弃用的同义词。
       </para>
       <para>
        <literal>to_tsvector('fat cats ate rats') @@@ to_tsquery('cat &amp; rat')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsvector</type> <literal>||</literal> <type>tsvector</type>
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        Concatenates two <type>tsvector</type>s.  If both inputs contain
        lexeme positions, the second input's positions are adjusted
        accordingly.
       </para>
       <para>
        <literal>'a:1 b:2'::tsvector || 'c:1 d:2 b:3'::tsvector</literal>
        <returnvalue>'a':1 'b':2,5 'c':3 'd':4</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsvector</type> <literal>||</literal> <type>tsvector</type>
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        连接两个<type>tsvector</type>。如果两个输入都包含词素位置，则相应地调整第二个输入的位置。
       </para>
       <para>
        <literal>'a:1 b:2'::tsvector || 'c:1 d:2 b:3'::tsvector</literal>
        <returnvalue>'a':1 'b':2,5 'c':3 'd':4</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsquery</type> <literal>&amp;&amp;</literal> <type>tsquery</type>
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        ANDs two <type>tsquery</type>s together, producing a query that
        matches documents that match both input queries.
       </para>
       <para>
        <literal>'fat | rat'::tsquery &amp;&amp; 'cat'::tsquery</literal>
        <returnvalue>( 'fat' | 'rat' ) &amp; 'cat'</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsquery</type> <literal>&amp;&amp;</literal> <type>tsquery</type>
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        ANDs两个<type>tsquery</type>一起，生成一个匹配两个输入查询的匹配文档的查询。
       </para>
       <para>
        <literal>'fat | rat'::tsquery &amp;&amp; 'cat'::tsquery</literal>
        <returnvalue>( 'fat' | 'rat' ) &amp; 'cat'</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsquery</type> <literal>||</literal> <type>tsquery</type>
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        ORs two <type>tsquery</type>s together, producing a query that
        matches documents that match either input query.
       </para>
       <para>
        <literal>'fat | rat'::tsquery || 'cat'::tsquery</literal>
        <returnvalue>'fat' | 'rat' | 'cat'</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsquery</type> <literal>||</literal> <type>tsquery</type>
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        ORs两个<type>tsquery</type>一起，生成一个匹配两个输入查询的匹配文档的查询。
       </para>
       <para>
        <literal>'fat | rat'::tsquery || 'cat'::tsquery</literal>
        <returnvalue>'fat' | 'rat' | 'cat'</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>!!</literal> <type>tsquery</type>
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        Negates a <type>tsquery</type>, producing a query that matches
        documents that do not match the input query.
       </para>
       <para>
        <literal>!! 'cat'::tsquery</literal>
        <returnvalue>!'cat'</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>!!</literal> <type>tsquery</type>
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        否定<type>tsquery</type>，生成一个与输入查询不匹配的匹配文档的查询。
       </para>
       <para>
        <literal>!! 'cat'::tsquery</literal>
        <returnvalue>!'cat'</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsquery</type> <literal>&lt;-&gt;</literal> <type>tsquery</type>
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        Constructs a phrase query, which matches if the two input queries
        match at successive lexemes.
       </para>
       <para>
        <literal>to_tsquery('fat') &lt;-&gt; to_tsquery('rat')</literal>
        <returnvalue>'fat' &lt;-&gt; 'rat'</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsquery</type> <literal>&lt;-&gt;</literal> <type>tsquery</type>
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        构造一个短语查询，如果两个输入查询在连续的词素上匹配，该查询将进行匹配。
       </para>
       <para>
        <literal>to_tsquery('fat') &lt;-&gt; to_tsquery('rat')</literal>
        <returnvalue>'fat' &lt;-&gt; 'rat'</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsquery</type> <literal>@&gt;</literal> <type>tsquery</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does first <type>tsquery</type> contain the second?  (This considers
        only whether all the lexemes appearing in one query appear in the
        other, ignoring the combining operators.)
       </para>
       <para>
        <literal>'cat'::tsquery @&gt; 'cat &amp; rat'::tsquery</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsquery</type> <literal>@&gt;</literal> <type>tsquery</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个<type>tsquery</type>包含了第二个吗?(这只考虑出现在一个查询中的所有词素是否出现在另一个查询中，忽略了组合操作符。)
       </para>
       <para>
        <literal>'cat'::tsquery @&gt; 'cat &amp; rat'::tsquery</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsquery</type> <literal>&lt;@</literal> <type>tsquery</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is first <type>tsquery</type> contained in the second?  (This
        considers only whether all the lexemes appearing in one query appear
        in the other, ignoring the combining operators.)
       </para>
       <para>
        <literal>'cat'::tsquery &lt;@ 'cat &amp; rat'::tsquery</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>'cat'::tsquery &lt;@ '!cat &amp; rat'::tsquery</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>tsquery</type> <literal>&lt;@</literal> <type>tsquery</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个<type>tsquery</type>包含在第二个中吗?(这只考虑出现在一个查询中的所有词素是否出现在另一个查询中，而忽略了组合操作符。)
       </para>
       <para>
        <literal>'cat'::tsquery &lt;@ 'cat &amp; rat'::tsquery</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>'cat'::tsquery &lt;@ '!cat &amp; rat'::tsquery</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
    <para>
     In addition to these specialized operators, the usual comparison
     operators shown in <xref linkend="functions-comparison-op-table"/> are
     available for types <type>tsvector</type> and <type>tsquery</type>.
     These are not very
     useful for text searching but allow, for example, unique indexes to be
     built on columns of these types.
    </para>
____________________________________________________________________________-->
    <para>
     除了这些专用操作符之外， <xref linkend="functions-comparison-op-table"/> 中所示的常用比较操作符也适用于<type>tsvector</type>和<type>tsquery</type>类型。
     它们对于文本搜索不是很有用，但是允许使用。例如，建在这些类型列上的唯一索引。
    </para>

   <table id="textsearch-functions-table">
<!--==========================orignal english content==========================
    <title>Text Search Functions</title>
____________________________________________________________________________-->
    <title>文本搜索函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_to_tsvector</primary>
        </indexterm>
        <function>array_to_tsvector</function> ( <type>text[]</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        Converts an array of lexemes to a <type>tsvector</type>.
        The given strings are used as-is without further processing.
       </para>
       <para>
        <literal>array_to_tsvector('{fat,cat,rat}'::text[])</literal>
        <returnvalue>'cat' 'fat' 'rat'</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_to_tsvector</primary>
        </indexterm>
        <function>array_to_tsvector</function> ( <type>text[]</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        将词素数组转换为<type>tsvector</type>。给定的字符串按原样使用，不做进一步处理。
       </para>
       <para>
        <literal>array_to_tsvector('{fat,cat,rat}'::text[])</literal>
        <returnvalue>'cat' 'fat' 'rat'</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>get_current_ts_config</primary>
        </indexterm>
        <function>get_current_ts_config</function> ( )
        <returnvalue>regconfig</returnvalue>
       </para>
       <para>
        Returns the OID of the current default text search configuration
        (as set by <xref linkend="guc-default-text-search-config"/>).
       </para>
       <para>
        <literal>get_current_ts_config()</literal>
        <returnvalue>english</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>get_current_ts_config</primary>
        </indexterm>
        <function>get_current_ts_config</function> ( )
        <returnvalue>regconfig</returnvalue>
       </para>
       <para>
        返回当前默认文本搜索配置的OID(由 <xref linkend="guc-default-text-search-config"/> 所设定的).
       </para>
       <para>
        <literal>get_current_ts_config()</literal>
        <returnvalue>english</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>length</primary>
        </indexterm>
        <function>length</function> ( <type>tsvector</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the number of lexemes in the <type>tsvector</type>.
       </para>
       <para>
        <literal>length('fat:2,4 cat:3 rat:5A'::tsvector)</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>length</primary>
        </indexterm>
        <function>length</function> ( <type>tsvector</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回<type>tsvector</type>中的词位数。
       </para>
       <para>
        <literal>length('fat:2,4 cat:3 rat:5A'::tsvector)</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>numnode</primary>
        </indexterm>
        <function>numnode</function> ( <type>tsquery</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the number of lexemes plus operators in
        the <type>tsquery</type>.
       </para>
       <para>
        <literal>numnode('(fat &amp; rat) | cat'::tsquery)</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>numnode</primary>
        </indexterm>
        <function>numnode</function> ( <type>tsquery</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回<type>tsquery</type>中词位和操作符的数目。
       </para>
       <para>
        <literal>numnode('(fat &amp; rat) | cat'::tsquery)</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>plainto_tsquery</primary>
        </indexterm>
        <function>plainto_tsquery</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>query</parameter> <type>text</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        Converts text to a <type>tsquery</type>, normalizing words according to
        the specified or default configuration.  Any punctuation in the string
        is ignored (it does not determine query operators).  The resulting
        query matches documents containing all non-stopwords in the text.
       </para>
       <para>
        <literal>plainto_tsquery('english', 'The Fat Rats')</literal>
        <returnvalue>'fat' &amp; 'rat'</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>plainto_tsquery</primary>
        </indexterm>
        <function>plainto_tsquery</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>query</parameter> <type>text</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        将文本转换为<type>tsquery</type>，根据指定的或默认配置对单词进行标准化。
        字符串中的任何标点符号都会被忽略(它不决定查询操作符)。结果查询匹配文本中包含所有非停止词的文档。
       </para>
       <para>
        <literal>plainto_tsquery('english', 'The Fat Rats')</literal>
        <returnvalue>'fat' &amp; 'rat'</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>phraseto_tsquery</primary>
        </indexterm>
        <function>phraseto_tsquery</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>query</parameter> <type>text</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        Converts text to a <type>tsquery</type>, normalizing words according to
        the specified or default configuration.  Any punctuation in the string
        is ignored (it does not determine query operators).  The resulting
        query matches phrases containing all non-stopwords in the text.
       </para>
       <para>
        <literal>phraseto_tsquery('english', 'The Fat Rats')</literal>
        <returnvalue>'fat' &lt;-&gt; 'rat'</returnvalue>
       </para>
       <para>
        <literal>phraseto_tsquery('english', 'The Cat and Rats')</literal>
        <returnvalue>'cat' &lt;2&gt; 'rat'</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>phraseto_tsquery</primary>
        </indexterm>
        <function>phraseto_tsquery</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>query</parameter> <type>text</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        将文本转换为<type>tsquery</type>，根据指定的或默认配置对单词进行标准化。
        字符串中的任何标点符号都会被忽略(它不决定查询操作符)。结果查询匹配包含文本中所有非停止词的短语。
       </para>
       <para>
        <literal>phraseto_tsquery('english', 'The Fat Rats')</literal>
        <returnvalue>'fat' &lt;-&gt; 'rat'</returnvalue>
       </para>
       <para>
        <literal>phraseto_tsquery('english', 'The Cat and Rats')</literal>
        <returnvalue>'cat' &lt;2&gt; 'rat'</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>websearch_to_tsquery</primary>
        </indexterm>
        <function>websearch_to_tsquery</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>query</parameter> <type>text</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        Converts text to a <type>tsquery</type>, normalizing words according
        to the specified or default configuration.  Quoted word sequences are
        converted to phrase tests.  The word <quote>or</quote> is understood
        as producing an OR operator, and a dash produces a NOT operator;
        other punctuation is ignored.
        This approximates the behavior of some common web search tools.
       </para>
       <para>
        <literal>websearch_to_tsquery('english', '"fat rat" or cat dog')</literal>
        <returnvalue>'fat' &lt;-&gt; 'rat' | 'cat' &amp; 'dog'</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>websearch_to_tsquery</primary>
        </indexterm>
        <function>websearch_to_tsquery</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>query</parameter> <type>text</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        将文本转换为<type>tsquery</type>，根据指定的或默认配置对单词进行标准化。引用的单词序列被转换为短语测试。
        <quote>or</quote>一词被理解为产生OR操作符，而破折号产生NOT操作符;其他标点符号被忽略。这类似于一些常见的网络搜索工具的行为。
       </para>
       <para>
        <literal>websearch_to_tsquery('english', '"fat rat" or cat dog')</literal>
        <returnvalue>'fat' &lt;-&gt; 'rat' | 'cat' &amp; 'dog'</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>querytree</primary>
        </indexterm>
        <function>querytree</function> ( <type>tsquery</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Produces a representation of the indexable portion of
        a <type>tsquery</type>.  A result that is empty or
        just <literal>T</literal> indicates a non-indexable query.
       </para>
       <para>
        <literal>querytree('foo &amp; ! bar'::tsquery)</literal>
        <returnvalue>'foo'</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>querytree</primary>
        </indexterm>
        <function>querytree</function> ( <type>tsquery</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        生成<type>tsquery</type>的可转位部分的表示。结果为空或仅为<literal>T</literal>表示不可索引查询。
       </para>
       <para>
        <literal>querytree('foo &amp; ! bar'::tsquery)</literal>
        <returnvalue>'foo'</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>setweight</primary>
        </indexterm>
        <function>setweight</function> ( <parameter>vector</parameter> <type>tsvector</type>, <parameter>weight</parameter> <type>"char"</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        Assigns the specified <parameter>weight</parameter> to each element
        of the <parameter>vector</parameter>.
       </para>
       <para>
        <literal>setweight('fat:2,4 cat:3 rat:5B'::tsvector, 'A')</literal>
        <returnvalue>'cat':3A 'fat':2A,4A 'rat':5A</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>setweight</primary>
        </indexterm>
        <function>setweight</function> ( <parameter>vector</parameter> <type>tsvector</type>, <parameter>weight</parameter> <type>"char"</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        将指定的<parameter>weight</parameter>赋给<parameter>vector</parameter>的每个元素。
       </para>
       <para>
        <literal>setweight('fat:2,4 cat:3 rat:5B'::tsvector, 'A')</literal>
        <returnvalue>'cat':3A 'fat':2A,4A 'rat':5A</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>setweight</primary>
         <secondary>setweight for specific lexeme(s)</secondary>
        </indexterm>
        <function>setweight</function> ( <parameter>vector</parameter> <type>tsvector</type>, <parameter>weight</parameter> <type>"char"</type>, <parameter>lexemes</parameter> <type>text[]</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        Assigns the specified <parameter>weight</parameter> to elements
        of the <parameter>vector</parameter> that are listed
        in <parameter>lexemes</parameter>.
       </para>
       <para>
        <literal>setweight('fat:2,4 cat:3 rat:5,6B'::tsvector, 'A', '{cat,rat}')</literal>
        <returnvalue>'cat':3A 'fat':2,4 'rat':5A,6A</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>setweight</primary>
         <secondary>setweight for specific lexeme(s)</secondary>
        </indexterm>
        <function>setweight</function> ( <parameter>vector</parameter> <type>tsvector</type>, <parameter>weight</parameter> <type>"char"</type>, <parameter>lexemes</parameter> <type>text[]</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        将指定的<parameter>weight</parameter>赋给列在<parameter>lexemes</parameter>中的<parameter>vector</parameter>元素。
       </para>
       <para>
        <literal>setweight('fat:2,4 cat:3 rat:5,6B'::tsvector, 'A', '{cat,rat}')</literal>
        <returnvalue>'cat':3A 'fat':2,4 'rat':5A,6A</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>strip</primary>
        </indexterm>
        <function>strip</function> ( <type>tsvector</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        Removes positions and weights from the <type>tsvector</type>.
       </para>
       <para>
        <literal>strip('fat:2,4 cat:3 rat:5A'::tsvector)</literal>
        <returnvalue>'cat' 'fat' 'rat'</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>strip</primary>
        </indexterm>
        <function>strip</function> ( <type>tsvector</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        从<type>tsvector</type>中移除位置和权重。
       </para>
       <para>
        <literal>strip('fat:2,4 cat:3 rat:5A'::tsvector)</literal>
        <returnvalue>'cat' 'fat' 'rat'</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_tsquery</primary>
        </indexterm>
        <function>to_tsquery</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>query</parameter> <type>text</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        Converts text to a <type>tsquery</type>, normalizing words according to
        the specified or default configuration.  The words must be combined
        by valid <type>tsquery</type> operators.
       </para>
       <para>
        <literal>to_tsquery('english', 'The &amp; Fat &amp; Rats')</literal>
        <returnvalue>'fat' &amp; 'rat'</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_tsquery</primary>
        </indexterm>
        <function>to_tsquery</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>query</parameter> <type>text</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        将文本转换为<type>tsquery</type>，根据指定的或默认配置对单词进行标准化。单词必须由有效的<type>tsquery</type>操作符组合。
       </para>
       <para>
        <literal>to_tsquery('english', 'The &amp; Fat &amp; Rats')</literal>
        <returnvalue>'fat' &amp; 'rat'</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_tsvector</primary>
        </indexterm>
        <function>to_tsvector</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
         <parameter>document</parameter> <type>text</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        Converts text to a <type>tsvector</type>, normalizing words according
        to the specified or default configuration.  Position information is
        included in the result.
       </para>
       <para>
        <literal>to_tsvector('english', 'The Fat Rats')</literal>
        <returnvalue>'fat':2 'rat':3</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_tsvector</primary>
        </indexterm>
        <function>to_tsvector</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
         <parameter>document</parameter> <type>text</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        将文本转换为<type>tsvector</type>，根据指定的或默认配置对单词进行标准化。结果中包含位置信息。
       </para>
       <para>
        <literal>to_tsvector('english', 'The Fat Rats')</literal>
        <returnvalue>'fat':2 'rat':3</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>to_tsvector</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>json</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para role="func_signature">
        <function>to_tsvector</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>jsonb</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        Converts each string value in the JSON document to
        a <type>tsvector</type>, normalizing words according to the specified
        or default configuration.  The results are then concatenated in
        document order to produce the output.  Position information is
        generated as though one stopword exists between each pair of string
        values.  (Beware that <quote>document order</quote> of the fields of a
        JSON object is implementation-dependent when the input
        is <type>jsonb</type>; observe the difference in the examples.)
       </para>
       <para>
        <literal>to_tsvector('english', '{"aa": "The Fat Rats", "b": "dog"}'::json)</literal>
        <returnvalue>'dog':5 'fat':2 'rat':3</returnvalue>
       </para>
       <para>
        <literal>to_tsvector('english', '{"aa": "The Fat Rats", "b": "dog"}'::jsonb)</literal>
        <returnvalue>'dog':1 'fat':4 'rat':5</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>to_tsvector</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>json</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para role="func_signature">
        <function>to_tsvector</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>jsonb</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        将JSON文档中的每个字符串值转换为<type>tsvector</type>，根据指定的或默认配置对单词进行标准化。
        然后将结果按文档顺序连接起来以产生输出。位置信息就像在每对字符串值之间存在一个停止词一样生成。
        (注意，当输入为<type>jsonb</type>时，JSON对象的字段的<quote>document order</quote>取决于实现;请观察这些例子中的差异。)
       </para>
       <para>
        <literal>to_tsvector('english', '{"aa": "The Fat Rats", "b": "dog"}'::json)</literal>
        <returnvalue>'dog':5 'fat':2 'rat':3</returnvalue>
       </para>
       <para>
        <literal>to_tsvector('english', '{"aa": "The Fat Rats", "b": "dog"}'::jsonb)</literal>
        <returnvalue>'dog':1 'fat':4 'rat':5</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_to_tsvector</primary>
        </indexterm>
        <function>json_to_tsvector</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>json</type>,
        <parameter>filter</parameter> <type>jsonb</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_to_tsvector</primary>
        </indexterm>
        <function>jsonb_to_tsvector</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>jsonb</type>,
        <parameter>filter</parameter> <type>jsonb</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        Selects each item in the JSON document that is requested by
        the <parameter>filter</parameter> and converts each one to
        a <type>tsvector</type>, normalizing words according to the specified
        or default configuration.  The results are then concatenated in
        document order to produce the output.  Position information is
        generated as though one stopword exists between each pair of selected
        items.  (Beware that <quote>document order</quote> of the fields of a
        JSON object is implementation-dependent when the input
        is <type>jsonb</type>.)
        The <parameter>filter</parameter> must be a <type>jsonb</type>
        array containing zero or more of these keywords:
        <literal>"string"</literal> (to include all string values),
        <literal>"numeric"</literal> (to include all numeric values),
        <literal>"boolean"</literal> (to include all boolean values),
        <literal>"key"</literal> (to include all keys), or
        <literal>"all"</literal> (to include all the above).
        As a special case, the <parameter>filter</parameter> can also be a
        simple JSON value that is one of these keywords.
       </para>
       <para>
        <literal>json_to_tsvector('english', '{"a": "The Fat Rats", "b": 123}'::json, '["string", "numeric"]')</literal>
        <returnvalue>'123':5 'fat':2 'rat':3</returnvalue>
       </para>
       <para>
        <literal>json_to_tsvector('english', '{"cat": "The Fat Rats", "dog": 123}'::json, '"all"')</literal>
        <returnvalue>'123':9 'cat':1 'dog':7 'fat':4 'rat':5</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_to_tsvector</primary>
        </indexterm>
        <function>json_to_tsvector</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>json</type>,
        <parameter>filter</parameter> <type>jsonb</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_to_tsvector</primary>
        </indexterm>
        <function>jsonb_to_tsvector</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>jsonb</type>,
        <parameter>filter</parameter> <type>jsonb</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        选择<parameter>filter</parameter>请求的JSON文档中的每个项，并将每个项转换为<type>tsvector</type>，根据指定的或默认配置对单词进行标准化。
        然后将结果按文档顺序连接起来以产生输出。位置信息就像在每对选定的项目之间存在一个停止词一样生成。
        (注意，当输入为<type>jsonb</type>时，JSON对象字段的<quote>document order</quote>取决于实现。)
        <parameter>filter</parameter>必须是一个<type>jsonb</type>数组，其中包含0个或多个关键字:
        <literal>"string"</literal>(包括所有字符串值)，
        <literal>"numeric"</literal>(包括所有数值)，
        <literal>"boolean"</literal>(包括所有布尔值)，
        <literal>"key"</literal>(包括所有键)，或
        <literal>"all"</literal>(包括以上所有关键字)。
        作为一种特殊情况，该<parameter>filter</parameter>也可以是这些关键字之一的简单JSON值。
       </para>
       <para>
        <literal>json_to_tsvector('english', '{"a": "The Fat Rats", "b": 123}'::json, '["string", "numeric"]')</literal>
        <returnvalue>'123':5 'fat':2 'rat':3</returnvalue>
       </para>
       <para>
        <literal>json_to_tsvector('english', '{"cat": "The Fat Rats", "dog": 123}'::json, '"all"')</literal>
        <returnvalue>'123':9 'cat':1 'dog':7 'fat':4 'rat':5</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_delete</primary>
        </indexterm>
        <function>ts_delete</function> ( <parameter>vector</parameter> <type>tsvector</type>, <parameter>lexeme</parameter> <type>text</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        Removes any occurrence of the given <parameter>lexeme</parameter>
        from the <parameter>vector</parameter>.
       </para>
       <para>
        <literal>ts_delete('fat:2,4 cat:3 rat:5A'::tsvector, 'fat')</literal>
        <returnvalue>'cat':3 'rat':5A</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_delete</primary>
        </indexterm>
        <function>ts_delete</function> ( <parameter>vector</parameter> <type>tsvector</type>, <parameter>lexeme</parameter> <type>text</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        从<parameter>vector</parameter>中删除任何出现的给定<parameter>lexeme</parameter>。
       </para>
       <para>
        <literal>ts_delete('fat:2,4 cat:3 rat:5A'::tsvector, 'fat')</literal>
        <returnvalue>'cat':3 'rat':5A</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>ts_delete</function> ( <parameter>vector</parameter> <type>tsvector</type>, <parameter>lexemes</parameter> <type>text[]</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        Removes any occurrences of the lexemes
        in <parameter>lexemes</parameter>
        from the <parameter>vector</parameter>.
       </para>
       <para>
        <literal>ts_delete('fat:2,4 cat:3 rat:5A'::tsvector, ARRAY['fat','rat'])</literal>
        <returnvalue>'cat':3</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>ts_delete</function> ( <parameter>vector</parameter> <type>tsvector</type>, <parameter>lexemes</parameter> <type>text[]</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        从<parameter>vector</parameter>中删除<parameter>lexemes</parameter>中出现的任何词位。
       </para>
       <para>
        <literal>ts_delete('fat:2,4 cat:3 rat:5A'::tsvector, ARRAY['fat','rat'])</literal>
        <returnvalue>'cat':3</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_filter</primary>
        </indexterm>
        <function>ts_filter</function> ( <parameter>vector</parameter> <type>tsvector</type>, <parameter>weights</parameter> <type>"char"[]</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        Selects only elements with the given <parameter>weights</parameter>
        from the <parameter>vector</parameter>.
       </para>
       <para>
        <literal>ts_filter('fat:2,4 cat:3b,7c rat:5A'::tsvector, '{a,b}')</literal>
        <returnvalue>'cat':3B 'rat':5A</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_filter</primary>
        </indexterm>
        <function>ts_filter</function> ( <parameter>vector</parameter> <type>tsvector</type>, <parameter>weights</parameter> <type>"char"[]</type> )
        <returnvalue>tsvector</returnvalue>
       </para>
       <para>
        只从<parameter>vector</parameter>中选择具有给定<parameter>weights</parameter>的元素。
       </para>
       <para>
        <literal>ts_filter('fat:2,4 cat:3b,7c rat:5A'::tsvector, '{a,b}')</literal>
        <returnvalue>'cat':3B 'rat':5A</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_headline</primary>
        </indexterm>
        <function>ts_headline</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>text</type>,
        <parameter>query</parameter> <type>tsquery</type>
        <optional>, <parameter>options</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Displays, in an abbreviated form, the match(es) for
        the <parameter>query</parameter> in
        the <parameter>document</parameter>, which must be raw text not
        a <type>tsvector</type>.  Words in the document are normalized
        according to the specified or default configuration before matching to
        the query.  Use of this function is discussed in
        <xref linkend="textsearch-headline"/>, which also describes the
        available <parameter>options</parameter>.
       </para>
       <para>
        <literal>ts_headline('The fat cat ate the rat.', 'cat')</literal>
        <returnvalue>The fat &lt;b&gt;cat&lt;/b&gt; ate the rat.</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_headline</primary>
        </indexterm>
        <function>ts_headline</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>text</type>,
        <parameter>query</parameter> <type>tsquery</type>
        <optional>, <parameter>options</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        以缩写形式显示<parameter>document</parameter>中<parameter>query</parameter>的匹配项，该匹配项必须是原始文本，而不是<type>tsvector</type>。
        在匹配查询之前，文档中的单词将根据指定的或默认的配置进行规范化。
        <xref linkend="textsearch-headline"/>中讨论了该函数的使用，还描述了可用的<parameter>options</parameter>。
       </para>
       <para>
        <literal>ts_headline('The fat cat ate the rat.', 'cat')</literal>
        <returnvalue>The fat &lt;b&gt;cat&lt;/b&gt; ate the rat.</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>ts_headline</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>json</type>,
        <parameter>query</parameter> <type>tsquery</type>
        <optional>, <parameter>options</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>ts_headline</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>jsonb</type>,
        <parameter>query</parameter> <type>tsquery</type>
        <optional>, <parameter>options</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Displays, in an abbreviated form, match(es) for
        the <parameter>query</parameter> that occur in string values
        within the JSON <parameter>document</parameter>.
        See <xref linkend="textsearch-headline"/> for more details.
       </para>
       <para>
        <literal>ts_headline('{"cat":"raining cats and dogs"}'::jsonb, 'cat')</literal>
        <returnvalue>{"cat": "raining &lt;b&gt;cats&lt;/b&gt; and dogs"}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>ts_headline</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>json</type>,
        <parameter>query</parameter> <type>tsquery</type>
        <optional>, <parameter>options</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>ts_headline</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>jsonb</type>,
        <parameter>query</parameter> <type>tsquery</type>
        <optional>, <parameter>options</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        以缩写形式显示匹配JSON<parameter>document</parameter>中字符串值中的<parameter>query</parameter>。
        更多细节请参阅 <xref linkend="textsearch-headline"/>。
       </para>
       <para>
        <literal>ts_headline('{"cat":"raining cats and dogs"}'::jsonb, 'cat')</literal>
        <returnvalue>{"cat": "raining &lt;b&gt;cats&lt;/b&gt; and dogs"}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_rank</primary>
        </indexterm>
        <function>ts_rank</function> (
        <optional> <parameter>weights</parameter> <type>real[]</type>, </optional>
        <parameter>vector</parameter> <type>tsvector</type>,
        <parameter>query</parameter> <type>tsquery</type>
        <optional>, <parameter>normalization</parameter> <type>integer</type> </optional> )
        <returnvalue>real</returnvalue>
       </para>
       <para>
        Computes a score showing how well
        the <parameter>vector</parameter> matches
        the <parameter>query</parameter>.  See
        <xref linkend="textsearch-ranking"/> for details.
       </para>
       <para>
        <literal>ts_rank(to_tsvector('raining cats and dogs'), 'cat')</literal>
        <returnvalue>0.06079271</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_rank</primary>
        </indexterm>
        <function>ts_rank</function> (
        <optional> <parameter>weights</parameter> <type>real[]</type>, </optional>
        <parameter>vector</parameter> <type>tsvector</type>,
        <parameter>query</parameter> <type>tsquery</type>
        <optional>, <parameter>normalization</parameter> <type>integer</type> </optional> )
        <returnvalue>real</returnvalue>
       </para>
       <para>
        计算一个分数，显示<parameter>vector</parameter>与<parameter>query</parameter>的匹配程度。详情请参见<xref linkend="textsearch-ranking"/>。
       </para>
       <para>
        <literal>ts_rank(to_tsvector('raining cats and dogs'), 'cat')</literal>
        <returnvalue>0.06079271</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_rank_cd</primary>
        </indexterm>
        <function>ts_rank_cd</function> (
        <optional> <parameter>weights</parameter> <type>real[]</type>, </optional>
        <parameter>vector</parameter> <type>tsvector</type>,
        <parameter>query</parameter> <type>tsquery</type>
        <optional>, <parameter>normalization</parameter> <type>integer</type> </optional> )
        <returnvalue>real</returnvalue>
       </para>
       <para>
        Computes a score showing how well
        the <parameter>vector</parameter> matches
        the <parameter>query</parameter>, using a cover density
        algorithm.  See <xref linkend="textsearch-ranking"/> for details.
       </para>
       <para>
        <literal>ts_rank_cd(to_tsvector('raining cats and dogs'), 'cat')</literal>
        <returnvalue>0.1</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_rank_cd</primary>
        </indexterm>
        <function>ts_rank_cd</function> (
        <optional> <parameter>weights</parameter> <type>real[]</type>, </optional>
        <parameter>vector</parameter> <type>tsvector</type>,
        <parameter>query</parameter> <type>tsquery</type>
        <optional>, <parameter>normalization</parameter> <type>integer</type> </optional> )
        <returnvalue>real</returnvalue>
       </para>
       <para>
        使用覆盖密度算法计算一个分数，显示<parameter>vector</parameter>与<parameter>query</parameter>的匹配程度。
        详情参见<xref linkend="textsearch-ranking"/>。
       </para>
       <para>
        <literal>ts_rank_cd(to_tsvector('raining cats and dogs'), 'cat')</literal>
        <returnvalue>0.1</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_rewrite</primary>
        </indexterm>
        <function>ts_rewrite</function> ( <parameter>query</parameter> <type>tsquery</type>,
        <parameter>target</parameter> <type>tsquery</type>,
        <parameter>substitute</parameter> <type>tsquery</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        Replaces occurrences of <parameter>target</parameter>
        with <parameter>substitute</parameter>
        within the <parameter>query</parameter>.
        See <xref linkend="textsearch-query-rewriting"/> for details.
       </para>
       <para>
        <literal>ts_rewrite('a &amp; b'::tsquery, 'a'::tsquery, 'foo|bar'::tsquery)</literal>
        <returnvalue>'b' &amp; ( 'foo' | 'bar' )</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_rewrite</primary>
        </indexterm>
        <function>ts_rewrite</function> ( <parameter>query</parameter> <type>tsquery</type>,
        <parameter>target</parameter> <type>tsquery</type>,
        <parameter>substitute</parameter> <type>tsquery</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        在<parameter>query</parameter>中使用 <parameter>substitute</parameter>替换出现的<parameter>target</parameter>。
        详情参见 <xref linkend="textsearch-query-rewriting"/> 。
       </para>
       <para>
        <literal>ts_rewrite('a &amp; b'::tsquery, 'a'::tsquery, 'foo|bar'::tsquery)</literal>
        <returnvalue>'b' &amp; ( 'foo' | 'bar' )</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>ts_rewrite</function> ( <parameter>query</parameter> <type>tsquery</type>,
        <parameter>select</parameter> <type>text</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        Replaces portions of the <parameter>query</parameter> according to
        target(s) and substitute(s) obtained by executing
        a <command>SELECT</command> command.
        See <xref linkend="textsearch-query-rewriting"/> for details.
       </para>
       <para>
        <literal>SELECT ts_rewrite('a &amp; b'::tsquery, 'SELECT t,s FROM aliases')</literal>
        <returnvalue>'b' &amp; ( 'foo' | 'bar' )</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>ts_rewrite</function> ( <parameter>query</parameter> <type>tsquery</type>,
        <parameter>select</parameter> <type>text</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        根据目标替换部分<parameter>query</parameter>，并替换通过执行<command>SELECT</command>命令获得的查询。
        详情参见<xref linkend="textsearch-query-rewriting"/>。
       </para>
       <para>
        <literal>SELECT ts_rewrite('a &amp; b'::tsquery, 'SELECT t,s FROM aliases')</literal>
        <returnvalue>'b' &amp; ( 'foo' | 'bar' )</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>tsquery_phrase</primary>
        </indexterm>
        <function>tsquery_phrase</function> ( <parameter>query1</parameter> <type>tsquery</type>, <parameter>query2</parameter> <type>tsquery</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        Constructs a phrase query that searches
        for matches of <parameter>query1</parameter>
        and <parameter>query2</parameter> at successive lexemes (same
        as <literal>&lt;-&gt;</literal> operator).
       </para>
       <para>
        <literal>tsquery_phrase(to_tsquery('fat'), to_tsquery('cat'))</literal>
        <returnvalue>'fat' &lt;-&gt; 'cat'</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>tsquery_phrase</primary>
        </indexterm>
        <function>tsquery_phrase</function> ( <parameter>query1</parameter> <type>tsquery</type>, <parameter>query2</parameter> <type>tsquery</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        构造一个短语查询，在连续的词位上搜索<parameter>query1</parameter>和<parameter>query2</parameter>的匹配项(与<literal>&lt;-&gt;</literal>操作符相同)。
       </para>
       <para>
        <literal>tsquery_phrase(to_tsquery('fat'), to_tsquery('cat'))</literal>
        <returnvalue>'fat' &lt;-&gt; 'cat'</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>tsquery_phrase</function> ( <parameter>query1</parameter> <type>tsquery</type>, <parameter>query2</parameter> <type>tsquery</type>, <parameter>distance</parameter> <type>integer</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        Constructs a phrase query that searches
        for matches of <parameter>query1</parameter> and
        <parameter>query2</parameter> that occur exactly
        <parameter>distance</parameter> lexemes apart.
       </para>
       <para>
        <literal>tsquery_phrase(to_tsquery('fat'), to_tsquery('cat'), 10)</literal>
        <returnvalue>'fat' &lt;10&gt; 'cat'</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>tsquery_phrase</function> ( <parameter>query1</parameter> <type>tsquery</type>, <parameter>query2</parameter> <type>tsquery</type>, <parameter>distance</parameter> <type>integer</type> )
        <returnvalue>tsquery</returnvalue>
       </para>
       <para>
        构造一个短语查询，用于搜索<parameter>query1</parameter>和<parameter>query2</parameter>的匹配项，这些匹配项恰好出现在<parameter>distance</parameter>词位之间。
       </para>
       <para>
        <literal>tsquery_phrase(to_tsquery('fat'), to_tsquery('cat'), 10)</literal>
        <returnvalue>'fat' &lt;10&gt; 'cat'</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>tsvector_to_array</primary>
        </indexterm>
        <function>tsvector_to_array</function> ( <type>tsvector</type> )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
        Converts a <type>tsvector</type> to an array of lexemes.
       </para>
       <para>
        <literal>tsvector_to_array('fat:2,4 cat:3 rat:5A'::tsvector)</literal>
        <returnvalue>{cat,fat,rat}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>tsvector_to_array</primary>
        </indexterm>
        <function>tsvector_to_array</function> ( <type>tsvector</type> )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
        将<type>tsvector</type>转换为词位的数组。
       </para>
       <para>
        <literal>tsvector_to_array('fat:2,4 cat:3 rat:5A'::tsvector)</literal>
        <returnvalue>{cat,fat,rat}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>unnest</primary>
         <secondary>for tsvector</secondary>
        </indexterm>
        <function>unnest</function> ( <type>tsvector</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>lexeme</parameter> <type>text</type>,
        <parameter>positions</parameter> <type>smallint[]</type>,
        <parameter>weights</parameter> <type>text</type> )
       </para>
       <para>
        Expands a <type>tsvector</type> into a set of rows, one per lexeme.
       </para>
       <para>
        <literal>select * from unnest('cat:3 fat:2,4 rat:5A'::tsvector)</literal>
        <returnvalue></returnvalue>
<programlisting>
 lexeme | positions | weights
-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-
 cat    | {3}       | {D}
 fat    | {2,4}     | {D,D}
 rat    | {5}       | {A}
</programlisting>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>unnest</primary>
         <secondary>for tsvector</secondary>
        </indexterm>
        <function>unnest</function> ( <type>tsvector</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>lexeme</parameter> <type>text</type>,
        <parameter>positions</parameter> <type>smallint[]</type>,
        <parameter>weights</parameter> <type>text</type> )
       </para>
       <para>
        将<type>tsvector</type>展开为一组行，每个行对应一个词位。
       </para>
       <para>
        <literal>select * from unnest('cat:3 fat:2,4 rat:5A'::tsvector)</literal>
        <returnvalue></returnvalue>
<programlisting>
 lexeme | positions | weights
--------+-----------+---------
 cat    | {3}       | {D}
 fat    | {2,4}     | {D,D}
 rat    | {5}       | {A}
</programlisting>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <note>
<!--==========================orignal english content==========================
   <para>
    All the text search functions that accept an optional <type>regconfig</type>
    argument will use the configuration specified by
    <xref linkend="guc-default-text-search-config"/>
    when that argument is omitted.
   </para>
____________________________________________________________________________-->
   <para>
    所有接受一个可选的<type>regconfig</type>参数的文本搜索函数在该参数被忽略时，使用由<xref linkend="guc-default-text-search-config"/>指定的配置。
   </para>
  </note>

<!--==========================orignal english content==========================
  <para>
   The functions in
   <xref linkend="textsearch-functions-debug-table"/>
   are listed separately because they are not usually used in everyday text
   searching operations.  They are primarily helpful for development and
   debugging of new text search configurations.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="textsearch-functions-debug-table"/>中的函数被单独列出，因为它们通常不被用于日常的文本搜索操作。 
   它们主要有助于开发和调试新的文本搜索配置。
  </para>

   <table id="textsearch-functions-debug-table">
<!--==========================orignal english content==========================
    <title>Text Search Debugging Functions</title>
____________________________________________________________________________-->
    <title>文本搜索调试函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_debug</primary>
        </indexterm>
        <function>ts_debug</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>text</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>alias</parameter> <type>text</type>,
        <parameter>description</parameter> <type>text</type>,
        <parameter>token</parameter> <type>text</type>,
        <parameter>dictionaries</parameter> <type>regdictionary[]</type>,
        <parameter>dictionary</parameter> <type>regdictionary</type>,
        <parameter>lexemes</parameter> <type>text[]</type> )
       </para>
       <para>
        Extracts and normalizes tokens from
        the <parameter>document</parameter> according to the specified or
        default text search configuration, and returns information about how
        each token was processed.
        See <xref linkend="textsearch-configuration-testing"/> for details.
       </para>
       <para>
        <literal>ts_debug('english', 'The Brightest supernovaes')</literal>
        <returnvalue>(asciiword,"Word, all ASCII",The,{english_stem},english_stem,{}) ...</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_debug</primary>
        </indexterm>
        <function>ts_debug</function> (
        <optional> <parameter>config</parameter> <type>regconfig</type>, </optional>
        <parameter>document</parameter> <type>text</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>alias</parameter> <type>text</type>,
        <parameter>description</parameter> <type>text</type>,
        <parameter>token</parameter> <type>text</type>,
        <parameter>dictionaries</parameter> <type>regdictionary[]</type>,
        <parameter>dictionary</parameter> <type>regdictionary</type>,
        <parameter>lexemes</parameter> <type>text[]</type> )
       </para>
       <para>
        根据指定的或默认的文本搜索配置从<parameter>document</parameter>中提取和标准化标记，并返回关于每个标记是如何处理的信息。
        详请参见<xref linkend="textsearch-configuration-testing"/>。
       </para>
       <para>
        <literal>ts_debug('english', 'The Brightest supernovaes')</literal>
        <returnvalue>(asciiword,"Word, all ASCII",The,{english_stem},english_stem,{}) ...</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_lexize</primary>
        </indexterm>
        <function>ts_lexize</function> ( <parameter>dict</parameter> <type>regdictionary</type>, <parameter>token</parameter> <type>text</type> )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
        Returns an array of replacement lexemes if the input token is known to
        the dictionary, or an empty array if the token is known to the
        dictionary but it is a stop word, or NULL if it is not a known word.
        See <xref linkend="textsearch-dictionary-testing"/> for details.
       </para>
       <para>
        <literal>ts_lexize('english_stem', 'stars')</literal>
        <returnvalue>{star}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_lexize</primary>
        </indexterm>
        <function>ts_lexize</function> ( <parameter>dict</parameter> <type>regdictionary</type>, <parameter>token</parameter> <type>text</type> )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
        如果字典知道输入标记，则返回替换词位数组;如果字典知道标记，但它是停止词，则返回空数组;如果它不是已知词，则返回NULL。
        详情参见<xref linkend="textsearch-dictionary-testing"/>。
       </para>
       <para>
        <literal>ts_lexize('english_stem', 'stars')</literal>
        <returnvalue>{star}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_parse</primary>
        </indexterm>
        <function>ts_parse</function> ( <parameter>parser_name</parameter> <type>text</type>,
        <parameter>document</parameter> <type>text</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>tokid</parameter> <type>integer</type>,
        <parameter>token</parameter> <type>text</type> )
       </para>
       <para>
        Extracts tokens from the <parameter>document</parameter> using the
        named parser.
        See <xref linkend="textsearch-parser-testing"/> for details.
       </para>
       <para>
        <literal>ts_parse('default', 'foo - bar')</literal>
        <returnvalue>(1,foo) ...</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_parse</primary>
        </indexterm>
        <function>ts_parse</function> ( <parameter>parser_name</parameter> <type>text</type>,
        <parameter>document</parameter> <type>text</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>tokid</parameter> <type>integer</type>,
        <parameter>token</parameter> <type>text</type> )
       </para>
       <para>
        使用命名的解析器从<parameter>document</parameter>中提取标记。详情参见<xref linkend="textsearch-parser-testing"/>。
       </para>
       <para>
        <literal>ts_parse('default', 'foo - bar')</literal>
        <returnvalue>(1,foo) ...</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>ts_parse</function> ( <parameter>parser_oid</parameter> <type>oid</type>,
        <parameter>document</parameter> <type>text</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>tokid</parameter> <type>integer</type>,
        <parameter>token</parameter> <type>text</type> )
       </para>
       <para>
        Extracts tokens from the <parameter>document</parameter> using a
        parser specified by OID.
        See <xref linkend="textsearch-parser-testing"/> for details.
       </para>
       <para>
        <literal>ts_parse(3722, 'foo - bar')</literal>
        <returnvalue>(1,foo) ...</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>ts_parse</function> ( <parameter>parser_oid</parameter> <type>oid</type>,
        <parameter>document</parameter> <type>text</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>tokid</parameter> <type>integer</type>,
        <parameter>token</parameter> <type>text</type> )
       </para>
       <para>
        使用OID指定的解析器从<parameter>document</parameter>中提取标记。
        详请参见 <xref linkend="textsearch-parser-testing"/> 。
       </para>
       <para>
        <literal>ts_parse(3722, 'foo - bar')</literal>
        <returnvalue>(1,foo) ...</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_token_type</primary>
        </indexterm>
        <function>ts_token_type</function> ( <parameter>parser_name</parameter> <type>text</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>tokid</parameter> <type>integer</type>,
        <parameter>alias</parameter> <type>text</type>,
        <parameter>description</parameter> <type>text</type> )
       </para>
       <para>
        Returns a table that describes each type of token the named parser can
        recognize.
        See <xref linkend="textsearch-parser-testing"/> for details.
       </para>
       <para>
        <literal>ts_token_type('default')</literal>
        <returnvalue>(1,asciiword,"Word, all ASCII") ...</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_token_type</primary>
        </indexterm>
        <function>ts_token_type</function> ( <parameter>parser_name</parameter> <type>text</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>tokid</parameter> <type>integer</type>,
        <parameter>alias</parameter> <type>text</type>,
        <parameter>description</parameter> <type>text</type> )
       </para>
       <para>
        返回一个表，该表描述命名解析器可以识别的每种类型的标记。详请参见<xref linkend="textsearch-parser-testing"/>。
       </para>
       <para>
        <literal>ts_token_type('default')</literal>
        <returnvalue>(1,asciiword,"Word, all ASCII") ...</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>ts_token_type</function> ( <parameter>parser_oid</parameter> <type>oid</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>tokid</parameter> <type>integer</type>,
        <parameter>alias</parameter> <type>text</type>,
        <parameter>description</parameter> <type>text</type> )
       </para>
       <para>
        Returns a table that describes each type of token a parser specified
        by OID can recognize.
        See <xref linkend="textsearch-parser-testing"/> for details.
       </para>
       <para>
        <literal>ts_token_type(3722)</literal>
        <returnvalue>(1,asciiword,"Word, all ASCII") ...</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>ts_token_type</function> ( <parameter>parser_oid</parameter> <type>oid</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>tokid</parameter> <type>integer</type>,
        <parameter>alias</parameter> <type>text</type>,
        <parameter>description</parameter> <type>text</type> )
       </para>
       <para>
        返回一个表，该表描述OID指定的解析器可以识别的每种标记类型。详请参见<xref linkend="textsearch-parser-testing"/>。
       </para>
       <para>
        <literal>ts_token_type(3722)</literal>
        <returnvalue>(1,asciiword,"Word, all ASCII") ...</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_stat</primary>
        </indexterm>
        <function>ts_stat</function> ( <parameter>sqlquery</parameter> <type>text</type>
        <optional>, <parameter>weights</parameter> <type>text</type> </optional> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>word</parameter> <type>text</type>,
        <parameter>ndoc</parameter> <type>integer</type>,
        <parameter>nentry</parameter> <type>integer</type> )
       </para>
       <para>
        Executes the <parameter>sqlquery</parameter>, which must return a
        single <type>tsvector</type> column, and returns statistics about each
        distinct lexeme contained in the data.
        See <xref linkend="textsearch-statistics"/> for details.
       </para>
       <para>
        <literal>ts_stat('SELECT vector FROM apod')</literal>
        <returnvalue>(foo,10,15) ...</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ts_stat</primary>
        </indexterm>
        <function>ts_stat</function> ( <parameter>sqlquery</parameter> <type>text</type>
        <optional>, <parameter>weights</parameter> <type>text</type> </optional> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>word</parameter> <type>text</type>,
        <parameter>ndoc</parameter> <type>integer</type>,
        <parameter>nentry</parameter> <type>integer</type> )
       </para>
       <para>
        执行<parameter>sqlquery</parameter>，该查询必须返回单个<type>tsvector</type>列，并返回关于数据中包含的每个不同词位的统计信息。
        详请参见<xref linkend="textsearch-statistics"/>。
       </para>
       <para>
        <literal>ts_stat('SELECT vector FROM apod')</literal>
        <returnvalue>(foo,10,15) ...</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

 </sect1>

 <sect1 id="functions-uuid">
<!--==========================orignal english content==========================
  <title>UUID Functions</title>
____________________________________________________________________________-->
  <title>UUID 函数</title>

<!--==========================orignal english content==========================
  <indexterm zone="datatype-uuid">
   <primary>UUID</primary>
   <secondary>generating</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="datatype-uuid">
   <primary>UUID</primary>
   <secondary>生成</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>gen_random_uuid</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>gen_random_uuid</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   <productname>PostgreSQL</productname> includes one function to generate a UUID:
<synopsis>
<function>gen_random_uuid</function> () <returnvalue>uuid</returnvalue>
</synopsis>
   This function returns a version 4 (random) UUID.  This is the most commonly
   used type of UUID and is appropriate for most applications.
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname> 包含一个函数来生成UUID:
<synopsis>
<function>gen_random_uuid</function> () <returnvalue>uuid</returnvalue>
</synopsis>
   此函数返回一个版本4(随机)的UUID。这是最常用的UUID类型，适用于大多数应用程序。
  </para>

<!--==========================orignal english content==========================
  <para>
   The <xref linkend="uuid-ossp"/> module provides additional functions that
   implement other standard algorithms for generating UUIDs.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="uuid-ossp"/>模块提供了额外的功能，用于实现生成UUIDs的其他标准算法。
  </para>

<!--==========================orignal english content==========================
  <para>
   <productname>PostgreSQL</productname> also provides the usual comparison
   operators shown in <xref linkend="functions-comparison-op-table"/> for
   UUIDs.
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>还为UUIDs提供了<xref linkend="functions-comparison-op-table"/>中所示的常用比较操作符。
  </para>
 </sect1>

 <sect1 id="functions-xml">

<!--==========================orignal english content==========================
  <title>XML Functions</title>
____________________________________________________________________________-->
  <title>XML 函数</title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>XML Functions</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>XML 函数</primary>
  </indexterm>
<!--==========================orignal english content==========================
  <para>
   The functions and function-like expressions described in this
   section operate on values of type <type>xml</type>.  See <xref
   linkend="datatype-xml"/> for information about the <type>xml</type>
   type.  The function-like expressions <function>xmlparse</function>
   and <function>xmlserialize</function> for converting to and from
   type <type>xml</type> are documented there, not in this section.
  </para>
____________________________________________________________________________-->
  <para>
   本节中描述的函数以及类函数的表达式都在类型<type>xml</type>的值上操作。类型<type>xml</type>的详细信息请参见<xref linkend="datatype-xml"/>。用于在值和类型<type>xml</type>之间转换的类函数的表达式<function>xmlparse</function>和<function>xmlserialize</function>记录在这里，而不是在本节中。
</para>

<!--==========================orignal english content==========================
  <para>
   Use of most of these functions
   requires <productname>PostgreSQL</productname> to have been built
   with <command>configure -&minus;with-libxml</command>.
  </para>
____________________________________________________________________________-->
  <para>
   使用大部分这些函数要求<productname>PostgreSQL</productname>使用了<command>configure --with-libxml</command>进行编译。
  </para>

  <sect2 id="functions-producing-xml">
<!--==========================orignal english content==========================
   <title>Producing XML Content</title>
____________________________________________________________________________-->
   <title>产生 XML 内容</title>

<!--==========================orignal english content==========================
   <para>
    A set of functions and function-like expressions is available for
    producing XML content from SQL data.  As such, they are
    particularly suitable for formatting query results into XML
    documents for processing in client applications.
   </para>
____________________________________________________________________________-->
   <para>
    有一组函数和类函数的表达式可以用来从 SQL 数据产生 XML 内容。它们特别适合于将查询结果格式化成 XML 文档以便于在客户端应用中处理。
   </para>

   <sect3>
<!--==========================orignal english content==========================
    <title><literal>xmlcomment</literal></title>
____________________________________________________________________________-->
    <title><literal>xmlcomment</literal></title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>xmlcomment</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>xmlcomment</primary>
    </indexterm>

<!--==========================orignal english content==========================
<synopsis>
<function>xmlcomment</function> ( <type>text</type> ) <returnvalue>xml</returnvalue>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<function>xmlcomment</function> ( <type>text</type> ) <returnvalue>xml</returnvalue>
</synopsis>

<!--==========================orignal english content==========================
    <para>
     The function <function>xmlcomment</function> creates an XML value
     containing an XML comment with the specified text as content.
     The text cannot contain <quote><literal>-&minus;</literal></quote> or end with a
     <quote><literal>-</literal></quote>, otherwise the resulting construct
     would not be a valid XML comment.
     If the argument is null, the result is null.
    </para>
____________________________________________________________________________-->
    <para>
     函数<function>xmlcomment</function>创建了一个 XML 值，它包含一个使用指定文本作为内容的 XML 注释。
     该文本不包含<quote><literal>--</literal></quote>或者也不会以一个<quote><literal>-</literal></quote>结尾，否则该结果的结构不是一个合法的 XML 注释。如果参数为空，结果也为空。
    </para>

<!--==========================orignal english content==========================
    <para>
     Example:
<screen><![CDATA[
SELECT xmlcomment('hello');

  xmlcomment
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 <!-&minus;hello-&minus;>
]]></screen>
    </para>
____________________________________________________________________________-->
    <para>
     例子：
<screen><![CDATA[
SELECT xmlcomment('hello');

  xmlcomment
--------------
 <!--hello-->
]]></screen>
    </para>
   </sect3>

   <sect3>
<!--==========================orignal english content==========================
    <title><literal>xmlconcat</literal></title>
____________________________________________________________________________-->
    <title><literal>xmlconcat</literal></title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>xmlconcat</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>xmlconcat</primary>
    </indexterm>

<!--==========================orignal english content==========================
<synopsis>
<function>xmlconcat</function> ( <type>xml</type> <optional>, ...</optional> ) <returnvalue>xml</returnvalue>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<function>xmlconcat</function> ( <type>xml</type> <optional>, ...</optional> ) <returnvalue>xml</returnvalue>
</synopsis>

<!--==========================orignal english content==========================
    <para>
     The function <function>xmlconcat</function> concatenates a list
     of individual XML values to create a single value containing an
     XML content fragment.  Null values are omitted; the result is
     only null if there are no nonnull arguments.
    </para>
____________________________________________________________________________-->
    <para>
     函数<function>xmlconcat</function>将由单个 XML 值组成的列表串接成一个单独的值，这个值包含一个 XML 内容片断。空值会被忽略，只有当没有参数为非空时结果才为空。
    </para>

<!--==========================orignal english content==========================
    <para>
     Example:
<screen><![CDATA[
SELECT xmlconcat('<abc/>', '<bar>foo</bar>');

      xmlconcat
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 <abc/><bar>foo</bar>
]]></screen>
    </para>
____________________________________________________________________________-->
    <para>
     例子：
<screen><![CDATA[
SELECT xmlconcat('<abc/>', '<bar>foo</bar>');

      xmlconcat
----------------------
 <abc/><bar>foo</bar>
]]></screen>
    </para>

<!--==========================orignal english content==========================
    <para>
     XML declarations, if present, are combined as follows.  If all
     argument values have the same XML version declaration, that
     version is used in the result, else no version is used.  If all
     argument values have the standalone declaration value
     <quote>yes</quote>, then that value is used in the result.  If
     all argument values have a standalone declaration value and at
     least one is <quote>no</quote>, then that is used in the result.
     Else the result will have no standalone declaration.  If the
     result is determined to require a standalone declaration but no
     version declaration, a version declaration with version 1.0 will
     be used because XML requires an XML declaration to contain a
     version declaration.  Encoding declarations are ignored and
     removed in all cases.
    </para>
____________________________________________________________________________-->
    <para>
     如果 XML 声明存在，它们会按照下面的方式被组合。如果所有的参数值都有相同的 XML 版本声明，该版本将被用在结果中，否则将不使用版本。如果所有参数值有独立声明值<quote>yes</quote>，那么该值将被用在结果中。如果所有参数值都有一个独立声明值并且至少有一个为<quote>no</quote>，则<quote>no</quote>被用在结果中。否则结果中将没有独立声明。如果结果被决定要要求一个独立声明但是没有版本声明，将会使用一个版本 1.0 的版本声明，因为 XML 要求一个 XML 声明要包含一个版本声明。编码声明会被忽略并且在所有情况中都会被移除。
    </para>

<!--==========================orignal english content==========================
    <para>
     Example:
<screen><![CDATA[
SELECT xmlconcat('<?xml version="1.1"?><foo/>', '<?xml version="1.1" standalone="no"?><bar/>');

             xmlconcat
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 <?xml version="1.1"?><foo/><bar/>
]]></screen>
    </para>
____________________________________________________________________________-->
    <para>
     例子：
<screen><![CDATA[
SELECT xmlconcat('<?xml version="1.1"?><foo/>', '<?xml version="1.1" standalone="no"?><bar/>');

             xmlconcat
-----------------------------------
 <?xml version="1.1"?><foo/><bar/>
]]></screen>
    </para>
   </sect3>

   <sect3>
<!--==========================orignal english content==========================
    <title><literal>xmlelement</literal></title>
____________________________________________________________________________-->
    <title><literal>xmlelement</literal></title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>xmlelement</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>xmlelement</primary>
   </indexterm>

<!--==========================orignal english content==========================
<synopsis>
<function>xmlelement</function> ( <literal>NAME</literal> <replaceable>name</replaceable> <optional>, <literal>XMLATTRIBUTES</literal> ( <replaceable>attvalue</replaceable> <optional> <literal>AS</literal> <replaceable>attname</replaceable> </optional> <optional>, ...</optional> ) </optional> <optional>, <replaceable>content</replaceable> <optional>, ...</optional></optional> ) <returnvalue>xml</returnvalue>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<function>xmlelement</function> ( <literal>NAME</literal> <replaceable>name</replaceable> <optional>, <literal>XMLATTRIBUTES</literal> ( <replaceable>attvalue</replaceable> <optional> <literal>AS</literal> <replaceable>attname</replaceable> </optional> <optional>, ...</optional> ) </optional> <optional>, <replaceable>content</replaceable> <optional>, ...</optional></optional> ) <returnvalue>xml</returnvalue>
</synopsis>

<!--==========================orignal english content==========================
    <para>
     The <function>xmlelement</function> expression produces an XML
     element with the given name, attributes, and content.
     The <replaceable>name</replaceable>
     and <replaceable>attname</replaceable> items shown in the syntax are
     simple identifiers, not values.  The <replaceable>attvalue</replaceable>
     and <replaceable>content</replaceable> items are expressions, which can
     yield any <productname>PostgreSQL</productname> data type.  The
     argument(s) within <literal>XMLATTRIBUTES</literal> generate attributes
     of the XML element; the <replaceable>content</replaceable> value(s) are
     concatenated to form its content.
    </para>
____________________________________________________________________________-->
    <para>
     表达式<function>xmlelement</function>使用给定名称、属性和内容产生一个 XML 元素。
     语法中显示的<replaceable>name</replaceable>和<replaceable>attname</replaceable>项是简单的标识符，而不是值。
     <replaceable>attvalue</replaceable>和<replaceable>content</replaceable>项是表达式，它们可以生成任何<productname>PostgreSQL</productname>数据类型。
     <literal>XMLATTRIBUTES</literal>的参数生成XML元素的属性；将<replaceable>content</replaceable>值连接起来形成其内容。
    </para>

<!--==========================orignal english content==========================
    <para>
     Examples:
<screen><![CDATA[
SELECT xmlelement(name foo);

 xmlelement
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 <foo/>

SELECT xmlelement(name foo, xmlattributes('xyz' as bar));

    xmlelement
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 <foo bar="xyz"/>

SELECT xmlelement(name foo, xmlattributes(current_date as bar), 'cont', 'ent');

             xmlelement
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 <foo bar="2007-01-26">content</foo>
]]></screen>
    </para>
____________________________________________________________________________-->
    <para>
     例子：
<screen><![CDATA[
SELECT xmlelement(name foo);

 xmlelement
------------
 <foo/>

SELECT xmlelement(name foo, xmlattributes('xyz' as bar));

    xmlelement
------------------
 <foo bar="xyz"/>

SELECT xmlelement(name foo, xmlattributes(current_date as bar), 'cont', 'ent');

             xmlelement
-------------------------------------
 <foo bar="2007-01-26">content</foo>
]]></screen>
    </para>

<!--==========================orignal english content==========================
    <para>
     Element and attribute names that are not valid XML names are
     escaped by replacing the offending characters by the sequence
     <literal>_x<replaceable>HHHH</replaceable>_</literal>, where
     <replaceable>HHHH</replaceable> is the character's Unicode
     codepoint in hexadecimal notation.  For example:
<screen><![CDATA[
SELECT xmlelement(name "foo$bar", xmlattributes('xyz' as "a&b"));

            xmlelement
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 <foo_x0024_bar a_x0026_b="xyz"/>
]]></screen>
    </para>
____________________________________________________________________________-->
    <para>
     不是合法 XML 名字的元素名和属性名将被逃逸，逃逸的方法是将违反的字符用序列<literal>_x<replaceable>HHHH</replaceable>_</literal>替换，其中<replaceable>HHHH</replaceable>是被替换字符的 Unicode 代码点的十六进制表示。例如：
<screen><![CDATA[
SELECT xmlelement(name "foo$bar", xmlattributes('xyz' as "a&b"));

            xmlelement
----------------------------------
 <foo_x0024_bar a_x0026_b="xyz"/>
]]></screen>
    </para>

<!--==========================orignal english content==========================
    <para>
     An explicit attribute name need not be specified if the attribute
     value is a column reference, in which case the column's name will
     be used as the attribute name by default.  In other cases, the
     attribute must be given an explicit name.  So this example is
     valid:
<screen>
CREATE TABLE test (a xml, b xml);
SELECT xmlelement(name test, xmlattributes(a, b)) FROM test;
</screen>
     But these are not:
<screen>
SELECT xmlelement(name test, xmlattributes('constant'), a, b) FROM test;
SELECT xmlelement(name test, xmlattributes(func(a, b))) FROM test;
</screen>
    </para>
____________________________________________________________________________-->
    <para>
     如果属性值是一个列引用，则不需要指定一个显式的属性名，在这种情况下列的名字将被默认用于属性的名字。在其他情况下，属性必须被给定一个显式名称。因此这个例子是合法的：
<screen>
CREATE TABLE test (a xml, b xml);
SELECT xmlelement(name test, xmlattributes(a, b)) FROM test;
</screen>
     但是下面这些不合法：
<screen>
SELECT xmlelement(name test, xmlattributes('constant'), a, b) FROM test;
SELECT xmlelement(name test, xmlattributes(func(a, b))) FROM test;
</screen>
    </para>

<!--==========================orignal english content==========================
    <para>
     Element content, if specified, will be formatted according to
     its data type.  If the content is itself of type <type>xml</type>,
     complex XML documents can be constructed.  For example:
<screen><![CDATA[
SELECT xmlelement(name foo, xmlattributes('xyz' as bar),
                            xmlelement(name abc),
                            xmlcomment('test'),
                            xmlelement(name xyz));

                  xmlelement
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 <foo bar="xyz"><abc/><!-&minus;test-&minus;><xyz/></foo>
]]></screen>

     Content of other types will be formatted into valid XML character
     data.  This means in particular that the characters &lt;, &gt;,
     and &amp; will be converted to entities.  Binary data (data type
     <type>bytea</type>) will be represented in base64 or hex
     encoding, depending on the setting of the configuration parameter
     <xref linkend="guc-xmlbinary"/>.  The particular behavior for
     individual data types is expected to evolve in order to align the
     PostgreSQL mappings with those specified in SQL:2006 and later,
     as discussed in <xref linkend="functions-xml-limits-casts"/>.
    </para>
____________________________________________________________________________-->
    <para>
     如果指定了元素内容，它们将被根据其数据类型格式化。如果内容本身也是类型<type>xml</type>，就可以构建复杂的 XML 文档。例如：
<screen><![CDATA[
SELECT xmlelement(name foo, xmlattributes('xyz' as bar),
                            xmlelement(name abc),
                            xmlcomment('test'),
                            xmlelement(name xyz));

                  xmlelement
----------------------------------------------
 <foo bar="xyz"><abc/><!--test--><xyz/></foo>
]]></screen>

     其他类型的内容将被格式化为合法的 XML 字符数据。这意味着字符 &lt;, &gt;, 和 &amp; 将被转换为实体。二进制数据（数据类型<type>bytea</type>）将被表示成 base64 或十六进制编码，具体取决于配置参数<xref linkend="guc-xmlbinary"/>的设置。为了使PostgreSQL的映射与SQL:2006及以后的SQL:2006中指定的映射保持一致，个别数据类型的特殊行为将不断发展，正如<xref linkend="functions-xml-limits-casts"/>中讨论的那样。
    </para>
   </sect3>

   <sect3>
<!--==========================orignal english content==========================
    <title><literal>xmlforest</literal></title>
____________________________________________________________________________-->
    <title><literal>xmlforest</literal></title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>xmlforest</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>xmlforest</primary>
   </indexterm>

<!--==========================orignal english content==========================
<synopsis>
<function>xmlforest</function> ( <replaceable>content</replaceable> <optional> <literal>AS</literal> <replaceable>name</replaceable> </optional> <optional>, ...</optional> ) <returnvalue>xml</returnvalue>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<function>xmlforest</function> ( <replaceable>content</replaceable> <optional> <literal>AS</literal> <replaceable>name</replaceable> </optional> <optional>, ...</optional> ) <returnvalue>xml</returnvalue>
</synopsis>

<!--==========================orignal english content==========================
    <para>
     The <function>xmlforest</function> expression produces an XML
     forest (sequence) of elements using the given names and content.
     As for <function>xmlelement</function>,
     each <replaceable>name</replaceable> must be a simple identifier, while
     the <replaceable>content</replaceable> expressions can have any data
     type.
    </para>
____________________________________________________________________________-->
    <para>
     表达式<function>xmlforest</function>使用给定名称和内容产生一个元素的 XML 森林（序列）。
     对于<function>xmlelement</function>，每个<replaceable>name</replaceable>都必须是一个简单的标识符，而<replaceable>content</replaceable>表达式可以有任何数据类型。
    </para>

<!--==========================orignal english content==========================
    <para>
     Examples:
<screen>
SELECT xmlforest('abc' AS foo, 123 AS bar);

          xmlforest
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 &lt;foo&gt;abc&lt;/foo&gt;&lt;bar&gt;123&lt;/bar&gt;


SELECT xmlforest(table_name, column_name)
FROM information_schema.columns
WHERE table_schema = 'pg_catalog';

                                xmlforest
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;&zwsp;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 &lt;table_name&gt;pg_authid&lt;/table_name&gt;&zwsp;&lt;column_name&gt;rolname&lt;/column_name&gt;
 &lt;table_name&gt;pg_authid&lt;/table_name&gt;&zwsp;&lt;column_name&gt;rolsuper&lt;/column_name&gt;
 ...
</screen>

     As seen in the second example, the element name can be omitted if
     the content value is a column reference, in which case the column
     name is used by default.  Otherwise, a name must be specified.
    </para>
____________________________________________________________________________-->
    <para>
     例子：
<screen>
SELECT xmlforest('abc' AS foo, 123 AS bar);

          xmlforest
------------------------------
 &lt;foo&gt;abc&lt;/foo&gt;&lt;bar&gt;123&lt;/bar&gt;


SELECT xmlforest(table_name, column_name)
FROM information_schema.columns
WHERE table_schema = 'pg_catalog';

                                xmlforest
------------------------------------&zwsp;-----------------------------------
 &lt;table_name&gt;pg_authid&lt;/table_name&gt;&zwsp;&lt;column_name&gt;rolname&lt;/column_name&gt;
 &lt;table_name&gt;pg_authid&lt;/table_name&gt;&zwsp;&lt;column_name&gt;rolsuper&lt;/column_name&gt;
 ...
</screen>

     如我们在第二个例子中所见，如果内容值是一个列引用，元素名称可以被忽略，这种情况下默认使用列名。否则，必须指定一个名字。
    </para>

<!--==========================orignal english content==========================
    <para>
     Element names that are not valid XML names are escaped as shown
     for <function>xmlelement</function> above.  Similarly, content
     data is escaped to make valid XML content, unless it is already
     of type <type>xml</type>.
    </para>
____________________________________________________________________________-->
    <para>
     如上文<function>xmlelement</function>所示，非法 XML 名字的元素名会被逃逸。相似地，内容数据也会被逃逸来产生合法的 XML 内容，除非它已经是一个<type>xml</type>类型。
    </para>

<!--==========================orignal english content==========================
    <para>
     Note that XML forests are not valid XML documents if they consist
     of more than one element, so it might be useful to wrap
     <function>xmlforest</function> expressions in
     <function>xmlelement</function>.
    </para>
____________________________________________________________________________-->
    <para>
     注意如果 XML 森林由多于一个元素组成，那么它不是合法的 XML 文档，因此在<function>xmlelement</function>中包装<function>xmlforest</function>表达式会有用处。
    </para>
   </sect3>

   <sect3>
<!--==========================orignal english content==========================
    <title><literal>xmlpi</literal></title>
____________________________________________________________________________-->
    <title><literal>xmlpi</literal></title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>xmlpi</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>xmlpi</primary>
   </indexterm>

<!--==========================orignal english content==========================
<synopsis>
<function>xmlpi</function> ( <literal>NAME</literal> <replaceable>name</replaceable> <optional>, <replaceable>content</replaceable> </optional> ) <returnvalue>xml</returnvalue>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<function>xmlpi</function> ( <literal>NAME</literal> <replaceable>name</replaceable> <optional>, <replaceable>content</replaceable> </optional> ) <returnvalue>xml</returnvalue>
</synopsis>

<!--==========================orignal english content==========================
    <para>
     The <function>xmlpi</function> expression creates an XML
     processing instruction.
     As for <function>xmlelement</function>,
     the <replaceable>name</replaceable> must be a simple identifier, while
     the <replaceable>content</replaceable> expression can have any data type.
     The <replaceable>content</replaceable>, if present, must not contain the
     character sequence <literal>?&gt;</literal>.
    </para>
____________________________________________________________________________-->
    <para>
     表达式<function>xmlpi</function>创建一个 XML 处理指令。
     对于<function>xmlelement</function>，<replaceable>name</replaceable>必须是一个简单的标识符，而<replaceable>content</replaceable>表达式可以有任何数据类型。如果存在，<replaceable>content</replaceable>不能包含字符序列<literal>?&gt;</literal>。
    </para>

<!--==========================orignal english content==========================
    <para>
     Example:
<screen><![CDATA[
SELECT xmlpi(name php, 'echo "hello world";');

            xmlpi
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 <?php echo "hello world";?>
]]></screen>
    </para>
____________________________________________________________________________-->
    <para>
     例子：
<screen><![CDATA[
SELECT xmlpi(name php, 'echo "hello world";');

            xmlpi
-----------------------------
 <?php echo "hello world";?>
]]></screen>
    </para>
   </sect3>

   <sect3>
<!--==========================orignal english content==========================
    <title><literal>xmlroot</literal></title>
____________________________________________________________________________-->
    <title><literal>xmlroot</literal></title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>xmlroot</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>xmlroot</primary>
   </indexterm>

<!--==========================orignal english content==========================
<synopsis>
<function>xmlroot</function> ( <type>xml</type>, <literal>VERSION</literal> {<type>text</type>|<literal>NO VALUE</literal>} <optional>, <literal>STANDALONE</literal> {<literal>YES</literal>|<literal>NO</literal>|<literal>NO VALUE</literal>} </optional> ) <returnvalue>xml</returnvalue>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<function>xmlroot</function> ( <type>xml</type>, <literal>VERSION</literal> {<type>text</type>|<literal>NO VALUE</literal>} <optional>, <literal>STANDALONE</literal> {<literal>YES</literal>|<literal>NO</literal>|<literal>NO VALUE</literal>} </optional> ) <returnvalue>xml</returnvalue>
</synopsis>

<!--==========================orignal english content==========================
    <para>
     The <function>xmlroot</function> expression alters the properties
     of the root node of an XML value.  If a version is specified,
     it replaces the value in the root node's version declaration; if a
     standalone setting is specified, it replaces the value in the
     root node's standalone declaration.
    </para>
____________________________________________________________________________-->
    <para>
     表达式<function>xmlroot</function>修改一个 XML 值的根结点的属性。如果指定了一个版本，它会替换根节点的版本声明中的值；如果指定了一个独立设置，它会替换根节点的独立声明中的值。
    </para>

<!--==========================orignal english content==========================
    <para>
<screen><![CDATA[
SELECT xmlroot(xmlparse(document '<?xml version="1.1"?><content>abc</content>'),
               version '1.0', standalone yes);

                xmlroot
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 <?xml version="1.0" standalone="yes"?>
 <content>abc</content>
]]></screen>
    </para>
____________________________________________________________________________-->
    <para>
<screen><![CDATA[
SELECT xmlroot(xmlparse(document '<?xml version="1.1"?><content>abc</content>'),
               version '1.0', standalone yes);

                xmlroot
----------------------------------------
 <?xml version="1.0" standalone="yes"?>
 <content>abc</content>
]]></screen>
    </para>
   </sect3>

   <sect3 id="functions-xml-xmlagg">
<!--==========================orignal english content==========================
    <title><literal>xmlagg</literal></title>
____________________________________________________________________________-->
    <title><literal>xmlagg</literal></title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>xmlagg</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>xmlagg</primary>
    </indexterm>

<!--==========================orignal english content==========================
<synopsis>
<function>xmlagg</function> ( <type>xml</type> ) <returnvalue>xml</returnvalue>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<function>xmlagg</function> ( <type>xml</type> ) <returnvalue>xml</returnvalue>
</synopsis>

<!--==========================orignal english content==========================
    <para>
     The function <function>xmlagg</function> is, unlike the other
     functions described here, an aggregate function.  It concatenates the
     input values to the aggregate function call,
     much like <function>xmlconcat</function> does, except that concatenation
     occurs across rows rather than across expressions in a single row.
     See <xref linkend="functions-aggregate"/> for additional information
     about aggregate functions.
    </para>
____________________________________________________________________________-->
    <para>
     和这里描述的其他函数不同，函数<function>xmlagg</function>是一个聚集函数。它将聚集函数调用的输入值串接起来，非常像<function>xmlconcat</function>所做的事情，除了串接是跨行发生的而不是在单一行的多个表达式上发生。聚集表达式的更多信息请见<xref linkend="functions-aggregate"/>。
    </para>

<!--==========================orignal english content==========================
    <para>
     Example:
<screen><![CDATA[
CREATE TABLE test (y int, x xml);
INSERT INTO test VALUES (1, '<foo>abc</foo>');
INSERT INTO test VALUES (2, '<bar/>');
SELECT xmlagg(x) FROM test;
        xmlagg
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 <foo>abc</foo><bar/>
]]></screen>
    </para>
____________________________________________________________________________-->
    <para>
     例子：
<screen><![CDATA[
CREATE TABLE test (y int, x xml);
INSERT INTO test VALUES (1, '<foo>abc</foo>');
INSERT INTO test VALUES (2, '<bar/>');
SELECT xmlagg(x) FROM test;
        xmlagg
----------------------
 <foo>abc</foo><bar/>
]]></screen>
    </para>

<!--==========================orignal english content==========================
    <para>
     To determine the order of the concatenation, an <literal>ORDER BY</literal>
     clause may be added to the aggregate call as described in
     <xref linkend="syntax-aggregates"/>. For example:

<screen><![CDATA[
SELECT xmlagg(x ORDER BY y DESC) FROM test;
        xmlagg
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 <bar/><foo>abc</foo>
]]></screen>
    </para>
____________________________________________________________________________-->
    <para>
     为了决定串接的顺序，可以为聚集调用增加一个<literal>ORDER BY</literal>子句，如<xref linkend="syntax-aggregates"/>中所述。例如：

<screen><![CDATA[
SELECT xmlagg(x ORDER BY y DESC) FROM test;
        xmlagg
----------------------
 <bar/><foo>abc</foo>
]]></screen>
    </para>

<!--==========================orignal english content==========================
    <para>
     The following non-standard approach used to be recommended
     in previous versions, and may still be useful in specific
     cases:

<screen><![CDATA[
SELECT xmlagg(x) FROM (SELECT * FROM test ORDER BY y DESC) AS tab;
        xmlagg
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 <bar/><foo>abc</foo>
]]></screen>
    </para>
____________________________________________________________________________-->
    <para>
     我们推荐在以前的版本中使用下列非标准方法，并且它们在特定情况下仍然有用：

<screen><![CDATA[
SELECT xmlagg(x) FROM (SELECT * FROM test ORDER BY y DESC) AS tab;
        xmlagg
----------------------
 <bar/><foo>abc</foo>
]]></screen>
    </para>
   </sect3>
   </sect2>

   <sect2 id="functions-xml-predicates">
<!--==========================orignal english content==========================
    <title>XML Predicates</title>
____________________________________________________________________________-->
    <title>XML 谓词</title>

<!--==========================orignal english content==========================
    <para>
     The expressions described in this section check properties
     of <type>xml</type> values.
    </para>
____________________________________________________________________________-->
    <para>
     这一节描述的表达式检查<type>xml</type>值的属性。
    </para>

   <sect3>
<!--==========================orignal english content==========================
    <title><literal>IS DOCUMENT</literal></title>
____________________________________________________________________________-->
    <title><literal>IS DOCUMENT</literal></title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>IS DOCUMENT</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>IS DOCUMENT</primary>
    </indexterm>

<!--==========================orignal english content==========================
<synopsis>
<type>xml</type> <literal>IS DOCUMENT</literal> <returnvalue>boolean</returnvalue>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<type>xml</type> <literal>IS DOCUMENT</literal> <returnvalue>boolean</returnvalue>
</synopsis>

<!--==========================orignal english content==========================
    <para>
     The expression <literal>IS DOCUMENT</literal> returns true if the
     argument XML value is a proper XML document, false if it is not
     (that is, it is a content fragment), or null if the argument is
     null.  See <xref linkend="datatype-xml"/> about the difference
     between documents and content fragments.
    </para>
____________________________________________________________________________-->
    <para>
     如果参数 XML 值是一个正确的 XML 文档，则<literal>IS DOCUMENT</literal>返回真，如果不是则返回假（即它是一个内容片断），或者是参数为空时返回空。文档和内容片断之间的区别请见<xref linkend="datatype-xml"/>。
    </para>
   </sect3>

   <sect3>
<!--==========================orignal english content==========================
    <title><literal>IS NOT DOCUMENT</literal></title>
____________________________________________________________________________-->
    <title><literal>IS NOT DOCUMENT</literal></title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>IS NOT DOCUMENT</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>IS NOT DOCUMENT</primary>
    </indexterm>

<!--==========================orignal english content==========================
<synopsis>
<type>xml</type> <literal>IS NOT DOCUMENT</literal> <returnvalue>boolean</returnvalue>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<type>xml</type> <literal>IS NOT DOCUMENT</literal> <returnvalue>boolean</returnvalue>
</synopsis>

<!--==========================orignal english content==========================
    <para>
     The expression <literal>IS NOT DOCUMENT</literal> returns false if the
     argument XML value is a proper XML document, true if it is not (that is,
     it is a content fragment), or null if the argument is null.
    </para>
____________________________________________________________________________-->
    <para>
     如果参数中的XML值是一个正确的XML文档，那么表达式<literal>IS NOT DOCUMENT</literal>返回假，否则返回真（也就是说它是一个内容片段），如果参数为空则返回空。
    </para>
   </sect3>

   <sect3 id="xml-exists">
<!--==========================orignal english content==========================
    <title><literal>XMLEXISTS</literal></title>
____________________________________________________________________________-->
    <title><literal>XMLEXISTS</literal></title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>XMLEXISTS</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>XMLEXISTS</primary>
    </indexterm>

<!--==========================orignal english content==========================
<synopsis>
<function>XMLEXISTS</function> ( <type>text</type> <literal>PASSING</literal> <optional><literal>BY</literal> {<literal>REF</literal>|<literal>VALUE</literal>}</optional> <type>xml</type> <optional><literal>BY</literal> {<literal>REF</literal>|<literal>VALUE</literal>}</optional> ) <returnvalue>boolean</returnvalue>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<function>XMLEXISTS</function> ( <type>text</type> <literal>PASSING</literal> <optional><literal>BY</literal> {<literal>REF</literal>|<literal>VALUE</literal>}</optional> <type>xml</type> <optional><literal>BY</literal> {<literal>REF</literal>|<literal>VALUE</literal>}</optional> ) <returnvalue>boolean</returnvalue>
</synopsis>

<!--==========================orignal english content==========================
    <para>
     The function <function>xmlexists</function> evaluates an XPath 1.0
     expression (the first argument), with the passed XML value as its context
     item.  The function returns false if the result of that evaluation
     yields an empty node-set, true if it yields any other value.  The
     function returns null if any argument is null.  A nonnull value
     passed as the context item must be an XML document, not a content
     fragment or any non-XML value.
    </para>
____________________________________________________________________________-->
    <para>
     函数<function>xmlexists</function>评价一个XPath 1.0表达式(第一个参数)，以传递的XML值作为其上下文项。 如果评价的结果产生一个空节点集，该函数返回false，如果产生任何其他值，则返回true。 如果任何参数为空，则函数返回null。 作为上下文项传递的非空值必须是一个XML文档，而不是内容片段或任何非XML值。
    </para>

<!--==========================orignal english content==========================
    <para>
     Example:
     <screen><![CDATA[
SELECT xmlexists('//town[text() = ''Toronto'']' PASSING BY VALUE '<towns><town>Toronto</town><town>Ottawa</town></towns>');

 xmlexists
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 t
(1 row)
]]></screen>
    </para>
____________________________________________________________________________-->
    <para>
     例子：
     <screen><![CDATA[
SELECT xmlexists('//town[text() = ''Toronto'']' PASSING BY VALUE '<towns><town>Toronto</town><town>Ottawa</town></towns>');

 xmlexists
------------
 t
(1 row)
]]></screen>
    </para>

<!--==========================orignal english content==========================
    <para>
     The <literal>BY REF</literal> and <literal>BY VALUE</literal> clauses
     are accepted in <productname>PostgreSQL</productname>, but are ignored,
     as discussed in <xref linkend="functions-xml-limits-postgresql"/>.
    </para>
____________________________________________________________________________-->
    <para>
     <literal>BY REF</literal>和<literal>BY VALUE</literal>子句在<productname>PostgreSQL</productname>中被接受，但在<xref linkend="functions-xml-limits-postgresql"/>中被忽略。
    </para>

<!--==========================orignal english content==========================
    <para>
     In the SQL standard, the <function>xmlexists</function> function
     evaluates an expression in the XML Query language,
     but <productname>PostgreSQL</productname> allows only an XPath 1.0
     expression, as discussed in
     <xref linkend="functions-xml-limits-xpath1"/>.
    </para>
____________________________________________________________________________-->
    <para>
     在SQL标准中，<function>xmlexists</function>函数评估XML查询语言中的表达式，但<productname>PostgreSQL</productname>只允许使用XPath 1.0表达式，在<xref linkend="functions-xml-limits-xpath1"/>中讨论过。
    </para>
   </sect3>

   <sect3 id="xml-is-well-formed">
<!--==========================orignal english content==========================
    <title><literal>xml_is_well_formed</literal></title>
____________________________________________________________________________-->
    <title><literal>xml_is_well_formed</literal></title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>xml_is_well_formed</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>xml_is_well_formed</primary>
    </indexterm>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>xml_is_well_formed_document</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>xml_is_well_formed_document</primary>
    </indexterm>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>xml_is_well_formed_content</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>xml_is_well_formed_content</primary>
    </indexterm>

<!--==========================orignal english content==========================
<synopsis>
<function>xml_is_well_formed</function> ( <type>text</type> ) <returnvalue>boolean</returnvalue>
<function>xml_is_well_formed_document</function> ( <type>text</type> ) <returnvalue>boolean</returnvalue>
<function>xml_is_well_formed_content</function> ( <type>text</type> ) <returnvalue>boolean</returnvalue>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<function>xml_is_well_formed</function> ( <type>text</type> ) <returnvalue>boolean</returnvalue>
<function>xml_is_well_formed_document</function> ( <type>text</type> ) <returnvalue>boolean</returnvalue>
<function>xml_is_well_formed_content</function> ( <type>text</type> ) <returnvalue>boolean</returnvalue>
</synopsis>

<!--==========================orignal english content==========================
    <para>
     These functions check whether a <type>text</type> string represents
     well-formed XML, returning a Boolean result.
     <function>xml_is_well_formed_document</function> checks for a well-formed
     document, while <function>xml_is_well_formed_content</function> checks
     for well-formed content.  <function>xml_is_well_formed</function> does
     the former if the <xref linkend="guc-xmloption"/> configuration
     parameter is set to <literal>DOCUMENT</literal>, or the latter if it is set to
     <literal>CONTENT</literal>.  This means that
     <function>xml_is_well_formed</function> is useful for seeing whether
     a simple cast to type <type>xml</type> will succeed, whereas the other two
     functions are useful for seeing whether the corresponding variants of
     <function>XMLPARSE</function> will succeed.
    </para>
____________________________________________________________________________-->
    <para>
     这些函数检查一个<type>text</type>串是不是一个良构的 XML，返回一个布尔结果。<function>xml_is_well_formed_document</function>检查一个良构的文档，而<function>xml_is_well_formed_content</function>检查良构的内容。如果<xref linkend="guc-xmloption"/>配置参数被设置为<literal>DOCUMENT</literal>，<function>xml_is_well_formed</function>会做第一个函数的工作；如果配置参数被设置为<literal>CONTENT</literal>，<function>xml_is_well_formed</function>会做第二个函数的工作。这意味着<function>xml_is_well_formed</function>对于检查一个到类型<type>xml</type>的简单造型是否会成功非常有用，而其他两个函数对于检查<function>XMLPARSE</function>的对应变体是否会成功有用。
    </para>

<!--==========================orignal english content==========================
    <para>
     Examples:

<screen><![CDATA[
SET xmloption TO DOCUMENT;
SELECT xml_is_well_formed('<>');
 xml_is_well_formed 
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 f
(1 row)

SELECT xml_is_well_formed('<abc/>');
 xml_is_well_formed 
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 t
(1 row)

SET xmloption TO CONTENT;
SELECT xml_is_well_formed('abc');
 xml_is_well_formed 
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 t
(1 row)

SELECT xml_is_well_formed_document('<pg:foo xmlns:pg="http://postgresql.org/stuff">bar</pg:foo>');
 xml_is_well_formed_document 
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 t
(1 row)

SELECT xml_is_well_formed_document('<pg:foo xmlns:pg="http://postgresql.org/stuff">bar</my:foo>');
 xml_is_well_formed_document 
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 f
(1 row)
]]></screen>

     The last example shows that the checks include whether
     namespaces are correctly matched.
    </para>
____________________________________________________________________________-->
    <para>
     例子：

<screen><![CDATA[
SET xmloption TO DOCUMENT;
SELECT xml_is_well_formed('<>');
 xml_is_well_formed 
--------------------
 f
(1 row)

SELECT xml_is_well_formed('<abc/>');
 xml_is_well_formed 
--------------------
 t
(1 row)

SET xmloption TO CONTENT;
SELECT xml_is_well_formed('abc');
 xml_is_well_formed 
--------------------
 t
(1 row)

SELECT xml_is_well_formed_document('<pg:foo xmlns:pg="http://postgresql.org/stuff">bar</pg:foo>');
 xml_is_well_formed_document 
-----------------------------
 t
(1 row)

SELECT xml_is_well_formed_document('<pg:foo xmlns:pg="http://postgresql.org/stuff">bar</my:foo>');
 xml_is_well_formed_document 
-----------------------------
 f
(1 row)
]]></screen>

     最后一个例子显示了这些检查也包括名字空间是否正确地匹配。
    </para>
   </sect3>
  </sect2>

  <sect2 id="functions-xml-processing">
<!--==========================orignal english content==========================
   <title>Processing XML</title>
____________________________________________________________________________-->
   <title>处理 XML</title>

<!--==========================orignal english content==========================
   <para>
    To process values of data type <type>xml</type>, PostgreSQL offers
    the functions <function>xpath</function> and
    <function>xpath_exists</function>, which evaluate XPath 1.0
    expressions, and the <function>XMLTABLE</function>
    table function.
   </para>
____________________________________________________________________________-->
   <para>
    要处理数据类型<type>xml</type>的值， PostgreSQL 提供了函数<function>xpath</function>和<function>xpath_exists</function>，它们计算 XPath 1.0 表达式以及<function>XMLTABLE</function>表函数。
   </para>

   <sect3 id="functions-xml-processing-xpath">
<!--==========================orignal english content==========================
    <title><literal>xpath</literal></title>
____________________________________________________________________________-->
    <title><literal>xpath</literal></title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>XPath</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>XPath</primary>
    </indexterm>

<!--==========================orignal english content==========================
<synopsis>
<function>xpath</function> ( <parameter>xpath</parameter> <type>text</type>, <parameter>xml</parameter> <type>xml</type> <optional>, <parameter>nsarray</parameter> <type>text[]</type> </optional> ) <returnvalue>xml[]</returnvalue>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<function>xpath</function> ( <parameter>xpath</parameter> <type>text</type>, <parameter>xml</parameter> <type>xml</type> <optional>, <parameter>nsarray</parameter> <type>text[]</type> </optional> ) <returnvalue>xml[]</returnvalue>
</synopsis>

<!--==========================orignal english content==========================
    <para>
     The function <function>xpath</function> evaluates the XPath 1.0
     expression <parameter>xpath</parameter> (given as text)
     against the XML value
     <parameter>xml</parameter>.  It returns an array of XML values
     corresponding to the node-set produced by the XPath expression.
     If the XPath expression returns a scalar value rather than a node-set,
     a single-element array is returned.
    </para>
____________________________________________________________________________-->
    <para>
     函数<function>xpath</function>根据 XML 值<parameter>xml</parameter>计算 XPath 1.0 表达式<parameter>xpath</parameter> (以文本形式给出)。
     它返回一个 XML 值的数组，该数组对应于该 XPath 表达式产生的结点集合。
     如果该 XPath 表达式返回一个标量值而不是一个结点集合，将会返回一个单一元素的数组。
    </para>

<!--==========================orignal english content==========================
   <para>
     The second argument must be a well formed XML document. In particular,
     it must have a single root node element.
    </para>
____________________________________________________________________________-->
   <para>
     第二个参数必须是一个良构的 XML 文档。特殊地，它必须有一个单一根结点元素。
   </para>

<!--==========================orignal english content==========================
    <para>
     The optional third argument of the function is an array of namespace
     mappings.  This array should be a two-dimensional <type>text</type> array with
     the length of the second axis being equal to 2 (i.e., it should be an
     array of arrays, each of which consists of exactly 2 elements).
     The first element of each array entry is the namespace name (alias), the
     second the namespace URI. It is not required that aliases provided in
     this array be the same as those being used in the XML document itself (in
     other words, both in the XML document and in the <function>xpath</function>
     function context, aliases are <emphasis>local</emphasis>).
    </para>
____________________________________________________________________________-->
    <para>
     该函数可选的第三个参数是一个名字空间映射的数组。这个数组应该是一个二维<type>text</type>数组，其第二轴长度等于2（即它应该是一个数组的数组，其中每一个都由刚好 2 个元素组成）。每个数组项的第一个元素是名字空间的名称（别名），第二个元素是名字空间的 URI。并不要求在这个数组中提供的别名和在 XML 文档本身中使用的那些名字空间相同（换句话说，在 XML 文档中和在<function>xpath</function>函数环境中，别名都是<emphasis>本地的</emphasis>）。
    </para>

<!--==========================orignal english content==========================
    <para>
     Example:
<screen><![CDATA[
SELECT xpath('/my:a/text()', '<my:a xmlns:my="http://example.com">test</my:a>',
             ARRAY[ARRAY['my', 'http://example.com']]);

 xpath  
-&minus;-&minus;-&minus;-&minus;
 {test}
(1 row)
]]></screen>
    </para>
____________________________________________________________________________-->
    <para>
     例子：
<screen><![CDATA[
SELECT xpath('/my:a/text()', '<my:a xmlns:my="http://example.com">test</my:a>',
             ARRAY[ARRAY['my', 'http://example.com']]);

 xpath  
--------
 {test}
(1 row)
]]></screen>
    </para>

<!--==========================orignal english content==========================
    <para>
     To deal with default (anonymous) namespaces, do something like this:
<screen><![CDATA[
SELECT xpath('//mydefns:b/text()', '<a xmlns="http://example.com"><b>test</b></a>',
             ARRAY[ARRAY['mydefns', 'http://example.com']]);

 xpath
-&minus;-&minus;-&minus;-&minus;
 {test}
(1 row)
]]></screen>
    </para>
____________________________________________________________________________-->
    <para>
     要处理默认（匿名）命名空间，做这样的事情：
<screen><![CDATA[
SELECT xpath('//mydefns:b/text()', '<a xmlns="http://example.com"><b>test</b></a>',
             ARRAY[ARRAY['mydefns', 'http://example.com']]);

 xpath
--------
 {test}
(1 row)
]]></screen>
    </para>
   </sect3>

   <sect3 id="functions-xml-processing-xpath-exists">
<!--==========================orignal english content==========================
    <title><literal>xpath_exists</literal></title>
____________________________________________________________________________-->
    <title><literal>xpath_exists</literal></title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>xpath_exists</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>xpath_exists</primary>
    </indexterm>

<!--==========================orignal english content==========================
<synopsis>
<function>xpath_exists</function> ( <parameter>xpath</parameter> <type>text</type>, <parameter>xml</parameter> <type>xml</type> <optional>, <parameter>nsarray</parameter> <type>text[]</type> </optional> ) <returnvalue>boolean</returnvalue>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<function>xpath_exists</function> ( <parameter>xpath</parameter> <type>text</type>, <parameter>xml</parameter> <type>xml</type> <optional>, <parameter>nsarray</parameter> <type>text[]</type> </optional> ) <returnvalue>boolean</returnvalue>
</synopsis>

<!--==========================orignal english content==========================
    <para>
     The function <function>xpath_exists</function> is a specialized form
     of the <function>xpath</function> function.  Instead of returning the
     individual XML values that satisfy the XPath 1.0 expression, this function
     returns a Boolean indicating whether the query was satisfied or not
     (specifically, whether it produced any value other than an empty node-set).
     This function is equivalent to the <literal>XMLEXISTS</literal> predicate,
     except that it also offers support for a namespace mapping argument.
    </para>
____________________________________________________________________________-->
    <para>
     函数<function>xpath_exists</function>是<function>xpath</function>函数的一种特殊形式。这个函数不是返回满足 XPath 1.0 表达式的单一 XML 值，它返回一个布尔值表示查询是否被满足(具体来说，它是否产生了空节点集以外的任何值)。这个函数等价于标准的<literal>XMLEXISTS</literal>谓词，不过它还提供了对一个名字空间映射参数的支持。
    </para>

<!--==========================orignal english content==========================
    <para>
     Example:
<screen><![CDATA[
SELECT xpath_exists('/my:a/text()', '<my:a xmlns:my="http://example.com">test</my:a>',
                     ARRAY[ARRAY['my', 'http://example.com']]);

 xpath_exists  
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 t
(1 row)
]]></screen>
    </para>
____________________________________________________________________________-->
    <para>
     例子：
<screen><![CDATA[
SELECT xpath_exists('/my:a/text()', '<my:a xmlns:my="http://example.com">test</my:a>',
                     ARRAY[ARRAY['my', 'http://example.com']]);

 xpath_exists  
--------------
 t
(1 row)
]]></screen>
    </para>
   </sect3>

   <sect3 id="functions-xml-processing-xmltable">
<!--==========================orignal english content==========================
    <title><literal>xmltable</literal></title>
____________________________________________________________________________-->
    <title><literal>xmltable</literal></title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>xmltable</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>xmltable</primary>
    </indexterm>

<!--==========================orignal english content==========================
    <indexterm zone="functions-xml-processing-xmltable">
     <primary>table function</primary>
     <secondary>XMLTABLE</secondary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm zone="functions-xml-processing-xmltable">
     <primary>table function</primary>
     <secondary>XMLTABLE</secondary>
    </indexterm>

<!--==========================orignal english content==========================
<synopsis>
<function>XMLTABLE</function> (
    <optional> <literal>XMLNAMESPACES</literal> ( <replaceable>namespace_uri</replaceable> <literal>AS</literal> <replaceable>namespace_name</replaceable> <optional>, ...</optional> ), </optional>
    <replaceable>row_expression</replaceable> <literal>PASSING</literal> <optional><literal>BY</literal> {<literal>REF</literal>|<literal>VALUE</literal>}</optional> <replaceable>document_expression</replaceable> <optional><literal>BY</literal> {<literal>REF</literal>|<literal>VALUE</literal>}</optional>
    <literal>COLUMNS</literal> <replaceable>name</replaceable> { <replaceable>type</replaceable> <optional><literal>PATH</literal> <replaceable>column_expression</replaceable></optional> <optional><literal>DEFAULT</literal> <replaceable>default_expression</replaceable></optional> <optional><literal>NOT NULL</literal> | <literal>NULL</literal></optional>
                  | <literal>FOR ORDINALITY</literal> }
            <optional>, ...</optional>
) <returnvalue>setof record</returnvalue>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<function>XMLTABLE</function> (
    <optional> <literal>XMLNAMESPACES</literal> ( <replaceable>namespace_uri</replaceable> <literal>AS</literal> <replaceable>namespace_name</replaceable> <optional>, ...</optional> ), </optional>
    <replaceable>row_expression</replaceable> <literal>PASSING</literal> <optional><literal>BY</literal> {<literal>REF</literal>|<literal>VALUE</literal>}</optional> <replaceable>document_expression</replaceable> <optional><literal>BY</literal> {<literal>REF</literal>|<literal>VALUE</literal>}</optional>
    <literal>COLUMNS</literal> <replaceable>name</replaceable> { <replaceable>type</replaceable> <optional><literal>PATH</literal> <replaceable>column_expression</replaceable></optional> <optional><literal>DEFAULT</literal> <replaceable>default_expression</replaceable></optional> <optional><literal>NOT NULL</literal> | <literal>NULL</literal></optional>
                  | <literal>FOR ORDINALITY</literal> }
            <optional>, ...</optional>
) <returnvalue>setof record</returnvalue>
</synopsis>

<!--==========================orignal english content==========================
    <para>
     The <function>xmltable</function> expression produces a table based
     on an XML value, an XPath filter to extract rows, and a
     set of column definitions.
     Although it syntactically resembles a function, it can only appear
     as a table in a query's <literal>FROM</literal> clause.
    </para>
____________________________________________________________________________-->
    <para>
     <function>xmltable</function>表达式基于给定的XML值产生一个表、一个抽取行的XPath过滤器以及一个列定义集合。
     虽然它在语法上类似于函数，但它只能作为一个表出现在查询的<literal>FROM</literal>子句中。
    </para>

<!--==========================orignal english content==========================
    <para>
     The optional <literal>XMLNAMESPACES</literal> clause gives a
     comma-separated list of namespace definitions, where
     each <replaceable>namespace_uri</replaceable> is a <type>text</type>
     expression and each <replaceable>namespace_name</replaceable> is a simple
     identifier.  It specifies the XML namespaces used in the document and
     their aliases. A default namespace specification is not currently
     supported.
    </para>
____________________________________________________________________________-->
    <para>
     可选的<literal>XMLNAMESPACES</literal>子句是一个逗号分隔的名字空间定义列表。
     其中每个<replaceable>namespace_uri</replaceable>是一个<type>text</type>表达式，每个<replaceable>namespace_name</replaceable>是一个简单的标识符。
     它指定文档中使用的XML名字空间极其别名。当前不支持默认的名字空间说明。
    </para>

<!--==========================orignal english content==========================
    <para>
     The required <replaceable>row_expression</replaceable> argument is an
     XPath 1.0 expression (given as <type>text</type>) that is evaluated,
     passing the XML value <replaceable>document_expression</replaceable> as
     its context item, to obtain a set of XML nodes. These nodes are what
     <function>xmltable</function> transforms into output rows. No rows
     will be produced if the <replaceable>document_expression</replaceable>
     is null, nor if the <replaceable>row_expression</replaceable> produces
     an empty node-set or any value other than a node-set.
    </para>
____________________________________________________________________________-->
    <para>
     所需的<replaceable>row_expression</replaceable>参数是一个求值的XPath 1.0表达式(以<type>text</type>形式给出)，通过传递XML值<replaceable>document_expression</replaceable>作为其上下文项，得到一组XML节点。
     这些节点就是<function>xmltable</function>转换为输出行的内容。如果<replaceable>document_expression</replaceable>为空，或者<replaceable>row_expression</replaceable>产生空节点集或节点集以外的任何值，则不会产生行。
    </para>

<!--==========================orignal english content==========================
    <para>
     <replaceable>document_expression</replaceable> provides the context
     item for the <replaceable>row_expression</replaceable>. It must be a
     well-formed XML document; fragments/forests are not accepted.
     The <literal>BY REF</literal> and <literal>BY VALUE</literal> clauses
     are accepted but ignored, as discussed in
     <xref linkend="functions-xml-limits-postgresql"/>.
    </para>
____________________________________________________________________________-->
    <para>
     <replaceable>document_expression</replaceable>提供了上下文。<replaceable>row_expression</replaceable>的项。
     它必须是一个格式良好的XML文档；不接受片段/森林。<literal>BY REF</literal>和<literal>BY VALUE</literal>子句 如上文所讨论的那样，被接受但被忽略了，正如在<xref linkend="functions-xml-limits-postgresql"/>中所讨论的。
    </para>

<!--==========================orignal english content==========================
    <para>
     In the SQL standard, the <function>xmltable</function> function
     evaluates expressions in the XML Query language,
     but <productname>PostgreSQL</productname> allows only XPath 1.0
     expressions, as discussed in
     <xref linkend="functions-xml-limits-xpath1"/>.
    </para>
____________________________________________________________________________-->
    <para>
     在SQL标准中，<function>xmltable</function>函数 评估XML查询语言中的表达式。
     但<productname>PostgreSQL</productname>只允许使用XPath 1.0的 表达式，正如在 <xref linkend="functions-xml-limits-xpath1"/>所讨论的。
    </para>

<!--==========================orignal english content==========================
    <para>
     The required <literal>COLUMNS</literal> clause specifies the
     column(s) that will be produced in the output table.
     See the syntax summary above for the format.
     A name is required for each column, as is a data type
     (unless <literal>FOR ORDINALITY</literal> is specified, in which case
     type <type>integer</type> is implicit).  The path, default and
     nullability clauses are optional.
    </para>
____________________________________________________________________________-->
    <para>
     需要的<literal>COLUMNS</literal>子句指定将在输出表中生成的列。有关格式，请参阅上面的语法摘要。
     每个列都需要一个名称，作为一个数据类型(除非指定了 <literal>FOR ORDINALITY</literal>，在这种情况下类型 <type>integer</type>是隐式的)。
     路径、默认值以及为空性子句是可选的。	 
    </para>

<!--==========================orignal english content==========================
    <para>
     A column marked <literal>FOR ORDINALITY</literal> will be populated
     with row numbers, starting with 1, in the order of nodes retrieved from
     the <replaceable>row_expression</replaceable>'s result node-set.
     At most one column may be marked <literal>FOR ORDINALITY</literal>.
    </para>
____________________________________________________________________________-->
    <para>
     被标记为<literal>FOR ORDINALITY</literal>的列将按照从<replaceable>row_expression</replaceable>的结果节点集中检索到的节点的顺序，从1开始，填充行号。最多只能有一个列被标记为<literal>FOR ORDINALITY</literal>。
    </para>

    <note>
<!--==========================orignal english content==========================
     <para>
      XPath 1.0 does not specify an order for nodes in a node-set, so code
      that relies on a particular order of the results will be
      implementation-dependent.  Details can be found in
      <xref linkend="xml-xpath-1-specifics"/>.
     </para>
____________________________________________________________________________-->
     <para>
      XPath 1.0 并没有为节点集中的节点指定顺序，因此依赖特定结果顺序的代码将取决于实现。 详情请参见 <xref linkend="xml-xpath-1-specifics"/>。
     </para>
    </note>

<!--==========================orignal english content==========================
    <para>
     The <replaceable>column_expression</replaceable> for a column is an
     XPath 1.0 expression that is evaluated for each row, with the current
     node from the <replaceable>row_expression</replaceable> result as its
     context item, to find the value of the column.  If
     no <replaceable>column_expression</replaceable> is given, then the
     column name is used as an implicit path.
    </para>
____________________________________________________________________________-->
    <para>
     列的<replaceable>column_expression</replaceable>是一个XPath 1.0表达式，它对每一行都要进行求值，并以<replaceable>row_expression</replaceable>结果中的当前节点作为其上下文项，以找到列的值。 如果没有给出<replaceable>column_expression</replaceable>，那么列名被用作隐式路径。
    </para>

<!--==========================orignal english content==========================
    <para>
     If a column's XPath expression returns a non-XML value (which is limited
     to string, boolean, or double in XPath 1.0) and the column has a
     PostgreSQL type other than <type>xml</type>, the column will be set
     as if by assigning the value's string representation to the PostgreSQL
     type.  (If the value is a boolean, its string representation is taken
     to be <literal>1</literal> or <literal>0</literal> if the output
     column's type category is numeric, otherwise <literal>true</literal> or
     <literal>false</literal>.)
    </para>
____________________________________________________________________________-->
    <para>
     如果一个列的XPath表达式返回一个非XML值（在XPath 1.0中仅限于string、boolean或double），而该列的PostgreSQL类型不是<type>xml</type>，那么该列将被设置为将值的字符串表示法分配给PostgreSQL类型。 (如果值是布尔值，如果输出列的类型类别是数字，那么它的字符串表示方式将被认为是<literal>1</literal>或<literal>0</literal>，否则<literal>true</literal>或 <literal>false</literal>。)
    </para>

<!--==========================orignal english content==========================
    <para>
     If a column's XPath expression returns a non-empty set of XML nodes
     and the column's PostgreSQL type is <type>xml</type>, the column will
     be assigned the expression result exactly, if it is of document or
     content form.
     <footnote>
      <para>
       A result containing more than one element node at the top level, or
       non-whitespace text outside of an element, is an example of content form.
       An XPath result can be of neither form, for example if it returns an
       attribute node selected from the element that contains it. Such a result
       will be put into content form with each such disallowed node replaced by
       its string value, as defined for the XPath 1.0
       <function>string</function> function.
      </para>
     </footnote>
    </para>
____________________________________________________________________________-->
    <para>
     如果一个列的XPath表达式返回一个非空的XML节点集，并且该列的PostgreSQL类型是<type>xml</type>，那么如果该列是文档或内容形式的，那么该列将被精确地分配表达式结果。
     <footnote>
      <para>
       在顶层包含一个以上的元素节点的结果，或者在元素之外的非空格文本，就是内容形式的一个例子。一个XPath结果可以是这两种形式的，例如，如果它返回的是一个从包含它的元素中选择的属性节点。这样的结果将被放到内容形式中，每个不允许的节点都会被替换为它的字符串值，就像XPath 1.0<function>string</function> 函数定义的那样。
       
      </para>
     </footnote>
    </para>

<!--==========================orignal english content==========================
    <para>
     A non-XML result assigned to an <type>xml</type> output column produces
     content, a single text node with the string value of the result.
     An XML result assigned to a column of any other type may not have more than
     one node, or an error is raised. If there is exactly one node, the column
     will be set as if by assigning the node's string
     value (as defined for the XPath 1.0 <function>string</function> function)
     to the PostgreSQL type.
    </para>
____________________________________________________________________________-->
    <para>
     分配给<type>xml</type>输出列的非XML结果会产生内容，一个带有结果字符串值的单个文本节点。分配给任何其他类型的列的XML结果不能有一个以上的节点，否则会产生错误。如果正好有一个节点，则该列将被设置为将该节点的字符串值（如XPath 1.0 <function>string</function>函数定义的那样）分配给PostgreSQL类型。
    </para>

<!--==========================orignal english content==========================
    <para>
     The string value of an XML element is the concatenation, in document order,
     of all text nodes contained in that element and its descendants. The string
     value of an element with no descendant text nodes is an
     empty string (not <literal>NULL</literal>).
     Any <literal>xsi:nil</literal> attributes are ignored.
     Note that the whitespace-only <literal>text()</literal> node between two non-text
     elements is preserved, and that leading whitespace on a <literal>text()</literal>
     node is not flattened.
     The XPath 1.0 <function>string</function> function may be consulted for the
     rules defining the string value of other XML node types and non-XML values.
    </para>
____________________________________________________________________________-->
    <para>
     一个XML元素的字符串值是字符串值的协整，按文档的顺序。该元素中包含的所有文本节点及其子节点。字符串 元素的值是一个没有下级文本节点的元素的值是一个 空字符串（不是<literal>NULL</literal>）。任何<literal>xsi:nil</literal>属性都会被忽略。请注意，两个非文本之间的<literal>text()</literal>节点只用空格，而两个非文本 元素，并且保留了<literal>text()</literal>上的前导白格。节点不被扁平化。XPath 1.0中的<function>string</function>函数可以参考XPath 1.0中的 定义其他XML节点类型和非XML值的字符串值的规则。
    </para>

<!--==========================orignal english content==========================
    <para>
     The conversion rules presented here are not exactly those of the SQL
     standard, as discussed in <xref linkend="functions-xml-limits-casts"/>.
    </para>
____________________________________________________________________________-->
    <para>
     这里介绍的转换规则并不完全是SQL标准中的转换规则，如<xref linkend="functions-xml-limits-casts"/>中讨论的那样。
    </para>

<!--==========================orignal english content==========================
    <para>
     If the path expression returns an empty node-set
     (typically, when it does not match)
     for a given row, the column will be set to <literal>NULL</literal>, unless
     a <replaceable>default_expression</replaceable> is specified; then the
     value resulting from evaluating that expression is used.
    </para>
____________________________________________________________________________-->
    <para>
     如果路径表达式为给定行返回一个空节点集（通常情况下，当它不匹配时），该列将被设置为<literal>NULL</literal>，除非指定了<replaceable>default_expression</replaceable>；然后使用评价该表达式产生的值。
    </para>

<!--==========================orignal english content==========================
    <para>
     A <replaceable>default_expression</replaceable>, rather than being
     evaluated immediately when <function>xmltable</function> is called,
     is evaluated each time a default is needed for the column.
     If the expression qualifies as stable or immutable, the repeat
     evaluation may be skipped.
     This means that you can usefully use volatile functions like
     <function>nextval</function> in
     <replaceable>default_expression</replaceable>.
    </para>
____________________________________________________________________________-->
    <para>
     <replaceable>default_expression</replaceable>，而不是在调用<function>xmltable</function>时立即被评价，而是在每次需要列的默认值时，都会被评价。 如果表达式符合稳定或不可更改的条件，则可以跳过重复评价。 这意味着，你可以在<replaceable>default_expression</replaceable>中使用像<function>nextval</function>这样的不稳定函数。
    </para>

<!--==========================orignal english content==========================
    <para>
     Columns may be marked <literal>NOT NULL</literal>. If the
     <replaceable>column_expression</replaceable> for a <literal>NOT
     NULL</literal> column does not match anything and there is
     no <literal>DEFAULT</literal> or
     the <replaceable>default_expression</replaceable> also evaluates to null,
     an error is reported.
    </para>
____________________________________________________________________________-->
    <para>
     列可能会被标记为<literal>NOT NULL</literal>。如果一个<literal>NOT NULL</literal>列的<replaceable>column_expression</replaceable>不匹配任何东西并且没有<literal>DEFAULT</literal>或者<replaceable>default_expression</replaceable>也计算为空，则会报告一个错误。
    </para>

<!--==========================orignal english content==========================
    <para>
     Examples:
  <screen><![CDATA[
CREATE TABLE xmldata AS SELECT
xml $$
<ROWS>
  <ROW id="1">
    <COUNTRY_ID>AU</COUNTRY_ID>
    <COUNTRY_NAME>Australia</COUNTRY_NAME>
  </ROW>
  <ROW id="5">
    <COUNTRY_ID>JP</COUNTRY_ID>
    <COUNTRY_NAME>Japan</COUNTRY_NAME>
    <PREMIER_NAME>Shinzo Abe</PREMIER_NAME>
    <SIZE unit="sq_mi">145935</SIZE>
  </ROW>
  <ROW id="6">
    <COUNTRY_ID>SG</COUNTRY_ID>
    <COUNTRY_NAME>Singapore</COUNTRY_NAME>
    <SIZE unit="sq_km">697</SIZE>
  </ROW>
</ROWS>
$$ AS data;

SELECT xmltable.*
  FROM xmldata,
       XMLTABLE('//ROWS/ROW'
                PASSING data
                COLUMNS id int PATH '@id',
                        ordinality FOR ORDINALITY,
                        "COUNTRY_NAME" text,
                        country_id text PATH 'COUNTRY_ID',
                        size_sq_km float PATH 'SIZE[@unit = "sq_km"]',
                        size_other text PATH
                             'concat(SIZE[@unit!="sq_km"], " ", SIZE[@unit!="sq_km"]/@unit)',
                        premier_name text PATH 'PREMIER_NAME' DEFAULT 'not specified');

 id | ordinality | COUNTRY_NAME | country_id | size_sq_km |  size_other  | premier_name  
-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
  1 |          1 | Australia    | AU         |            |              | not specified
  5 |          2 | Japan        | JP         |            | 145935 sq_mi | Shinzo Abe
  6 |          3 | Singapore    | SG         |        697 |              | not specified
]]></screen>

     The following example shows concatenation of multiple text() nodes,
     usage of the column name as XPath filter, and the treatment of whitespace,
     XML comments and processing instructions:

  <screen><![CDATA[
CREATE TABLE xmlelements AS SELECT
xml $$
  <root>
   <element>  Hello<!-&minus; xyxxz -&minus;>2a2<?aaaaa?> <!-&minus;x-&minus;>  bbb<x>xxx</x>CC  </element>
  </root>
$$ AS data;

SELECT xmltable.*
  FROM xmlelements, XMLTABLE('/root' PASSING data COLUMNS element text);
         element         
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
   Hello2a2   bbbxxxCC  
]]></screen>
    </para>
____________________________________________________________________________-->
    <para>
     例子：
  <screen><![CDATA[
CREATE TABLE xmldata AS SELECT
xml $$
<ROWS>
  <ROW id="1">
    <COUNTRY_ID>AU</COUNTRY_ID>
    <COUNTRY_NAME>Australia</COUNTRY_NAME>
  </ROW>
  <ROW id="5">
    <COUNTRY_ID>JP</COUNTRY_ID>
    <COUNTRY_NAME>Japan</COUNTRY_NAME>
    <PREMIER_NAME>Shinzo Abe</PREMIER_NAME>
    <SIZE unit="sq_mi">145935</SIZE>
  </ROW>
  <ROW id="6">
    <COUNTRY_ID>SG</COUNTRY_ID>
    <COUNTRY_NAME>Singapore</COUNTRY_NAME>
    <SIZE unit="sq_km">697</SIZE>
  </ROW>
</ROWS>
$$ AS data;

SELECT xmltable.*
  FROM xmldata,
       XMLTABLE('//ROWS/ROW'
                PASSING data
                COLUMNS id int PATH '@id',
                        ordinality FOR ORDINALITY,
                        "COUNTRY_NAME" text,
                        country_id text PATH 'COUNTRY_ID',
                        size_sq_km float PATH 'SIZE[@unit = "sq_km"]',
                        size_other text PATH
                             'concat(SIZE[@unit!="sq_km"], " ", SIZE[@unit!="sq_km"]/@unit)',
                        premier_name text PATH 'PREMIER_NAME' DEFAULT 'not specified');

 id | ordinality | COUNTRY_NAME | country_id | size_sq_km |  size_other  | premier_name  
----+------------+--------------+------------+------------+--------------+---------------
  1 |          1 | Australia    | AU         |            |              | not specified
  5 |          2 | Japan        | JP         |            | 145935 sq_mi | Shinzo Abe
  6 |          3 | Singapore    | SG         |        697 |              | not specified
]]></screen>

     接下来的例子展示了多个text()节点的串接、列名用作XPath过滤器的用法以及对空格、XML注释和处理指令的处理：

  <screen><![CDATA[
CREATE TABLE xmlelements AS SELECT
xml $$
  <root>
   <element>  Hello<!-- xyxxz -->2a2<?aaaaa?> <!--x-->  bbb<x>xxx</x>CC  </element>
  </root>
$$ AS data;

SELECT xmltable.*
  FROM xmlelements, XMLTABLE('/root' PASSING data COLUMNS element text);
         element         
-------------------------
   Hello2a2   bbbxxxCC  
]]></screen>
    </para>

<!--==========================orignal english content==========================
    <para>
     The following example illustrates how
     the <literal>XMLNAMESPACES</literal> clause can be used to specify
     a list of namespaces
     used in the XML document as well as in the XPath expressions:

  <screen><![CDATA[
WITH xmldata(data) AS (VALUES ('
<example xmlns="http://example.com/myns" xmlns:B="http://example.com/b">
 <item foo="1" B:bar="2"/>
 <item foo="3" B:bar="4"/>
 <item foo="4" B:bar="5"/>
</example>'::xml)
)
SELECT xmltable.*
  FROM XMLTABLE(XMLNAMESPACES('http://example.com/myns' AS x,
                              'http://example.com/b' AS "B"),
             '/x:example/x:item'
                PASSING (SELECT data FROM xmldata)
                COLUMNS foo int PATH '@foo',
                  bar int PATH '@B:bar');
 foo | bar
-&minus;-&minus;-+-&minus;-&minus;-
   1 |   2
   3 |   4
   4 |   5
(3 rows)
]]></screen>
    </para>
____________________________________________________________________________-->
    <para>
     下面的例子展示了如何使用<literal>XMLNAMESPACES</literal>子句指定用在XML文档以及XPath表达式中的名字空间列表：

  <screen><![CDATA[
WITH xmldata(data) AS (VALUES ('
<example xmlns="http://example.com/myns" xmlns:B="http://example.com/b">
 <item foo="1" B:bar="2"/>
 <item foo="3" B:bar="4"/>
 <item foo="4" B:bar="5"/>
</example>'::xml)
)
SELECT xmltable.*
  FROM XMLTABLE(XMLNAMESPACES('http://example.com/myns' AS x,
                              'http://example.com/b' AS "B"),
             '/x:example/x:item'
                PASSING (SELECT data FROM xmldata)
                COLUMNS foo int PATH '@foo',
                  bar int PATH '@B:bar');
 foo | bar
-----+-----
   1 |   2
   3 |   4
   4 |   5
(3 rows)
]]></screen>
    </para>
   </sect3>
  </sect2>

  <sect2 id="functions-xml-mapping">
<!--==========================orignal english content==========================
   <title>Mapping Tables to XML</title>
____________________________________________________________________________-->
   <title>将表映射到 XML</title>

<!--==========================orignal english content==========================
   <indexterm zone="functions-xml-mapping">
    <primary>XML export</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="functions-xml-mapping">
    <primary>XML export</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    The following functions map the contents of relational tables to
    XML values.  They can be thought of as XML export functionality:
<synopsis>
<function>table_to_xml</function> ( <parameter>table</parameter> <type>regclass</type>, <parameter>nulls</parameter> <type>boolean</type>,
               <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>query_to_xml</function> ( <parameter>query</parameter> <type>text</type>, <parameter>nulls</parameter> <type>boolean</type>,
               <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>cursor_to_xml</function> ( <parameter>cursor</parameter> <type>refcursor</type>, <parameter>count</parameter> <type>integer</type>, <parameter>nulls</parameter> <type>boolean</type>,
                <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
</synopsis>
   </para>
____________________________________________________________________________-->
   <para>
    下面的函数将会把关系表的内容映射成 XML 值。它们可以被看成是 XML 导出功能：
<synopsis>
<function>table_to_xml</function> ( <parameter>table</parameter> <type>regclass</type>, <parameter>nulls</parameter> <type>boolean</type>,
               <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>query_to_xml</function> ( <parameter>query</parameter> <type>text</type>, <parameter>nulls</parameter> <type>boolean</type>,
               <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>cursor_to_xml</function> ( <parameter>cursor</parameter> <type>refcursor</type>, <parameter>count</parameter> <type>integer</type>, <parameter>nulls</parameter> <type>boolean</type>,
                <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
</synopsis>
   </para>

<!--==========================orignal english content==========================
   <para>
    <function>table_to_xml</function> maps the content of the named
    table, passed as parameter <parameter>table</parameter>.  The
    <type>regclass</type> type accepts strings identifying tables using the
    usual notation, including optional schema qualifications and
    double quotes.  <function>query_to_xml</function> executes the
    query whose text is passed as parameter
    <parameter>query</parameter> and maps the result set.
    <function>cursor_to_xml</function> fetches the indicated number of
    rows from the cursor specified by the parameter
    <parameter>cursor</parameter>.  This variant is recommended if
    large tables have to be mapped, because the result value is built
    up in memory by each function.
   </para>
____________________________________________________________________________-->
   <para>
    <function>table_to_xml</function>映射由参数<parameter>table</parameter>传递的命名表的内容。<type>regclass</type>类型接受使用常见标记标识表的字符串，包括可选的模式限定和双引号。<function>query_to_xml</function>执行由参数<parameter>query</parameter>传递的查询并且映射结果集。<function>cursor_to_xml</function>从<parameter>cursor</parameter>指定的游标中取出指定数量的行。如果需要映射一个大型的表，我们推荐这种变体，因为每一个函数都是在内存中构建结果值的。
   </para>

<!--==========================orignal english content==========================
   <para>
    If <parameter>tableforest</parameter> is false, then the resulting
    XML document looks like this:
<screen><![CDATA[
<tablename>
  <row>
    <columnname1>data</columnname1>
    <columnname2>data</columnname2>
  </row>

  <row>
    ...
  </row>

  ...
</tablename>
]]></screen>

    If <parameter>tableforest</parameter> is true, the result is an
    XML content fragment that looks like this:
<screen><![CDATA[
<tablename>
  <columnname1>data</columnname1>
  <columnname2>data</columnname2>
</tablename>

<tablename>
  ...
</tablename>

...
]]></screen>

    If no table name is available, that is, when mapping a query or a
    cursor, the string <literal>table</literal> is used in the first
    format, <literal>row</literal> in the second format.
   </para>
____________________________________________________________________________-->
   <para>
    如果<parameter>tableforest</parameter>为假，则结果的 XML 文档看起来像这样：
<screen><![CDATA[
<tablename>
  <row>
    <columnname1>data</columnname1>
    <columnname2>data</columnname2>
  </row>

  <row>
    ...
  </row>

  ...
</tablename>
]]></screen>

    如果<parameter>tableforest</parameter>为真，结果是一个看起来像这样的 XML 内容片断：
<screen><![CDATA[
<tablename>
  <columnname1>data</columnname1>
  <columnname2>data</columnname2>
</tablename>

<tablename>
  ...
</tablename>

...
]]></screen>

    如果没有表名可用，在映射一个查询或一个游标时，在第一种格式中使用串<literal>table</literal>，在第二种格式中使用<literal>row</literal>。
   </para>

<!--==========================orignal english content==========================
   <para>
    The choice between these formats is up to the user.  The first
    format is a proper XML document, which will be important in many
    applications.  The second format tends to be more useful in the
    <function>cursor_to_xml</function> function if the result values are to be
    reassembled into one document later on.  The functions for
    producing XML content discussed above, in particular
    <function>xmlelement</function>, can be used to alter the results
    to taste.
   </para>
____________________________________________________________________________-->
   <para>
    这几种格式的选择由用户决定。第一种格式是一个正确的 XML 文档，它在很多应用中都很重要。如果结果值要被重组为一个文档，第二种格式在<function>cursor_to_xml</function>函数中更有用。前文讨论的产生 XML 内容的函数（特别是<function>xmlelement</function>）可以被用来把结果修改成符合用户的要求。
   </para>

<!--==========================orignal english content==========================
   <para>
    The data values are mapped in the same way as described for the
    function <function>xmlelement</function> above.
   </para>
____________________________________________________________________________-->
   <para>
    数据值会被以前文的函数<function>xmlelement</function>中描述的相同方法映射。
   </para>

<!--==========================orignal english content==========================
   <para>
    The parameter <parameter>nulls</parameter> determines whether null
    values should be included in the output.  If true, null values in
    columns are represented as:
<screen><![CDATA[
<columnname xsi:nil="true"/>
]]></screen>
    where <literal>xsi</literal> is the XML namespace prefix for XML
    Schema Instance.  An appropriate namespace declaration will be
    added to the result value.  If false, columns containing null
    values are simply omitted from the output.
   </para>
____________________________________________________________________________-->
   <para>
    参数<parameter>nulls</parameter>决定空值是否会被包含在输出中。如果为真，列中的空值被表示为：
<screen><![CDATA[
<columnname xsi:nil="true"/>
]]></screen>
    其中<literal>xsi</literal>是 XML 模式实例的 XML 名字空间前缀。一个合适的名字空间声明将被加入到结果值中。如果为假，包含空值的列将被从输出中忽略掉。
   </para>

<!--==========================orignal english content==========================
   <para>
    The parameter <parameter>targetns</parameter> specifies the
    desired XML namespace of the result.  If no particular namespace
    is wanted, an empty string should be passed.
   </para>
____________________________________________________________________________-->
   <para>
    参数<parameter>targetns</parameter>指定想要的结果的 XML 名字空间。如果没有想要的特定名字空间，将会传递一个空串。
   </para>

<!--==========================orignal english content==========================
   <para>
    The following functions return XML Schema documents describing the
    mappings performed by the corresponding functions above:
<synopsis>
<function>table_to_xmlschema</function> ( <parameter>table</parameter> <type>regclass</type>, <parameter>nulls</parameter> <type>boolean</type>,
                     <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>query_to_xmlschema</function> ( <parameter>query</parameter> <type>text</type>, <parameter>nulls</parameter> <type>boolean</type>,
                     <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>cursor_to_xmlschema</function> ( <parameter>cursor</parameter> <type>refcursor</type>, <parameter>nulls</parameter> <type>boolean</type>,
                      <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
</synopsis>
    It is essential that the same parameters are passed in order to
    obtain matching XML data mappings and XML Schema documents.
   </para>
____________________________________________________________________________-->
   <para>
    下面的函数返回 XML 模式文档，这些文档描述上述对应函数所执行的映射：
<synopsis>
<function>table_to_xmlschema</function> ( <parameter>table</parameter> <type>regclass</type>, <parameter>nulls</parameter> <type>boolean</type>,
                     <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>query_to_xmlschema</function> ( <parameter>query</parameter> <type>text</type>, <parameter>nulls</parameter> <type>boolean</type>,
                     <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>cursor_to_xmlschema</function> ( <parameter>cursor</parameter> <type>refcursor</type>, <parameter>nulls</parameter> <type>boolean</type>,
                      <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
</synopsis>
    最重要的是相同的参数被传递来获得匹配的 XML 数据映射和 XML 模式文档。
   </para>

<!--==========================orignal english content==========================
   <para>
    The following functions produce XML data mappings and the
    corresponding XML Schema in one document (or forest), linked
    together.  They can be useful where self-contained and
    self-describing results are wanted:
<synopsis>
<function>table_to_xml_and_xmlschema</function> ( <parameter>table</parameter> <type>regclass</type>, <parameter>nulls</parameter> <type>boolean</type>,
                             <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>query_to_xml_and_xmlschema</function> ( <parameter>query</parameter> <type>text</type>, <parameter>nulls</parameter> <type>boolean</type>,
                             <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
</synopsis>
   </para>
____________________________________________________________________________-->
   <para>
    下面的函数产生 XML 数据映射和对应的 XML 模式，并把产生的结果链接在一起放在一个文档（或森林）中。在要求自包含和自描述的结果是它们非常有用：
<synopsis>
<function>table_to_xml_and_xmlschema</function> ( <parameter>table</parameter> <type>regclass</type>, <parameter>nulls</parameter> <type>boolean</type>,
                             <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>query_to_xml_and_xmlschema</function> ( <parameter>query</parameter> <type>text</type>, <parameter>nulls</parameter> <type>boolean</type>,
                             <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
</synopsis>
   </para>

<!--==========================orignal english content==========================
   <para>
    In addition, the following functions are available to produce
    analogous mappings of entire schemas or the entire current
    database:
<synopsis>
<function>schema_to_xml</function> ( <parameter>schema</parameter> <type>name</type>, <parameter>nulls</parameter> <type>boolean</type>,
                <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>schema_to_xmlschema</function> ( <parameter>schema</parameter> <type>name</type>, <parameter>nulls</parameter> <type>boolean</type>,
                      <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>schema_to_xml_and_xmlschema</function> ( <parameter>schema</parameter> <type>name</type>, <parameter>nulls</parameter> <type>boolean</type>,
                              <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>

<function>database_to_xml</function> ( <parameter>nulls</parameter> <type>boolean</type>,
                  <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>database_to_xmlschema</function> ( <parameter>nulls</parameter> <type>boolean</type>,
                        <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>database_to_xml_and_xmlschema</function> ( <parameter>nulls</parameter> <type>boolean</type>,
                                <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
</synopsis>

    These functions ignore tables that are not readable by the current user.
    The database-wide functions additionally ignore schemas that the current
    user does not have <literal>USAGE</literal> (lookup) privilege for.
   </para>
____________________________________________________________________________-->
   <para>
    另外，下面的函数可用于产生相似的整个模式或整个当前数据库的映射：
<synopsis>
<function>schema_to_xml</function> ( <parameter>schema</parameter> <type>name</type>, <parameter>nulls</parameter> <type>boolean</type>,
                <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>schema_to_xmlschema</function> ( <parameter>schema</parameter> <type>name</type>, <parameter>nulls</parameter> <type>boolean</type>,
                      <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>schema_to_xml_and_xmlschema</function> ( <parameter>schema</parameter> <type>name</type>, <parameter>nulls</parameter> <type>boolean</type>,
                              <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>

<function>database_to_xml</function> ( <parameter>nulls</parameter> <type>boolean</type>,
                  <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>database_to_xmlschema</function> ( <parameter>nulls</parameter> <type>boolean</type>,
                        <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
<function>database_to_xml_and_xmlschema</function> ( <parameter>nulls</parameter> <type>boolean</type>,
                                <parameter>tableforest</parameter> <type>boolean</type>, <parameter>targetns</parameter> <type>text</type> ) <returnvalue>xml</returnvalue>
</synopsis>

    这些函数会忽略当前用户不可读的表。数据库范围的函数还会忽略当前用户没有<literal>USAGE</literal> (查找)权限的模式。
   </para>

<!--==========================orignal english content==========================
   <para>
    Note that these potentially produce a lot of data, which needs to
    be built up in memory.  When requesting content mappings of large
    schemas or databases, it might be worthwhile to consider mapping the
    tables separately instead, possibly even through a cursor.
   </para>
____________________________________________________________________________-->
   <para>
    请注意，这可能会产生大量数据，这些数据需要在内存中构建。
    当请求大型模式或数据库的内容映射时，可能值得考虑单独映射表，甚至可能通过游标。
   </para>

<!--==========================orignal english content==========================
   <para>
    The result of a schema content mapping looks like this:

<screen><![CDATA[
<schemaname>

table1-mapping

table2-mapping

...

</schemaname>]]></screen>

    where the format of a table mapping depends on the
    <parameter>tableforest</parameter> parameter as explained above.
   </para>
____________________________________________________________________________-->
   <para>
    一个模式内容映射的结果看起来像这样：

<screen><![CDATA[
<schemaname>

table1-mapping

table2-mapping

...

</schemaname>]]></screen>

    其中一个表映射的格式取决于上文解释的<parameter>tableforest</parameter>参数。
   </para>

<!--==========================orignal english content==========================
   <para>
    The result of a database content mapping looks like this:

<screen><![CDATA[
<dbname>

<schema1name>
  ...
</schema1name>

<schema2name>
  ...
</schema2name>

...

</dbname>]]></screen>

    where the schema mapping is as above.
   </para>
____________________________________________________________________________-->
   <para>
    一个数据库内容映射的结果看起来像这样：

<screen><![CDATA[
<dbname>

<schema1name>
  ...
</schema1name>

<schema2name>
  ...
</schema2name>

...

</dbname>]]></screen>

    其中的模式映射如上所述。
   </para>

<!--==========================orignal english content==========================
   <para>
    As an example of using the output produced by these functions,
    <xref linkend="xslt-xml-html"/> shows an XSLT stylesheet that
    converts the output of
    <function>table_to_xml_and_xmlschema</function> to an HTML
    document containing a tabular rendition of the table data.  In a
    similar manner, the results from these functions can be
    converted into other XML-based formats.
   </para>
____________________________________________________________________________-->
   <para>
    作为一个使用这些函数产生的输出的例子，<xref linkend="xslt-xml-html"/>展示了一个 XSLT 样式表，它将<function>table_to_xml_and_xmlschema</function>的输出转换为一个包含表数据的扁平转印的 HTML 文档。以一种相似的方式，这些函数的结果可以被转换成其他基于 XML 的格式。
   </para>

   <example id="xslt-xml-html">
<!--==========================orignal english content==========================
    <title>XSLT Stylesheet for Converting SQL/XML Output to HTML</title>
____________________________________________________________________________-->
    <title>转换 SQL/XML 输出到 HTML 的 XSLT 样式表</title>
<!--==========================orignal english content==========================
<programlisting><![CDATA[
<?xml version="1.0"?>
<xsl:stylesheet version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xsd="http://www.w3.org/2001/XMLSchema"
    xmlns="http://www.w3.org/1999/xhtml"
>

  <xsl:output method="xml"
      doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
      doctype-public="-//W3C/DTD XHTML 1.0 Strict//EN"
      indent="yes"/>

  <xsl:template match="/*">
    <xsl:variable name="schema" select="//xsd:schema"/>
    <xsl:variable name="tabletypename"
                  select="$schema/xsd:element[@name=name(current())]/@type"/>
    <xsl:variable name="rowtypename"
                  select="$schema/xsd:complexType[@name=$tabletypename]/xsd:sequence/xsd:element[@name='row']/@type"/>

    <html>
      <head>
        <title><xsl:value-of select="name(current())"/></title>
      </head>
      <body>
        <table>
          <tr>
            <xsl:for-each select="$schema/xsd:complexType[@name=$rowtypename]/xsd:sequence/xsd:element/@name">
              <th><xsl:value-of select="."/></th>
            </xsl:for-each>
          </tr>

          <xsl:for-each select="row">
            <tr>
              <xsl:for-each select="*">
                <td><xsl:value-of select="."/></td>
              </xsl:for-each>
            </tr>
          </xsl:for-each>
        </table>
      </body>
    </html>
  </xsl:template>

</xsl:stylesheet>
]]></programlisting>
____________________________________________________________________________-->
<programlisting><![CDATA[
<?xml version="1.0"?>
<xsl:stylesheet version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xsd="http://www.w3.org/2001/XMLSchema"
    xmlns="http://www.w3.org/1999/xhtml"
>

  <xsl:output method="xml"
      doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
      doctype-public="-//W3C/DTD XHTML 1.0 Strict//EN"
      indent="yes"/>

  <xsl:template match="/*">
    <xsl:variable name="schema" select="//xsd:schema"/>
    <xsl:variable name="tabletypename"
                  select="$schema/xsd:element[@name=name(current())]/@type"/>
    <xsl:variable name="rowtypename"
                  select="$schema/xsd:complexType[@name=$tabletypename]/xsd:sequence/xsd:element[@name='row']/@type"/>

    <html>
      <head>
        <title><xsl:value-of select="name(current())"/></title>
      </head>
      <body>
        <table>
          <tr>
            <xsl:for-each select="$schema/xsd:complexType[@name=$rowtypename]/xsd:sequence/xsd:element/@name">
              <th><xsl:value-of select="."/></th>
            </xsl:for-each>
          </tr>

          <xsl:for-each select="row">
            <tr>
              <xsl:for-each select="*">
                <td><xsl:value-of select="."/></td>
              </xsl:for-each>
            </tr>
          </xsl:for-each>
        </table>
      </body>
    </html>
  </xsl:template>

</xsl:stylesheet>
]]></programlisting>
   </example>
  </sect2>
 </sect1>

 <sect1 id="functions-json">
<!--==========================orignal english content==========================
  <title>JSON Functions and Operators</title>
____________________________________________________________________________-->
  <title>JSON 函数和操作符</title>

<!--==========================orignal english content==========================
  <indexterm zone="functions-json">
   <primary>JSON</primary>
   <secondary>functions and operators</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="functions-json">
   <primary>JSON</primary>
   <secondary>函数和操作符</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   This section describes:

   <itemizedlist>
    <listitem>
     <para>
      functions and operators for processing and creating JSON data
     </para>
    </listitem>
    <listitem>
     <para>
      the SQL/JSON path language
     </para>
    </listitem>
   </itemizedlist>
  </para>
____________________________________________________________________________-->
  <para>
   本节描述:

   <itemizedlist>
    <listitem>
     <para>
      用于处理和创建JSON数据的函数和运算器
     </para>
    </listitem>
    <listitem>
     <para>
      SQL/JSON路径语言
     </para>
    </listitem>
   </itemizedlist>
  </para>

<!--==========================orignal english content==========================
  <para>
   To learn more about the SQL/JSON standard, see
   <xref linkend="sqltr-19075-6"/>. For details on JSON types
   supported in <productname>PostgreSQL</productname>,
   see <xref linkend="datatype-json"/>.
  </para>
____________________________________________________________________________-->
  <para>
   要了解有关SQL/JSON标准的更多信息，请参阅<xref linkend="sqltr-19075-6"/>。有关<productname>PostgreSQL</productname>中支持的JSON类型的详细信息，见 <xref linkend="datatype-json"/>。
   .
  </para>

  <sect2 id="functions-json-processing">
<!--==========================orignal english content==========================
   <title>Processing and Creating JSON Data</title>
____________________________________________________________________________-->
   <title>处理和创建JSON数据</title>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="functions-json-op-table"/> shows the operators that
   are available for use with JSON data types (see <xref
   linkend="datatype-json"/>).
   In addition, the usual comparison operators shown in <xref
   linkend="functions-comparison-op-table"/> are available for
   <type>jsonb</type>, though not for <type>json</type>.  The comparison
   operators follow the ordering rules for B-tree operations outlined in
   <xref linkend="json-indexing"/>.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="functions-json-op-table"/>展示了可以用于 JSON 数据类型（见<xref linkend="datatype-json"/>）的操作符。
   此外，<xref linkend="functions-comparison-op-table"/>所示的常用比较操作符也适用于<type>jsonb</type>，但不适用于<type>json</type>。
   比较操作符遵循 <xref linkend="json-indexing"/>中的B树操作概要的排序规则。
  </para>

  <table id="functions-json-op-table">
<!--==========================orignal english content==========================
    <title><type>json</type> and <type>jsonb</type> Operators</title>
____________________________________________________________________________-->
    <title><type>json</type> 和 <type>jsonb</type> 操作符</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Operator
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        操作符
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>-&gt;</literal> <type>integer</type>
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>-&gt;</literal> <type>integer</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Extracts <parameter>n</parameter>'th element of JSON array
        (array elements are indexed from zero, but negative integers count
        from the end).
       </para>
       <para>
        <literal>'[{"a":"foo"},{"b":"bar"},{"c":"baz"}]'::json -&gt; 2</literal>
        <returnvalue>{"c":"baz"}</returnvalue>
       </para>
       <para>
        <literal>'[{"a":"foo"},{"b":"bar"},{"c":"baz"}]'::json -&gt; -3</literal>
        <returnvalue>{"a":"foo"}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>-&gt;</literal> <type>integer</type>
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>-&gt;</literal> <type>integer</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        提取JSON数组的第<parameter>n</parameter>个元素(数组元素从0开始索引，但负整数从末尾开始计数)。
       </para>
       <para>
        <literal>'[{"a":"foo"},{"b":"bar"},{"c":"baz"}]'::json -&gt; 2</literal>
        <returnvalue>{"c":"baz"}</returnvalue>
       </para>
       <para>
        <literal>'[{"a":"foo"},{"b":"bar"},{"c":"baz"}]'::json -&gt; -3</literal>
        <returnvalue>{"a":"foo"}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>-&gt;</literal> <type>text</type>
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>-&gt;</literal> <type>text</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Extracts JSON object field with the given key.
       </para>
       <para>
        <literal>'{"a": {"b":"foo"}}'::json -&gt; 'a'</literal>
        <returnvalue>{"b":"foo"}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>-&gt;</literal> <type>text</type>
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>-&gt;</literal> <type>text</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        用给定的键提取JSON对象字段。
       </para>
       <para>
        <literal>'{"a": {"b":"foo"}}'::json -&gt; 'a'</literal>
        <returnvalue>{"b":"foo"}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>-&gt;&gt;</literal> <type>integer</type>
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>-&gt;&gt;</literal> <type>integer</type>
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Extracts <parameter>n</parameter>'th element of JSON array,
        as <type>text</type>.
       </para>
       <para>
        <literal>'[1,2,3]'::json -&gt;&gt; 2</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>-&gt;&gt;</literal> <type>integer</type>
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>-&gt;&gt;</literal> <type>integer</type>
        <returnvalue>text</returnvalue>
       </para>
       <para>
        提取JSON数组的第<parameter>n</parameter>个元素，作为<type>text</type>。
       </para>
       <para>
        <literal>'[1,2,3]'::json -&gt;&gt; 2</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>-&gt;&gt;</literal> <type>text</type>
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>-&gt;&gt;</literal> <type>text</type>
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Extracts JSON object field with the given key, as <type>text</type>.
       </para>
       <para>
        <literal>'{"a":1,"b":2}'::json -&gt;&gt; 'b'</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>-&gt;&gt;</literal> <type>text</type>
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>-&gt;&gt;</literal> <type>text</type>
        <returnvalue>text</returnvalue>
       </para>
       <para>
        用给定的键提取JSON对象字段，作为<type>text</type>。
       </para>
       <para>
        <literal>'{"a":1,"b":2}'::json -&gt;&gt; 'b'</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>#&gt;</literal> <type>text[]</type>
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>#&gt;</literal> <type>text[]</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Extracts JSON sub-object at the specified path, where path elements
        can be either field keys or array indexes.
       </para>
       <para>
        <literal>'{"a": {"b": ["foo","bar"]}}'::json #&gt; '{a,b,1}'</literal>
        <returnvalue>"bar"</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>#&gt;</literal> <type>text[]</type>
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>#&gt;</literal> <type>text[]</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        提取指定路径下的JSON子对象，路径元素可以是字段键或数组索引。
       </para>
       <para>
        <literal>'{"a": {"b": ["foo","bar"]}}'::json #&gt; '{a,b,1}'</literal>
        <returnvalue>"bar"</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>#&gt;&gt;</literal> <type>text[]</type>
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>#&gt;&gt;</literal> <type>text[]</type>
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Extracts JSON sub-object at the specified path as <type>text</type>.
       </para>
       <para>
        <literal>'{"a": {"b": ["foo","bar"]}}'::json #&gt;&gt; '{a,b,1}'</literal>
        <returnvalue>bar</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>#&gt;&gt;</literal> <type>text[]</type>
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>#&gt;&gt;</literal> <type>text[]</type>
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将指定路径上的JSON子对象提取为<type>text</type>。
       </para>
       <para>
        <literal>'{"a": {"b": ["foo","bar"]}}'::json #&gt;&gt; '{a,b,1}'</literal>
        <returnvalue>bar</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <note>
<!--==========================orignal english content==========================
   <para>
    The field/element/path extraction operators return NULL, rather than
    failing, if the JSON input does not have the right structure to match
    the request; for example if no such key or array element exists.
   </para>
____________________________________________________________________________-->
   <para>
    如果JSON输入没有匹配请求的正确结构，字段/元素/路径提取操作符返回NULL，而不是失败;例如，如果不存在这样的键或数组元素。
   </para>
  </note>

<!--==========================orignal english content==========================
  <para>
   Some further operators exist only for <type>jsonb</type>, as shown
   in <xref linkend="functions-jsonb-op-table"/>.
   <xref linkend="json-indexing"/>
   describes how these operators can be used to effectively search indexed
   <type>jsonb</type> data.
  </para>
____________________________________________________________________________-->
  <para>
   还有一些操作符仅适用于<type>jsonb</type>，如表<xref linkend="functions-jsonb-op-table"/>所示。
   第<xref linkend="json-indexing"/>描述了如何使用这些操作符来有效地搜索索引的<type>jsonb</type>数据。
  </para>

  <table id="functions-jsonb-op-table">
<!--==========================orignal english content==========================
    <title>Additional <type>jsonb</type> Operators</title>
____________________________________________________________________________-->
    <title>附加的 <type>jsonb</type> 操作符</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Operator
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        操作符
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>@&gt;</literal> <type>jsonb</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does the first JSON value contain the second?
        (See <xref linkend="json-containment"/> for details about containment.)
       </para>
       <para>
        <literal>'{"a":1, "b":2}'::jsonb &#64;&gt; '{"b":2}'::jsonb</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>@&gt;</literal> <type>jsonb</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个JSON值是否包含第二个?(请参见<xref linkend="json-containment"/>以了解包含的详细信息。)
       </para>
       <para>
        <literal>'{"a":1, "b":2}'::jsonb &#64;&gt; '{"b":2}'::jsonb</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>&lt;@</literal> <type>jsonb</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the first JSON value contained in the second?
       </para>
       <para>
        <literal>'{"b":2}'::jsonb &lt;@ '{"a":1, "b":2}'::jsonb</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>&lt;@</literal> <type>jsonb</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第二个JSON中是否包含第一个JSON值?
       </para>
       <para>
        <literal>'{"b":2}'::jsonb &lt;@ '{"a":1, "b":2}'::jsonb</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>?</literal> <type>text</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does the text string exist as a top-level key or array element within
        the JSON value?
       </para>
       <para>
        <literal>'{"a":1, "b":2}'::jsonb ? 'b'</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>'["a", "b", "c"]'::jsonb ? 'b'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>?</literal> <type>text</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        文本字符串是否作为JSON值中的顶级键或数组元素存在?
       </para>
       <para>
        <literal>'{"a":1, "b":2}'::jsonb ? 'b'</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>'["a", "b", "c"]'::jsonb ? 'b'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>?|</literal> <type>text[]</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Do any of the strings in the text array exist as top-level keys or
        array elements?
       </para>
       <para>
        <literal>'{"a":1, "b":2, "c":3}'::jsonb ?| array['b', 'd']</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>?|</literal> <type>text[]</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        文本数组中的字符串是否作为顶级键或数组元素存在?
       </para>
       <para>
        <literal>'{"a":1, "b":2, "c":3}'::jsonb ?| array['b', 'd']</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>?&amp;</literal> <type>text[]</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Do all of the strings in the text array exist as top-level keys or
        array elements?
       </para>
       <para>
        <literal>'["a", "b", "c"]'::jsonb ?&amp; array['a', 'b']</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>?&amp;</literal> <type>text[]</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        文本数组中的所有字符串都作为顶级键或数组元素存在吗?
       </para>
       <para>
        <literal>'["a", "b", "c"]'::jsonb ?&amp; array['a', 'b']</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>||</literal> <type>jsonb</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Concatenates two <type>jsonb</type> values.
        Concatenating two objects generates an object with the union of their
        keys, taking the second object's value when there are duplicate keys.
        Does not operate recursively: only the top-level array or object
        structure is merged.
       </para>
       <para>
        <literal>'["a", "b"]'::jsonb || '["a", "d"]'::jsonb</literal>
        <returnvalue>["a", "b", "a", "d"]</returnvalue>
       </para>
       <para>
        <literal>'{"a": "b"}'::jsonb || '{"c": "d"}'::jsonb</literal>
        <returnvalue>{"a": "b", "c": "d"}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>||</literal> <type>jsonb</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        连接两个<type>jsonb</type>值。连接两个数组将生成一个包含每个输入的所有元素的数组。连接两个对象将生成一个包含它们键的并集的对象，当存在重复的键时取第二个对象的值。
        所有其他情况都是通过将非数组输入转换为单个元素数组，然后按照两个数组的方式进行处理。
        不递归操作:只有顶级数组或对象结构被合并。
       </para>
       <para>
        <literal>'["a", "b"]'::jsonb || '["a", "d"]'::jsonb</literal>
        <returnvalue>["a", "b", "a", "d"]</returnvalue>
       </para>
       <para>
        <literal>'{"a": "b"}'::jsonb || '{"c": "d"}'::jsonb</literal>
        <returnvalue>{"a": "b", "c": "d"}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>-</literal> <type>text</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Deletes a key (and its value) from a JSON object, or matching string
        value(s) from a JSON array.
       </para>
       <para>
        <literal>'{"a": "b", "c": "d"}'::jsonb - 'a'</literal>
        <returnvalue>{"c": "d"}</returnvalue>
       </para>
       <para>
        <literal>'["a", "b", "c", "b"]'::jsonb - 'b'</literal>
        <returnvalue>["a", "c"]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>-</literal> <type>text</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        从JSON对象中删除键(以及它的值)，或从JSON数组中删除匹配的字符串值。
       </para>
       <para>
        <literal>'{"a": "b", "c": "d"}'::jsonb - 'a'</literal>
        <returnvalue>{"c": "d"}</returnvalue>
       </para>
       <para>
        <literal>'["a", "b", "c", "b"]'::jsonb - 'b'</literal>
        <returnvalue>["a", "c"]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>-</literal> <type>text[]</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Deletes all matching keys or array elements from the left operand.
       </para>
       <para>
        <literal>'{"a": "b", "c": "d"}'::jsonb - '{a,c}'::text[]</literal>
        <returnvalue>{}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>-</literal> <type>text[]</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        从左操作数中删除所有匹配的键或数组元素。
       </para>
       <para>
        <literal>'{"a": "b", "c": "d"}'::jsonb - '{a,c}'::text[]</literal>
        <returnvalue>{}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>-</literal> <type>integer</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Deletes the array element with specified index (negative
        integers count from the end).  Throws an error if JSON value
        is not an array.
       </para>
       <para>
        <literal>'["a", "b"]'::jsonb - 1 </literal>
        <returnvalue>["a"]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>-</literal> <type>integer</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        删除具有指定索引的数组元素(负整数从末尾计数)。如果JSON值不是数组，则抛出错误。
       </para>
       <para>
        <literal>'["a", "b"]'::jsonb - 1 </literal>
        <returnvalue>["a"]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>#-</literal> <type>text[]</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Deletes the field or array element at the specified path, where path
        elements can be either field keys or array indexes.
       </para>
       <para>
        <literal>'["a", {"b":1}]'::jsonb #- '{1,b}'</literal>
        <returnvalue>["a", {}]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>#-</literal> <type>text[]</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        删除指定路径上的字段或数组元素，路径元素可以是字段键或数组索引。
       </para>
       <para>
        <literal>'["a", {"b":1}]'::jsonb #- '{1,b}'</literal>
        <returnvalue>["a", {}]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>@?</literal> <type>jsonpath</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does JSON path return any item for the specified JSON value?
       </para>
       <para>
        <literal>'{"a":[1,2,3,4,5]}'::jsonb @? '$.a[*] ? (@ > 2)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>@?</literal> <type>jsonpath</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        JSON路径是否为指定的JSON值返回任何项?
       </para>
       <para>
        <literal>'{"a":[1,2,3,4,5]}'::jsonb @? '$.a[*] ? (@ > 2)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>@@</literal> <type>jsonpath</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Returns the result of a JSON path predicate check for the
        specified JSON value.  Only the first item of the result is taken into
        account.  If the result is not Boolean, then <literal>NULL</literal>
        is returned.
       </para>
       <para>
        <literal>'{"a":[1,2,3,4,5]}'::jsonb @@ '$.a[*] > 2'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>@@</literal> <type>jsonpath</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        返回指定JSON值的JSON路径谓词检查的结果。只考虑结果的第一项。如果结果不是布尔值，则返回<literal>NULL</literal>。
       </para>
       <para>
        <literal>'{"a":[1,2,3,4,5]}'::jsonb @@ '$.a[*] > 2'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <note>
<!--==========================orignal english content==========================
   <para>
    The <type>jsonpath</type> operators <literal>@?</literal>
    and <literal>@@</literal> suppress the following errors: missing object
    field or array element, unexpected JSON item type, datetime and numeric
    errors.  The <type>jsonpath</type>-related functions described below can
    also be told to suppress these types of errors.  This behavior might be
    helpful when searching JSON document collections of varying structure.
   </para>
____________________________________________________________________________-->
   <para>
    <type>jsonpath</type>操作符<literal>@?</literal> 和 <literal>@@</literal>抑制以下错误:缺少对象字段或数组元素，意外的JSON项目类型，日期时间和数字错误。
	还可以告诉以下描述的与<type>jsonpath</type>相关的函数来抑制这些类型的错误。在搜索不同结构的JSON文档集合时，此行为可能会有所帮助。
	
	The <type>jsonpath</type> operators <literal>@?</literal>
    and <literal>@@</literal> suppress the following errors: missing object
    field or array element, unexpected JSON item type, datetime and numeric
    errors.  The <type>jsonpath</type>-related functions described below can
    also be told to suppress these types of errors.  This behavior might be
    helpful when searching JSON document collections of varying structure.
   </para>
  </note>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="functions-json-creation-table"/> shows the functions that are
   available for constructing <type>json</type> and <type>jsonb</type> values.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="functions-json-creation-table"/> 显示可用于构造<type>json</type>和<type>jsonb</type>值的函数。
  </para>

  <table id="functions-json-creation-table">
<!--==========================orignal english content==========================
    <title>JSON Creation Functions</title>
____________________________________________________________________________-->
    <title>JSON 创建函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_json</primary>
        </indexterm>
        <function>to_json</function> ( <type>anyelement</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>to_jsonb</primary>
        </indexterm>
        <function>to_jsonb</function> ( <type>anyelement</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Converts any SQL value to <type>json</type> or <type>jsonb</type>.
        Arrays and composites are converted recursively to arrays and
        objects (multidimensional arrays become arrays of arrays in JSON).
        Otherwise, if there is a cast from the SQL data type
        to <type>json</type>, the cast function will be used to perform the
        conversion;<footnote>
         <para>
          For example, the <xref linkend="hstore"/> extension has a cast
          from <type>hstore</type> to <type>json</type>, so that
          <type>hstore</type> values converted via the JSON creation functions
          will be represented as JSON objects, not as primitive string values.
         </para>
        </footnote>
        otherwise, a scalar JSON value is produced.  For any scalar other than
        a number, a Boolean, or a null value, the text representation will be
        used, with escaping as necessary to make it a valid JSON string value.
       </para>
       <para>
        <literal>to_json('Fred said "Hi."'::text)</literal>
        <returnvalue>"Fred said \"Hi.\""</returnvalue>
       </para>
       <para>
        <literal>to_jsonb(row(42, 'Fred said "Hi."'::text))</literal>
        <returnvalue>{"f1": 42, "f2": "Fred said \"Hi.\""}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_json</primary>
        </indexterm>
        <function>to_json</function> ( <type>anyelement</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>to_jsonb</primary>
        </indexterm>
        <function>to_jsonb</function> ( <type>anyelement</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        将任何SQL值转换为<type>json</type>或<type>jsonb</type>。数组和组合递归地转换为数组和对象(多维数组在JSON中变成数组的数组)。
        否则，如果存在从SQL数据类型到<type>json</type>的类型转换，则造型函数将用于执行转换;
        <footnote>
         <para>
          例如，<xref linkend="hstore"/>扩展有一个从<type>hstore</type>到<type>json</type>的转换，这样通过json创建函数转换的<type>hstore</type>值将被表示为json对象，而不是原始字符串值
         </para>
        </footnote>
        否则，将生成一个标量json值。对于除数字、布尔值或空值之外的任何标量，将使用文本表示，并根据需要进行转义，使其成为有效的JSON字符串值。
       </para>
       <para>
        <literal>to_json('Fred said "Hi."'::text)</literal>
        <returnvalue>"Fred said \"Hi.\""</returnvalue>
       </para>
       <para>
        <literal>to_jsonb(row(42, 'Fred said "Hi."'::text))</literal>
        <returnvalue>{"f1": 42, "f2": "Fred said \"Hi.\""}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_to_json</primary>
        </indexterm>
        <function>array_to_json</function> ( <type>anyarray</type> <optional>, <type>boolean</type> </optional> )
        <returnvalue>json</returnvalue>
       </para>
       <para>
        Converts a SQL array to a JSON array.  The behavior is the same
        as <function>to_json</function> except that line feeds will be added
        between top-level array elements if the optional boolean parameter is
        true.
       </para>
       <para>
        <literal>array_to_json('{{1,5},{99,100}}'::int[])</literal>
        <returnvalue>[[1,5],[99,100]]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_to_json</primary>
        </indexterm>
        <function>array_to_json</function> ( <type>anyarray</type> <optional>, <type>boolean</type> </optional> )
        <returnvalue>json</returnvalue>
       </para>
       <para>
        将SQL数组转换为JSON数组。该行为与<function>to_json</function>相同，只是如果可选boolean参数为真，换行符将在顶级数组元素之间添加。
       </para>
       <para>
        <literal>array_to_json('{{1,5},{99,100}}'::int[])</literal>
        <returnvalue>[[1,5],[99,100]]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>row_to_json</primary>
        </indexterm>
        <function>row_to_json</function> ( <type>record</type> <optional>, <type>boolean</type> </optional> )
        <returnvalue>json</returnvalue>
       </para>
       <para>
        Converts a SQL composite value to a JSON object.  The behavior is the
        same as <function>to_json</function> except that line feeds will be
        added between top-level elements if the optional boolean parameter is
        true.
       </para>
       <para>
        <literal>row_to_json(row(1,'foo'))</literal>
        <returnvalue>{"f1":1,"f2":"foo"}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>row_to_json</primary>
        </indexterm>
        <function>row_to_json</function> ( <type>record</type> <optional>, <type>boolean</type> </optional> )
        <returnvalue>json</returnvalue>
       </para>
       <para>
        将SQL组合值转换为JSON对象。该行为与<function>to_json</function>相同，只是如果可选boolean参数为真，换行符将在顶级元素之间添加。
       </para>
       <para>
        <literal>row_to_json(row(1,'foo'))</literal>
        <returnvalue>{"f1":1,"f2":"foo"}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_build_array</primary>
        </indexterm>
        <function>json_build_array</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_build_array</primary>
        </indexterm>
        <function>jsonb_build_array</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Builds a possibly-heterogeneously-typed JSON array out of a variadic
        argument list.  Each argument is converted as
        per <function>to_json</function> or <function>to_jsonb</function>.
       </para>
       <para>
        <literal>json_build_array(1, 2, 'foo', 4, 5)</literal>
        <returnvalue>[1, 2, "foo", 4, 5]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_build_array</primary>
        </indexterm>
        <function>json_build_array</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_build_array</primary>
        </indexterm>
        <function>jsonb_build_array</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        根据可变参数列表构建可能异构类型的JSON数组。每个参数都按照<function>to_json</function>或<function>to_jsonb</function>进行转换。
       </para>
       <para>
        <literal>json_build_array(1, 2, 'foo', 4, 5)</literal>
        <returnvalue>[1, 2, "foo", 4, 5]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_build_object</primary>
        </indexterm>
        <function>json_build_object</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_build_object</primary>
        </indexterm>
        <function>jsonb_build_object</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Builds a JSON object out of a variadic argument list.  By convention,
        the argument list consists of alternating keys and values.  Key
        arguments are coerced to text; value arguments are converted as
        per <function>to_json</function> or <function>to_jsonb</function>.
       </para>
       <para>
        <literal>json_build_object('foo', 1, 2, row(3,'bar'))</literal>
        <returnvalue>{"foo" : 1, "2" : {"f1":3,"f2":"bar"}}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_build_object</primary>
        </indexterm>
        <function>json_build_object</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_build_object</primary>
        </indexterm>
        <function>jsonb_build_object</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        根据可变参数列表构建一个JSON对象。按照惯例，参数列表由交替的键和值组成。
        关键参数强制转换为文本;值参数按照<function>to_json</function>或<function>to_jsonb</function>进行转换。
       </para>
       <para>
        <literal>json_build_object('foo', 1, 2, row(3,'bar'))</literal>
        <returnvalue>{"foo" : 1, "2" : {"f1":3,"f2":"bar"}}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_object</primary>
        </indexterm>
        <function>json_object</function> ( <type>text[]</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_object</primary>
        </indexterm>
        <function>jsonb_object</function> ( <type>text[]</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Builds a JSON object out of a text array.  The array must have either
        exactly one dimension with an even number of members, in which case
        they are taken as alternating key/value pairs, or two dimensions
        such that each inner array has exactly two elements, which
        are taken as a key/value pair.  All values are converted to JSON
        strings.
       </para>
       <para>
        <literal>json_object('{a, 1, b, "def", c, 3.5}')</literal>
        <returnvalue>{"a" : "1", "b" : "def", "c" : "3.5"}</returnvalue>
       </para>
        <para><literal>json_object('{{a, 1}, {b, "def"}, {c, 3.5}}')</literal>
        <returnvalue>{"a" : "1", "b" : "def", "c" : "3.5"}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_object</primary>
        </indexterm>
        <function>json_object</function> ( <type>text[]</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_object</primary>
        </indexterm>
        <function>jsonb_object</function> ( <type>text[]</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        从文本数组构建JSON对象。该数组必须有两个维度，一个维度的成员数为偶数，在这种情况下，它们被视为交替的键/值对;
        另一个维度的成员数为二维，每个内部数组恰好有两个元素，它们被视为键/值对。所有值都转换为JSON字符串。
       </para>
       <para>
        <literal>json_object('{a, 1, b, "def", c, 3.5}')</literal>
        <returnvalue>{"a" : "1", "b" : "def", "c" : "3.5"}</returnvalue>
       </para>
        <para><literal>json_object('{{a, 1}, {b, "def"}, {c, 3.5}}')</literal>
        <returnvalue>{"a" : "1", "b" : "def", "c" : "3.5"}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>json_object</function> ( <parameter>keys</parameter> <type>text[]</type>, <parameter>values</parameter> <type>text[]</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <function>jsonb_object</function> ( <parameter>keys</parameter> <type>text[]</type>, <parameter>values</parameter> <type>text[]</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        This form of <function>json_object</function> takes keys and values
        pairwise from separate text arrays.  Otherwise it is identical to
        the one-argument form.
       </para>
       <para>
        <literal>json_object('{a,b}', '{1,2}')</literal>
        <returnvalue>{"a": "1", "b": "2"}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>json_object</function> ( <parameter>keys</parameter> <type>text[]</type>, <parameter>values</parameter> <type>text[]</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <function>jsonb_object</function> ( <parameter>keys</parameter> <type>text[]</type>, <parameter>values</parameter> <type>text[]</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        这种形式的<function>json_object</function>从单独的文本数组中成对地获取键和值。否则，它与单参数形式相同。
       </para>
       <para>
        <literal>json_object('{a,b}', '{1,2}')</literal>
        <returnvalue>{"a": "1", "b": "2"}</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="functions-json-processing-table"/> shows the functions that
   are available for processing <type>json</type> and <type>jsonb</type> values.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="functions-json-processing-table"/> 显示可用于处理<type>json</type>和<type>jsonb</type>值的函数。
  </para>

  <table id="functions-json-processing-table">
<!--==========================orignal english content==========================
    <title>JSON Processing Functions</title>
____________________________________________________________________________-->
    <title>JSON 处理函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_array_elements</primary>
        </indexterm>
        <function>json_array_elements</function> ( <type>json</type> )
        <returnvalue>setof json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_array_elements</primary>
        </indexterm>
        <function>jsonb_array_elements</function> ( <type>jsonb</type> )
        <returnvalue>setof jsonb</returnvalue>
       </para>
       <para>
        Expands the top-level JSON array into a set of JSON values.
       </para>
       <para>
        <literal>select * from json_array_elements('[1,true, [2,false]]')</literal>
        <returnvalue></returnvalue>
<programlisting>
   value
-&minus;-&minus;-&minus;-&minus;-&minus;-
 1
 true
 [2,false]
</programlisting>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_array_elements</primary>
        </indexterm>
        <function>json_array_elements</function> ( <type>json</type> )
        <returnvalue>setof json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_array_elements</primary>
        </indexterm>
        <function>jsonb_array_elements</function> ( <type>jsonb</type> )
        <returnvalue>setof jsonb</returnvalue>
       </para>
       <para>
        将顶级JSON数组展开为一组JSON值。
       </para>
       <para>
        <literal>select * from json_array_elements('[1,true, [2,false]]')</literal>
        <returnvalue></returnvalue>
<programlisting>
   value
-----------
 1
 true
 [2,false]
</programlisting>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_array_elements_text</primary>
        </indexterm>
        <function>json_array_elements_text</function> ( <type>json</type> )
        <returnvalue>setof text</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_array_elements_text</primary>
        </indexterm>
        <function>jsonb_array_elements_text</function> ( <type>jsonb</type> )
        <returnvalue>setof text</returnvalue>
       </para>
       <para>
        Expands the top-level JSON array into a set of <type>text</type> values.
       </para>
       <para>
        <literal>select * from json_array_elements_text('["foo", "bar"]')</literal>
        <returnvalue></returnvalue>
<programlisting>
   value
-&minus;-&minus;-&minus;-&minus;-&minus;-
 foo
 bar
</programlisting>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_array_elements_text</primary>
        </indexterm>
        <function>json_array_elements_text</function> ( <type>json</type> )
        <returnvalue>setof text</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_array_elements_text</primary>
        </indexterm>
        <function>jsonb_array_elements_text</function> ( <type>jsonb</type> )
        <returnvalue>setof text</returnvalue>
       </para>
       <para>
        将顶级JSON数组展开为一组<type>文本</type>值。
       </para>
       <para>
        <literal>select * from json_array_elements_text('["foo", "bar"]')</literal>
        <returnvalue></returnvalue>
<programlisting>
   value
-----------
 foo
 bar
</programlisting>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_array_length</primary>
        </indexterm>
        <function>json_array_length</function> ( <type>json</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_array_length</primary>
        </indexterm>
        <function>jsonb_array_length</function> ( <type>jsonb</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the number of elements in the top-level JSON array.
       </para>
       <para>
        <literal>json_array_length('[1,2,3,{"f1":1,"f2":[5,6]},4]')</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_array_length</primary>
        </indexterm>
        <function>json_array_length</function> ( <type>json</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_array_length</primary>
        </indexterm>
        <function>jsonb_array_length</function> ( <type>jsonb</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回顶级JSON数组中的元素数量。
       </para>
       <para>
        <literal>json_array_length('[1,2,3,{"f1":1,"f2":[5,6]},4]')</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_each</primary>
        </indexterm>
        <function>json_each</function> ( <type>json</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>key</parameter> <type>text</type>,
        <parameter>value</parameter> <type>json</type> )
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_each</primary>
        </indexterm>
        <function>jsonb_each</function> ( <type>jsonb</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>key</parameter> <type>text</type>,
        <parameter>value</parameter> <type>jsonb</type> )
       </para>
       <para>
        Expands the top-level JSON object into a set of key/value pairs.
       </para>
       <para>
        <literal>select * from json_each('{"a":"foo", "b":"bar"}')</literal>
        <returnvalue></returnvalue>
<programlisting>
 key | value
-&minus;-&minus;-+-&minus;-&minus;-&minus;-
 a   | "foo"
 b   | "bar"
</programlisting>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_each</primary>
        </indexterm>
        <function>json_each</function> ( <type>json</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>key</parameter> <type>text</type>,
        <parameter>value</parameter> <type>json</type> )
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_each</primary>
        </indexterm>
        <function>jsonb_each</function> ( <type>jsonb</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>key</parameter> <type>text</type>,
        <parameter>value</parameter> <type>jsonb</type> )
       </para>
       <para>
        将顶级JSON对象展开为一组键/值对。
       </para>
       <para>
        <literal>select * from json_each('{"a":"foo", "b":"bar"}')</literal>
        <returnvalue></returnvalue>
<programlisting>
 key | value
-----+-------
 a   | "foo"
 b   | "bar"
</programlisting>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_each_text</primary>
        </indexterm>
        <function>json_each_text</function> ( <type>json</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>key</parameter> <type>text</type>,
        <parameter>value</parameter> <type>text</type> )
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_each_text</primary>
        </indexterm>
        <function>jsonb_each_text</function> ( <type>jsonb</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>key</parameter> <type>text</type>,
        <parameter>value</parameter> <type>text</type> )
       </para>
       <para>
        Expands the top-level JSON object into a set of key/value pairs.
        The returned <parameter>value</parameter>s will be of
        type <type>text</type>.
       </para>
       <para>
        <literal>select * from json_each_text('{"a":"foo", "b":"bar"}')</literal>
        <returnvalue></returnvalue>
<programlisting>
 key | value
-&minus;-&minus;-+-&minus;-&minus;-&minus;-
 a   | foo
 b   | bar
</programlisting>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_each_text</primary>
        </indexterm>
        <function>json_each_text</function> ( <type>json</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>key</parameter> <type>text</type>,
        <parameter>value</parameter> <type>text</type> )
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_each_text</primary>
        </indexterm>
        <function>jsonb_each_text</function> ( <type>jsonb</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>key</parameter> <type>text</type>,
        <parameter>value</parameter> <type>text</type> )
       </para>
       <para>
        将顶级JSON对象扩展为一组键/值对。返回的<parameter>值</parameter>的类型为<type>文本</type>。
       </para>
       <para>
        <literal>select * from json_each_text('{"a":"foo", "b":"bar"}')</literal>
        <returnvalue></returnvalue>
<programlisting>
 key | value
-----+-------
 a   | foo
 b   | bar
</programlisting>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_extract_path</primary>
        </indexterm>
        <function>json_extract_path</function> ( <parameter>from_json</parameter> <type>json</type>, <literal>VARIADIC</literal> <parameter>path_elems</parameter> <type>text[]</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_extract_path</primary>
        </indexterm>
        <function>jsonb_extract_path</function> ( <parameter>from_json</parameter> <type>jsonb</type>, <literal>VARIADIC</literal> <parameter>path_elems</parameter> <type>text[]</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Extracts JSON sub-object at the specified path.
        (This is functionally equivalent to the <literal>#&gt;</literal>
        operator, but writing the path out as a variadic list can be more
        convenient in some cases.)
       </para>
       <para>
        <literal>json_extract_path('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}', 'f4', 'f6')</literal>
        <returnvalue>"foo"</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_extract_path</primary>
        </indexterm>
        <function>json_extract_path</function> ( <parameter>from_json</parameter> <type>json</type>, <literal>VARIADIC</literal> <parameter>path_elems</parameter> <type>text[]</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_extract_path</primary>
        </indexterm>
        <function>jsonb_extract_path</function> ( <parameter>from_json</parameter> <type>jsonb</type>, <literal>VARIADIC</literal> <parameter>path_elems</parameter> <type>text[]</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        在指定路径下提取JSON子对象。(这在功能上相当于<literal>#&gt;</literal>操作符，但在某些情况下，将路径写成可变参数列表会更方便。)
       </para>
       <para>
        <literal>json_extract_path('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}', 'f4', 'f6')</literal>
        <returnvalue>"foo"</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_extract_path_text</primary>
        </indexterm>
        <function>json_extract_path_text</function> ( <parameter>from_json</parameter> <type>json</type>, <literal>VARIADIC</literal> <parameter>path_elems</parameter> <type>text[]</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_extract_path_text</primary>
        </indexterm>
        <function>jsonb_extract_path_text</function> ( <parameter>from_json</parameter> <type>jsonb</type>, <literal>VARIADIC</literal> <parameter>path_elems</parameter> <type>text[]</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Extracts JSON sub-object at the specified path as <type>text</type>.
        (This is functionally equivalent to the <literal>#&gt;&gt;</literal>
        operator.)
       </para>
       <para>
        <literal>json_extract_path_text('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}', 'f4', 'f6')</literal>
        <returnvalue>foo</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_extract_path_text</primary>
        </indexterm>
        <function>json_extract_path_text</function> ( <parameter>from_json</parameter> <type>json</type>, <literal>VARIADIC</literal> <parameter>path_elems</parameter> <type>text[]</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_extract_path_text</primary>
        </indexterm>
        <function>jsonb_extract_path_text</function> ( <parameter>from_json</parameter> <type>jsonb</type>, <literal>VARIADIC</literal> <parameter>path_elems</parameter> <type>text[]</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将指定路径上的JSON子对象提取为<type>文本</type>。(这在功能上等同于<literal>#&gt;&gt;</literal>操作符。)
       </para>
       <para>
        <literal>json_extract_path_text('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}', 'f4', 'f6')</literal>
        <returnvalue>foo</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_object_keys</primary>
        </indexterm>
        <function>json_object_keys</function> ( <type>json</type> )
        <returnvalue>setof text</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_object_keys</primary>
        </indexterm>
        <function>jsonb_object_keys</function> ( <type>jsonb</type> )
        <returnvalue>setof text</returnvalue>
       </para>
       <para>
        Returns the set of keys in the top-level JSON object.
       </para>
       <para>
        <literal>select * from json_object_keys('{"f1":"abc","f2":{"f3":"a", "f4":"b"}}')</literal>
        <returnvalue></returnvalue>
<programlisting>
 json_object_keys
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 f1
 f2
</programlisting>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_object_keys</primary>
        </indexterm>
        <function>json_object_keys</function> ( <type>json</type> )
        <returnvalue>setof text</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_object_keys</primary>
        </indexterm>
        <function>jsonb_object_keys</function> ( <type>jsonb</type> )
        <returnvalue>setof text</returnvalue>
       </para>
       <para>
        返回顶级JSON对象中的键集合。
       </para>
       <para>
        <literal>select * from json_object_keys('{"f1":"abc","f2":{"f3":"a", "f4":"b"}}')</literal>
        <returnvalue></returnvalue>
<programlisting>
 json_object_keys
------------------
 f1
 f2
</programlisting>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_populate_record</primary>
        </indexterm>
        <function>json_populate_record</function> ( <parameter>base</parameter> <type>anyelement</type>, <parameter>from_json</parameter> <type>json</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_populate_record</primary>
        </indexterm>
        <function>jsonb_populate_record</function> ( <parameter>base</parameter> <type>anyelement</type>, <parameter>from_json</parameter> <type>jsonb</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        Expands the top-level JSON object to a row having the composite type
        of the <parameter>base</parameter> argument.  The JSON object
        is scanned for fields whose names match column names of the output row
        type, and their values are inserted into those columns of the output.
        (Fields that do not correspond to any output column name are ignored.)
        In typical use, the value of <parameter>base</parameter> is just
        <literal>NULL</literal>, which means that any output columns that do
        not match any object field will be filled with nulls.  However,
        if <parameter>base</parameter> isn't <literal>NULL</literal> then
        the values it contains will be used for unmatched columns.
       </para>
       <para>
        To convert a JSON value to the SQL type of an output column, the
        following rules are applied in sequence:
        <itemizedlist spacing="compact">
         <listitem>
          <para>
           A JSON null value is converted to a SQL null in all cases.
          </para>
         </listitem>
         <listitem>
          <para>
           If the output column is of type <type>json</type>
           or <type>jsonb</type>, the JSON value is just reproduced exactly.
          </para>
         </listitem>
         <listitem>
          <para>
           If the output column is a composite (row) type, and the JSON value
           is a JSON object, the fields of the object are converted to columns
           of the output row type by recursive application of these rules.
          </para>
         </listitem>
         <listitem>
          <para>
           Likewise, if the output column is an array type and the JSON value
           is a JSON array, the elements of the JSON array are converted to
           elements of the output array by recursive application of these
           rules.
          </para>
         </listitem>
         <listitem>
          <para>
           Otherwise, if the JSON value is a string, the contents of the
           string are fed to the input conversion function for the column's
           data type.
          </para>
         </listitem>
         <listitem>
          <para>
           Otherwise, the ordinary text representation of the JSON value is
           fed to the input conversion function for the column's data type.
          </para>
         </listitem>
        </itemizedlist>
       </para>
       <para>
        While the example below uses a constant JSON value, typical use would
        be to reference a <type>json</type> or <type>jsonb</type> column
        laterally from another table in the query's <literal>FROM</literal>
        clause.  Writing <function>json_populate_record</function> in
        the <literal>FROM</literal> clause is good practice, since all of the
        extracted columns are available for use without duplicate function
        calls.
       </para>
       <para>
        <literal>create type subrowtype as (d int, e text);</literal>
        <literal>create type myrowtype as (a int, b text[], c subrowtype);</literal>
       </para>
       <para>
        <literal>select * from json_populate_record(null::myrowtype,
         '{"a": 1, "b": ["2", "a b"], "c": {"d": 4, "e": "a  b c"}, "x": "foo"}')</literal>
        <returnvalue></returnvalue>
<programlisting>
 a |   b       |      c
-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 1 | {2,"a b"} | (4,"a b c")
</programlisting>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_populate_record</primary>
        </indexterm>
        <function>json_populate_record</function> ( <parameter>base</parameter> <type>anyelement</type>, <parameter>from_json</parameter> <type>json</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_populate_record</primary>
        </indexterm>
        <function>jsonb_populate_record</function> ( <parameter>base</parameter> <type>anyelement</type>, <parameter>from_json</parameter> <type>jsonb</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        将顶级JSON对象扩展为具有<parameter>基本</parameter>参数的复合类型的行。JSON对象将被扫描，查找名称与输出行类型的列名匹配的字段，并将它们的值插入到输出的这些列中。
        (不对应任何输出列名的字段将被忽略。)在典型的使用中，<parameter>基本</parameter>的值仅为<literal>NULL</literal>，这意味着任何不匹配任何对象字段的输出列都将被填充为空。
        但是，如果<parameter>base</parameter>不为<literal>NULL</literal>，那么它包含的值将用于不匹配的列。
       </para>
       <para>
        要将JSON值转换为输出列的SQL类型，需要按次序应用以下规则:
        <itemizedlist spacing="compact">
         <listitem>
          <para>
           在所有情况下，JSON空值都会转换为SQL空值。
          </para>
         </listitem>
         <listitem>
          <para>
           如果输出列的类型是<type>json</type>或<type>jsonb</type>，则会精确地重制JSON值。
          </para>
         </listitem>
         <listitem>
          <para>
           如果输出列是复合(行)类型，且JSON值是JSON对象，则该对象的字段将转换为输出行类型的列，通过这些规则的递归应用程序。
          </para>
         </listitem>
         <listitem>
          <para>
           同样，如果输出列是数组类型，而JSON值是JSON数组，则通过这些规则的递归应用程序将JSON数组的元素转换为输出数组的元素。
          </para>
         </listitem>
         <listitem>
          <para>
           否则，如果JSON值是字符串，则将字符串的内容提供给输入转换函数，用以确定列的数据类型。
          </para>
         </listitem>
         <listitem>
          <para>
           否则，JSON值的普通文本表示将被提供给输入转换函数，以确定列的数据类型。
          </para>
         </listitem>
        </itemizedlist>
       </para>
       <para>
        虽然下面的示例使用一个常量JSON值，典型的用法是在查询的<literal>FROM</literal>子句中从另一个表侧面地引用<type>json</type>或<type>jsonb</type>列。
        在<literal>FROM</literal>子句中编写<function>json_populate_record</function>是一种很好的实践，因为提取的所有列都可以使用，而不需要重复的函数调用。
       </para>
       <para>
        <literal>create type subrowtype as (d int, e text);</literal>
        <literal>create type myrowtype as (a int, b text[], c subrowtype);</literal>
       </para>
       <para>
        <literal>select * from json_populate_record(null::myrowtype,
         '{"a": 1, "b": ["2", "a b"], "c": {"d": 4, "e": "a  b c"}, "x": "foo"}')</literal>
        <returnvalue></returnvalue>
<programlisting>
 a |   b       |      c
---+-----------+-------------
 1 | {2,"a b"} | (4,"a b c")
</programlisting>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_populate_recordset</primary>
        </indexterm>
        <function>json_populate_recordset</function> ( <parameter>base</parameter> <type>anyelement</type>, <parameter>from_json</parameter> <type>json</type> )
        <returnvalue>setof anyelement</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_populate_recordset</primary>
        </indexterm>
        <function>jsonb_populate_recordset</function> ( <parameter>base</parameter> <type>anyelement</type>, <parameter>from_json</parameter> <type>jsonb</type> )
        <returnvalue>setof anyelement</returnvalue>
       </para>
       <para>
        Expands the top-level JSON array of objects to a set of rows having
        the composite type of the <parameter>base</parameter> argument.
        Each element of the JSON array is processed as described above
        for <function>json[b]_populate_record</function>.
       </para>
       <para>
        <literal>create type twoints as (a int, b int);</literal>
       </para>
       <para>
        <literal>select * from json_populate_recordset(null::twoints, '[{"a":1,"b":2}, {"a":3,"b":4}]')</literal>
        <returnvalue></returnvalue>
<programlisting>
 a | b
-&minus;-+-&minus;-
 1 | 2
 3 | 4
</programlisting>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_populate_recordset</primary>
        </indexterm>
        <function>json_populate_recordset</function> ( <parameter>base</parameter> <type>anyelement</type>, <parameter>from_json</parameter> <type>json</type> )
        <returnvalue>setof anyelement</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_populate_recordset</primary>
        </indexterm>
        <function>jsonb_populate_recordset</function> ( <parameter>base</parameter> <type>anyelement</type>, <parameter>from_json</parameter> <type>jsonb</type> )
        <returnvalue>setof anyelement</returnvalue>
       </para>
       <para>
        将对象的顶级JSON数组展开为一组具有<parameter>基本</parameter>参数的复合类型的行。
        对于<function>json[b]_populate_record</function>，将如上所述处理JSON数组的每个元素。
       </para>
       <para>
        <literal>create type twoints as (a int, b int);</literal>
       </para>
       <para>
        <literal>select * from json_populate_recordset(null::twoints, '[{"a":1,"b":2}, {"a":3,"b":4}]')</literal>
        <returnvalue></returnvalue>
<programlisting>
 a | b
---+---
 1 | 2
 3 | 4
</programlisting>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_to_record</primary>
        </indexterm>
        <function>json_to_record</function> ( <type>json</type> )
        <returnvalue>record</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_to_record</primary>
        </indexterm>
        <function>jsonb_to_record</function> ( <type>jsonb</type> )
        <returnvalue>record</returnvalue>
       </para>
       <para>
        Expands the top-level JSON object to a row having the composite type
        defined by an <literal>AS</literal> clause.  (As with all functions
        returning <type>record</type>, the calling query must explicitly
        define the structure of the record with an <literal>AS</literal>
        clause.)  The output record is filled from fields of the JSON object,
        in the same way as described above
        for <function>json[b]_populate_record</function>.  Since there is no
        input record value, unmatched columns are always filled with nulls.
       </para>
       <para>
        <literal>create type myrowtype as (a int, b text);</literal>
       </para>
       <para>
        <literal>select * from json_to_record('{"a":1,"b":[1,2,3],"c":[1,2,3],"e":"bar","r": {"a": 123, "b": "a b c"}}') as x(a int, b text, c int[], d text, r myrowtype)</literal>
        <returnvalue></returnvalue>
<programlisting>
 a |    b    |    c    | d |       r
-&minus;-+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-+-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 1 | [1,2,3] | {1,2,3} |   | (123,"a b c")
</programlisting>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_to_record</primary>
        </indexterm>
        <function>json_to_record</function> ( <type>json</type> )
        <returnvalue>record</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_to_record</primary>
        </indexterm>
        <function>jsonb_to_record</function> ( <type>jsonb</type> )
        <returnvalue>record</returnvalue>
       </para>
       <para>
        将顶级JSON对象展开为具有由 <literal>AS</literal>子句定义的复合类型的行。
        (与所有返回<type>record</type>的函数一样，调用查询必须使用<literal>AS</literal>子句显式定义记录的结构。)
        输出记录由JSON对象的字段填充，与上面描述的<function>json[b]_populate_record</function>的方式相同。
        由于没有输入记录值，不匹配的列总是用空值填充。
       </para>
       <para>
        <literal>create type myrowtype as (a int, b text);</literal>
       </para>
       <para>
        <literal>select * from json_to_record('{"a":1,"b":[1,2,3],"c":[1,2,3],"e":"bar","r": {"a": 123, "b": "a b c"}}') as x(a int, b text, c int[], d text, r myrowtype)</literal>
        <returnvalue></returnvalue>
<programlisting>
 a |    b    |    c    | d |       r
---+---------+---------+---+---------------
 1 | [1,2,3] | {1,2,3} |   | (123,"a b c")
</programlisting>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_to_recordset</primary>
        </indexterm>
        <function>json_to_recordset</function> ( <type>json</type> )
        <returnvalue>setof record</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_to_recordset</primary>
        </indexterm>
        <function>jsonb_to_recordset</function> ( <type>jsonb</type> )
        <returnvalue>setof record</returnvalue>
       </para>
       <para>
        Expands the top-level JSON array of objects to a set of rows having
        the composite type defined by an <literal>AS</literal> clause.  (As
        with all functions returning <type>record</type>, the calling query
        must explicitly define the structure of the record with
        an <literal>AS</literal> clause.)  Each element of the JSON array is
        processed as described above
        for <function>json[b]_populate_record</function>.
       </para>
       <para>
        <literal>select * from json_to_recordset('[{"a":1,"b":"foo"}, {"a":"2","c":"bar"}]') as x(a int, b text)</literal>
        <returnvalue></returnvalue>
<programlisting>
 a |  b
-&minus;-+-&minus;-&minus;-
 1 | foo
 2 |
</programlisting>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_to_recordset</primary>
        </indexterm>
        <function>json_to_recordset</function> ( <type>json</type> )
        <returnvalue>setof record</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_to_recordset</primary>
        </indexterm>
        <function>jsonb_to_recordset</function> ( <type>jsonb</type> )
        <returnvalue>setof record</returnvalue>
       </para>
       <para>
        将顶级JSON对象数组展开为一组由<literal>AS</literal>子句定义的复合类型的行。
        (与所有返回record的函数一样，调用查询必须使用<literal>AS</literal>子句显式定义记录的结构。)
        对于<function>json[b]_populate_record</function>，将如上所述处理JSON数组的每个元素。
       </para>
       <para>
        <literal>select * from json_to_recordset('[{"a":1,"b":"foo"}, {"a":"2","c":"bar"}]') as x(a int, b text)</literal>
        <returnvalue></returnvalue>
<programlisting>
 a |  b
---+-----
 1 | foo
 2 |
</programlisting>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_set</primary>
        </indexterm>
        <function>jsonb_set</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>text[]</type>, <parameter>new_value</parameter> <type>jsonb</type> <optional>, <parameter>create_if_missing</parameter> <type>boolean</type> </optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Returns <parameter>target</parameter>
        with the item designated by <parameter>path</parameter>
        replaced by <parameter>new_value</parameter>, or with
        <parameter>new_value</parameter> added if
        <parameter>create_if_missing</parameter> is true (which is the
        default) and the item designated by <parameter>path</parameter>
        does not exist.
        All earlier steps in the path must exist, or
        the <parameter>target</parameter> is returned unchanged.
        As with the path oriented operators, negative integers that
        appear in the <parameter>path</parameter> count from the end
        of JSON arrays.
        If the last path step is an array index that is out of range,
        and <parameter>create_if_missing</parameter> is true, the new
        value is added at the beginning of the array if the index is negative,
        or at the end of the array if it is positive.
       </para>
       <para>
        <literal>jsonb_set('[{"f1":1,"f2":null},2,null,3]', '{0,f1}', '[2,3,4]', false)</literal>
        <returnvalue>[{"f1": [2, 3, 4], "f2": null}, 2, null, 3]</returnvalue>
       </para>
       <para>
        <literal>jsonb_set('[{"f1":1,"f2":null},2]', '{0,f3}', '[2,3,4]')</literal>
        <returnvalue>[{"f1": 1, "f2": null, "f3": [2, 3, 4]}, 2]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_set</primary>
        </indexterm>
        <function>jsonb_set</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>text[]</type>, <parameter>new_value</parameter> <type>jsonb</type> <optional>, <parameter>create_if_missing</parameter> <type>boolean</type> </optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        返回<parameter>target</parameter>，将<parameter>path</parameter>指定的项替换为<parameter>new_value</parameter>，
        如果<parameter>create_if_missing</parameter>为真(此为默认值)并且<parameter>path</parameter>指定的项不存在，则添加<parameter>new_value</parameter>。
        路径中的所有前面步骤都必须存在，否则将不加改变地返回<parameter>target</parameter>。
        与面向路径操作符一样，负整数出现在JSON数组末尾的<parameter>path</parameter>计数中。
        如果最后一个路径步骤是超出范围的数组索引，并且<parameter>create_if_missing</parameter>为真，那么如果索引为负，新值将添加到数组的开头，如果索引为正，则添加到数组的结尾。
       </para>
       <para>
        <literal>jsonb_set('[{"f1":1,"f2":null},2,null,3]', '{0,f1}', '[2,3,4]', false)</literal>
        <returnvalue>[{"f1": [2, 3, 4], "f2": null}, 2, null, 3]</returnvalue>
       </para>
       <para>
        <literal>jsonb_set('[{"f1":1,"f2":null},2]', '{0,f3}', '[2,3,4]')</literal>
        <returnvalue>[{"f1": 1, "f2": null, "f3": [2, 3, 4]}, 2]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_set_lax</primary>
        </indexterm>
        <function>jsonb_set_lax</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>text[]</type>, <parameter>new_value</parameter> <type>jsonb</type> <optional>, <parameter>create_if_missing</parameter> <type>boolean</type> <optional>, <parameter>null_value_treatment</parameter> <type>text</type> </optional></optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        If <parameter>new_value</parameter> is not <literal>NULL</literal>,
        behaves identically to <literal>jsonb_set</literal>. Otherwise behaves
        according to the value
        of <parameter>null_value_treatment</parameter> which must be one
        of <literal>'raise_exception'</literal>,
        <literal>'use_json_null'</literal>, <literal>'delete_key'</literal>, or
        <literal>'return_target'</literal>. The default is
        <literal>'use_json_null'</literal>.
       </para>
       <para>
        <literal>jsonb_set_lax('[{"f1":1,"f2":null},2,null,3]', '{0,f1}', null)</literal>
        <returnvalue>[{"f1":null,"f2":null},2,null,3]</returnvalue>
       </para>
       <para>
        <literal>jsonb_set_lax('[{"f1":99,"f2":null},2]', '{0,f3}', null, true, 'return_target')</literal>
        <returnvalue>[{"f1": 99, "f2": null}, 2]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_set_lax</primary>
        </indexterm>
        <function>jsonb_set_lax</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>text[]</type>, <parameter>new_value</parameter> <type>jsonb</type> <optional>, <parameter>create_if_missing</parameter> <type>boolean</type> <optional>, <parameter>null_value_treatment</parameter> <type>text</type> </optional></optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        如果<parameter>new_value</parameter>不为<literal>NULL</literal>，则行为与<literal>jsonb_set</literal>完全一样。
        否则，根据<parameter>null_value_treatment</parameter>的值，它必须是<literal>'raise_exception'</literal>，<literal>'use_json_null'</literal>, <literal>'delete_key'</literal>, 或<literal>'return_target'</literal>。
        默认值为<literal>'use_json_null'</literal>。
       </para>
       <para>
        <literal>jsonb_set_lax('[{"f1":1,"f2":null},2,null,3]', '{0,f1}', null)</literal>
        <returnvalue>[{"f1":null,"f2":null},2,null,3]</returnvalue>
       </para>
       <para>
        <literal>jsonb_set_lax('[{"f1":99,"f2":null},2]', '{0,f3}', null, true, 'return_target')</literal>
        <returnvalue>[{"f1": 99, "f2": null}, 2]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_insert</primary>
        </indexterm>
        <function>jsonb_insert</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>text[]</type>, <parameter>new_value</parameter> <type>jsonb</type> <optional>, <parameter>insert_after</parameter> <type>boolean</type> </optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Returns <parameter>target</parameter>
        with <parameter>new_value</parameter> inserted.  If the item
        designated by the <parameter>path</parameter> is an array
        element, <parameter>new_value</parameter> will be inserted before
        that item if <parameter>insert_after</parameter> is false (which
        is the default), or after it
        if <parameter>insert_after</parameter> is true.  If the item
        designated by the <parameter>path</parameter> is an object
        field, <parameter>new_value</parameter> will be inserted only if
        the object does not already contain that key.
        All earlier steps in the path must exist, or
        the <parameter>target</parameter> is returned unchanged.
        As with the path oriented operators, negative integers that
        appear in the <parameter>path</parameter> count from the end
        of JSON arrays.
        If the last path step is an array index that is out of range, the new
        value is added at the beginning of the array if the index is negative,
        or at the end of the array if it is positive.
       </para>
       <para>
        <literal>jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '"new_value"')</literal>
        <returnvalue>{"a": [0, "new_value", 1, 2]}</returnvalue>
       </para>
       <para>
        <literal>jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '"new_value"', true)</literal>
        <returnvalue>{"a": [0, 1, "new_value", 2]}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_insert</primary>
        </indexterm>
        <function>jsonb_insert</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>text[]</type>, <parameter>new_value</parameter> <type>jsonb</type> <optional>, <parameter>insert_after</parameter> <type>boolean</type> </optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        返回插入<parameter>new_value</parameter>的<parameter>target</parameter>。
        如果<parameter>path</parameter>指派的项是一个数组元素，如果 <parameter>insert_after</parameter>为假(此为默认值)，则<parameter>new_value</parameter>将被插入到该项之前，如果 <parameter>insert_after</parameter>为真则在该项之后。
        如果由<parameter>path</parameter>指派的项是一个对象字段，则只在对象不包含该键时才插入 <parameter>new_value</parameter>。
        路径中的所有前面步骤都必须存在，否则将不加改变地返回<parameter>target</parameter>。
        与面向路径操作符一样，负整数出现在JSON数组末尾的 <parameter>path</parameter>计数中。
        如果最后一个路径步骤是超出范围的数组下标，则如果下标为负，则将新值添加到数组的开头;如果下标为正，则将新值添加到数组的结尾。
       </para>
       <para>
        <literal>jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '"new_value"')</literal>
        <returnvalue>{"a": [0, "new_value", 1, 2]}</returnvalue>
       </para>
       <para>
        <literal>jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '"new_value"', true)</literal>
        <returnvalue>{"a": [0, 1, "new_value", 2]}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_strip_nulls</primary>
        </indexterm>
        <function>json_strip_nulls</function> ( <type>json</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_strip_nulls</primary>
        </indexterm>
        <function>jsonb_strip_nulls</function> ( <type>jsonb</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Deletes all object fields that have null values from the given JSON
        value, recursively.  Null values that are not object fields are
        untouched.
       </para>
       <para>
        <literal>json_strip_nulls('[{"f1":1, "f2":null}, 2, null, 3]')</literal>
        <returnvalue>[{"f1":1},2,null,3]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_strip_nulls</primary>
        </indexterm>
        <function>json_strip_nulls</function> ( <type>json</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_strip_nulls</primary>
        </indexterm>
        <function>jsonb_strip_nulls</function> ( <type>jsonb</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        从给定的JSON值中删除所有具有空值的对象字段，递归地。非对象字段的空值是未受影响的。
       </para>
       <para>
        <literal>json_strip_nulls('[{"f1":1, "f2":null}, 2, null, 3]')</literal>
        <returnvalue>[{"f1":1},2,null,3]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_exists</primary>
        </indexterm>
        <function>jsonb_path_exists</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Checks whether the JSON path returns any item for the specified JSON
        value.
        If the <parameter>vars</parameter> argument is specified, it must
        be a JSON object, and its fields provide named values to be
        substituted into the <type>jsonpath</type> expression.
        If the <parameter>silent</parameter> argument is specified and
        is <literal>true</literal>, the function suppresses the same errors
        as the <literal>@?</literal> and <literal>@@</literal> operators do.
       </para>
       <para>
        <literal>jsonb_path_exists('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_exists</primary>
        </indexterm>
        <function>jsonb_path_exists</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        检查JSON路径是否返回指定JSON值的任何项。如果指定了<parameter>vars</parameter>参数，则它必须是一个JSON对象，并且它的字段提供要替换到<type>jsonpath</type>表达式中的名称值。
        如果指定了<parameter>silent</parameter>参数并为<literal>true</literal>，函数会抑制与<literal>@?</literal> 和 <literal>@@</literal>运算符相同的错误。
       </para>
       <para>
        <literal>jsonb_path_exists('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_match</primary>
        </indexterm>
        <function>jsonb_path_match</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Returns the result of a JSON path predicate check for the specified
        JSON value.  Only the first item of the result is taken into account.
        If the result is not Boolean, then <literal>NULL</literal> is returned.
        The optional <parameter>vars</parameter>
        and <parameter>silent</parameter> arguments act the same as
        for <function>jsonb_path_exists</function>.
       </para>
       <para>
        <literal>jsonb_path_match('{"a":[1,2,3,4,5]}', 'exists($.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max))', '{"min":2, "max":4}')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_match</primary>
        </indexterm>
        <function>jsonb_path_match</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        返回指定JSON值的JSON路径谓词检查的结果。只有结果的第一项被考虑在内。
        如果结果不是布尔值，则返回<literal>NULL</literal>。可选的<parameter>vars</parameter>和<parameter>silent</parameter>参数的作用与<function>jsonb_path_exists</function>相同。
       </para>
       <para>
        <literal>jsonb_path_match('{"a":[1,2,3,4,5]}', 'exists($.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max))', '{"min":2, "max":4}')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query</primary>
        </indexterm>
        <function>jsonb_path_query</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>setof jsonb</returnvalue>
       </para>
       <para>
        Returns all JSON items returned by the JSON path for the specified
        JSON value.
        The optional <parameter>vars</parameter>
        and <parameter>silent</parameter> arguments act the same as
        for <function>jsonb_path_exists</function>.
       </para>
       <para>
        <literal>select * from jsonb_path_query('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}')</literal>
        <returnvalue></returnvalue>
<programlisting>
 jsonb_path_query
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 2
 3
 4
</programlisting>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query</primary>
        </indexterm>
        <function>jsonb_path_query</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>setof jsonb</returnvalue>
       </para>
       <para>
        为指定的JSON值返回由JSON路径返回的所有JSON项。可选的<parameter>vars</parameter>和<parameter>silent</parameter>参数的作用与<function>jsonb_path_exists</function>相同。
       </para>
       <para>
        <literal>select * from jsonb_path_query('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}')</literal>
        <returnvalue></returnvalue>
<programlisting>
 jsonb_path_query
------------------
 2
 3
 4
</programlisting>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query_array</primary>
        </indexterm>
        <function>jsonb_path_query_array</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Returns all JSON items returned by the JSON path for the specified
        JSON value, as a JSON array.
        The optional <parameter>vars</parameter>
        and <parameter>silent</parameter> arguments act the same as
        for <function>jsonb_path_exists</function>.
       </para>
       <para>
        <literal>jsonb_path_query_array('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}')</literal>
        <returnvalue>[2, 3, 4]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query_array</primary>
        </indexterm>
        <function>jsonb_path_query_array</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        以JSON数组的形式返回由JSON路径为指定的JSON值返回的所有JSON项。可选的<parameter>vars</parameter>和<parameter>silent</parameter>参数的作用与<function>jsonb_path_exists</function>相同。
       </para>
       <para>
        <literal>jsonb_path_query_array('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}')</literal>
        <returnvalue>[2, 3, 4]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query_first</primary>
        </indexterm>
        <function>jsonb_path_query_first</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Returns the first JSON item returned by the JSON path for the
        specified JSON value.  Returns <literal>NULL</literal> if there are no
        results.
        The optional <parameter>vars</parameter>
        and <parameter>silent</parameter> arguments act the same as
        for <function>jsonb_path_exists</function>.
       </para>
       <para>
        <literal>jsonb_path_query_first('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query_first</primary>
        </indexterm>
        <function>jsonb_path_query_first</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        为指定的JSON值返回由JSON路径返回的第一个JSON项。如果没有结果则返回<literal>NULL</literal>。
        可选的<parameter>vars</parameter>和<parameter>silent</parameter>参数的作用与 <function>jsonb_path_exists</function>相同。
       </para>
       <para>
        <literal>jsonb_path_query_first('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_exists_tz</primary>
        </indexterm>
        <function>jsonb_path_exists_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_path_match_tz</primary>
        </indexterm>
        <function>jsonb_path_match_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query_tz</primary>
        </indexterm>
        <function>jsonb_path_query_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>setof jsonb</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query_array_tz</primary>
        </indexterm>
        <function>jsonb_path_query_array_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query_first_tz</primary>
        </indexterm>
        <function>jsonb_path_query_first_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        These functions act like their counterparts described above without
        the <literal>_tz</literal> suffix, except that these functions support
        comparisons of date/time values that require timezone-aware
        conversions.  The example below requires interpretation of the
        date-only value <literal>2015-08-02</literal> as a timestamp with time
        zone, so the result depends on the current
        <xref linkend="guc-timezone"/> setting.  Due to this dependency, these
        functions are marked as stable, which means these functions cannot be
        used in indexes.  Their counterparts are immutable, and so can be used
        in indexes; but they will throw errors if asked to make such
        comparisons.
       </para>
       <para>
        <literal>jsonb_path_exists_tz('["2015-08-01 12:00:00 -05"]', '$[*] ? (@.datetime() &lt; "2015-08-02".datetime())')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_exists_tz</primary>
        </indexterm>
        <function>jsonb_path_exists_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_path_match_tz</primary>
        </indexterm>
        <function>jsonb_path_match_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query_tz</primary>
        </indexterm>
        <function>jsonb_path_query_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>setof jsonb</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query_array_tz</primary>
        </indexterm>
        <function>jsonb_path_query_array_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query_first_tz</primary>
        </indexterm>
        <function>jsonb_path_query_first_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        这些函数与上面描述的没有<literal>_tz</literal>后缀的对应函数类似，除了这些函数支持需要时区感知转换的日期/时间值比较之外。
        下面的示例需要将只包含日期的值<literal>2015-08-02</literal>解释为带有时区的时间戳，因此结果依赖于当前<xref linkend="guc-timezone"/>设置。
        由于这种依赖性，这些函数被标记为稳定的，这意味着不能在索引中使用这些函数。
        它们的对应项是不可改变的，因此可以用于索引;但是，如果要求他们进行这样的比较，他们就会抛出错误。
       </para>
       <para>
        <literal>jsonb_path_exists_tz('["2015-08-01 12:00:00 -05"]', '$[*] ? (@.datetime() &lt; "2015-08-02".datetime())')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_pretty</primary>
        </indexterm>
        <function>jsonb_pretty</function> ( <type>jsonb</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts the given JSON value to pretty-printed, indented text.
       </para>
       <para>
        <literal>jsonb_pretty('[{"f1":1,"f2":null}, 2]')</literal>
        <returnvalue></returnvalue>
<programlisting>
[
    {
        "f1": 1,
        "f2": null
    },
    2
]
</programlisting>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_pretty</primary>
        </indexterm>
        <function>jsonb_pretty</function> ( <type>jsonb</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将给定的JSON值转换为精美打印的，缩进的文本。
       </para>
       <para>
        <literal>jsonb_pretty('[{"f1":1,"f2":null}, 2]')</literal>
        <returnvalue></returnvalue>
<programlisting>
[
    {
        "f1": 1,
        "f2": null
    },
    2
]
</programlisting>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_typeof</primary>
        </indexterm>
        <function>json_typeof</function> ( <type>json</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_typeof</primary>
        </indexterm>
        <function>jsonb_typeof</function> ( <type>jsonb</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the type of the top-level JSON value as a text string.
        Possible types are
        <literal>object</literal>, <literal>array</literal>,
        <literal>string</literal>, <literal>number</literal>,
        <literal>boolean</literal>, and <literal>null</literal>.
        (The <literal>null</literal> result should not be confused
        with a SQL NULL; see the examples.)
       </para>
       <para>
        <literal>json_typeof('-123.4')</literal>
        <returnvalue>number</returnvalue>
       </para>
       <para>
        <literal>json_typeof('null'::json)</literal>
        <returnvalue>null</returnvalue>
       </para>
       <para>
        <literal>json_typeof(NULL::json) IS NULL</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_typeof</primary>
        </indexterm>
        <function>json_typeof</function> ( <type>json</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_typeof</primary>
        </indexterm>
        <function>jsonb_typeof</function> ( <type>jsonb</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        以文本字符串形式返回顶级JSON值的类型。可能的类型有<literal>object</literal>, <literal>array</literal>,<literal>string</literal>, <literal>number</literal>,<literal>boolean</literal>, 和 <literal>null</literal>。
        (<literal>null</literal>的结果不应该与SQL NULL 混淆;参见示例。)
       </para>
       <para>
        <literal>json_typeof('-123.4')</literal>
        <returnvalue>number</returnvalue>
       </para>
       <para>
        <literal>json_typeof('null'::json)</literal>
        <returnvalue>null</returnvalue>
       </para>
       <para>
        <literal>json_typeof(NULL::json) IS NULL</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
  <para>
    See also <xref linkend="functions-aggregate"/> for the aggregate
    function <function>json_agg</function> which aggregates record
    values as JSON, the aggregate function
    <function>json_object_agg</function> which aggregates pairs of values
    into a JSON object, and their <type>jsonb</type> equivalents,
    <function>jsonb_agg</function> and <function>jsonb_object_agg</function>.
  </para>
____________________________________________________________________________-->
  <para>
    参见 <xref linkend="functions-aggregate"/>，聚合函数<function>json_agg</function>将聚合记录值为JSON，聚合函数<function>json_object_agg</function>将聚合成对的值为JSON对象，
    以及它们在<type>jsonb</type>中的相当的(函数)，<function>jsonb_agg</function>和<function>jsonb_object_agg</function>。
  </para>
 </sect2>

 <sect2 id="functions-sqljson-path">
<!--==========================orignal english content==========================
  <title>The SQL/JSON Path Language</title>
____________________________________________________________________________-->
  <title>SQL/JSON 路径语言</title>

<!--==========================orignal english content==========================
  <indexterm zone="functions-sqljson-path">
   <primary>SQL/JSON path language</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="functions-sqljson-path">
   <primary>SQL/JSON 路径语言</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   SQL/JSON path expressions specify the items to be retrieved
   from the JSON data, similar to XPath expressions used
   for SQL access to XML. In <productname>PostgreSQL</productname>,
   path expressions are implemented as the <type>jsonpath</type>
   data type and can use any elements described in
   <xref linkend="datatype-jsonpath"/>.
  </para>
____________________________________________________________________________-->
  <para>
   SQL/JSON路径表达式指定了要从JSON数据中检索的项目，类似于SQL访问XML时使用的XPath表达式。
   在<productname>PostgreSQL</productname>中，路径表达式作为<type>jsonpath</type>数据类型实现，可以使用<xref linkend="datatype-jsonpath"/>中描述的任何元素。
  </para>

<!--==========================orignal english content==========================
  <para>
   JSON query functions and operators
   pass the provided path expression to the <firstterm>path engine</firstterm>
   for evaluation. If the expression matches the queried JSON data,
   the corresponding JSON item, or set of items, is returned.
   Path expressions are written in the SQL/JSON path language
   and can include arithmetic expressions and functions.
  </para>
____________________________________________________________________________-->
  <para>
   JSON查询函数和操作符将提供的路径表达式传递给<firstterm>path engine</firstterm>进行评估。
   如果表达式与被查询的JSON数据匹配，则返回相应的JSON项或项集。
   路径表达式是用SQL/JSON路径语言编写的，也可以包括算术表达式和函数。
  </para>

<!--==========================orignal english content==========================
  <para>
   A path expression consists of a sequence of elements allowed
   by the <type>jsonpath</type> data type.
   The path expression is normally evaluated from left to right, but
   you can use parentheses to change the order of operations.
   If the evaluation is successful, a sequence of JSON items is produced,
   and the evaluation result is returned to the JSON query function
   that completes the specified computation.
  </para>
____________________________________________________________________________-->
  <para>
   路径表达式由<type>jsonpath</type>数据类型允许的元素序列组成。路径表达式通常从左向右求值，但你可以使用圆括号来更改操作的顺序。
   如果计算成功，将生成一系列JSON项，并将计算结果返回到JSON查询函数，该函数将完成指定的计算。
  </para>

<!--==========================orignal english content==========================
  <para>
   To refer to the JSON value being queried (the
   <firstterm>context item</firstterm>), use the <literal>$</literal> variable
   in the path expression. It can be followed by one or more
   <link linkend="type-jsonpath-accessors">accessor operators</link>,
   which go down the JSON structure level by level to retrieve sub-items
   of the context item. Each operator that follows deals with the
   result of the previous evaluation step.
  </para>
____________________________________________________________________________-->
  <para>
   要引用正在查询的JSON值(<firstterm>context item</firstterm>项)，在路径表达式中使用<literal>$</literal>变量。
   它后面可以跟着一个或多个<link linkend="type-jsonpath-accessors">accessor operators</link>，这些操作符在JSON结构中逐级向下检索上下文项的子项。
   后面的每个操作符处理前一个求值步骤的结果。
  </para>

<!--==========================orignal english content==========================
  <para>
   For example, suppose you have some JSON data from a GPS tracker that you
   would like to parse, such as:
<programlisting>
{
  "track": {
    "segments": [
      {
        "location":   [ 47.763, 13.4034 ],
        "start time": "2018-10-14 10:05:14",
        "HR": 73
      },
      {
        "location":   [ 47.706, 13.2635 ],
        "start time": "2018-10-14 10:39:21",
        "HR": 135
      }
    ]
  }
}
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   例如，假设你有一些你想要解析的来自GPS跟踪器的JSON数据，例如:
<programlisting>
{
  "track": {
    "segments": [
      {
        "location":   [ 47.763, 13.4034 ],
        "start time": "2018-10-14 10:05:14",
        "HR": 73
      },
      {
        "location":   [ 47.706, 13.2635 ],
        "start time": "2018-10-14 10:39:21",
        "HR": 135
      }
    ]
  }
}
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   To retrieve the available track segments, you need to use the
   <literal>.<replaceable>key</replaceable></literal> accessor
   operator to descend through surrounding JSON objects:
<programlisting>
$.track.segments
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   为了检索可用的轨迹段，你需要使用<literal>.<replaceable>key</replaceable></literal>访问操作符来向下浏览周边的JSON对象:
<programlisting>
$.track.segments
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   To retrieve the contents of an array, you typically use the
   <literal>[*]</literal> operator. For example,
   the following path will return the location coordinates for all
   the available track segments:
<programlisting>
$.track.segments[*].location
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   要检索数组的内容，通常使用<literal>[*]</literal>操作符。例如，下面的路径将返回所有可用轨道段的位置坐标:
<programlisting>
$.track.segments[*].location
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   To return the coordinates of the first segment only, you can
   specify the corresponding subscript in the <literal>[]</literal>
   accessor operator. Recall that JSON array indexes are 0-relative:
<programlisting>
$.track.segments[0].location
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   要只返回第一个段的坐标，可以在<literal>[]</literal>访问操作符中指定相应的下标。重新调用相对于0的JSON数组索引:
<programlisting>
$.track.segments[0].location
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   The result of each path evaluation step can be processed
   by one or more <type>jsonpath</type> operators and methods
   listed in <xref linkend="functions-sqljson-path-operators"/>.
   Each method name must be preceded by a dot. For example,
   you can get the size of an array:
<programlisting>
$.track.segments.size()
</programlisting>
   More examples of using <type>jsonpath</type> operators
   and methods within path expressions appear below in
   <xref linkend="functions-sqljson-path-operators"/>.
  </para>
____________________________________________________________________________-->
  <para>
   每个路径求值步骤的结果可以由<xref linkend="functions-sqljson-path-operators"/>中列出的一个或多个<type>jsonpath</type>操作符和方法来处理。
   每个方法名之前必须有一个点。例如，你可以得到一个数组的大小:
<programlisting>
$.track.segments.size()
</programlisting>
   在路径表达式中使用<type>jsonpath</type>操作符和方法的更多示例见下面<xref linkend="functions-sqljson-path-operators"/>。
  </para>

<!--==========================orignal english content==========================
  <para>
   When defining a path, you can also use one or more
   <firstterm>filter expressions</firstterm> that work similarly to the
   <literal>WHERE</literal> clause in SQL. A filter expression begins with
   a question mark and provides a condition in parentheses:

<programlisting>
? (<replaceable>condition</replaceable>)
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   在定义路径时，还可以使用一个或多个与SQL中的<literal>WHERE</literal>子句类似的<firstterm>filter expressions</firstterm>。
   过滤器表达式以问号开头，并在圆括号中提供条件:

<programlisting>
? (<replaceable>condition</replaceable>)
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Filter expressions must be written just after the path evaluation step
   to which they should apply. The result of that step is filtered to include
   only those items that satisfy the provided condition. SQL/JSON defines
   three-valued logic, so the condition can be <literal>true</literal>, <literal>false</literal>,
   or <literal>unknown</literal>. The <literal>unknown</literal> value
   plays the same role as SQL <literal>NULL</literal> and can be tested
   for with the <literal>is unknown</literal> predicate. Further path
   evaluation steps use only those items for which the filter expression
   returned <literal>true</literal>.
  </para>
____________________________________________________________________________-->
  <para>
   过滤表达式必须在它们应该应用的路径求值步骤之后写入。该步骤的结果将被筛选，以只包括满足所提供条件的那些项。
   SQL/JSON定义了三值逻辑，因此条件可以是 <literal>true</literal>, <literal>false</literal>,或 <literal>unknown</literal>。
   <literal>unknown</literal>值发挥与SQL <literal>NULL</literal>相同的角色，可以使用<literal>is unknown</literal>谓词进行测试。
   进一步的路径求值步骤只使用筛选器表达式返回<literal>true</literal>的那些项。
  </para>

<!--==========================orignal english content==========================
  <para>
   The functions and operators that can be used in filter expressions are
   listed in <xref linkend="functions-sqljson-filter-ex-table"/>.  Within a
   filter expression, the <literal>@</literal> variable denotes the value
   being filtered (i.e., one result of the preceding path step).  You can
   write accessor operators after <literal>@</literal> to retrieve component
   items.
  </para>
____________________________________________________________________________-->
  <para>
   可以在过滤表达式中使用的函数和操作符罗列在<xref linkend="functions-sqljson-filter-ex-table"/>中。
   在一个过滤表达式中，<literal>@</literal>变量表示被过滤的值(也就是说，前面路径步骤的一个结果)。你可以在 <literal>@</literal>后面写访问操作符来检索组件项。
  </para>

<!--==========================orignal english content==========================
  <para>
   For example, suppose you would like to retrieve all heart rate values higher
   than 130. You can achieve this using the following expression:
<programlisting>
$.track.segments[*].HR ? (@ &gt; 130)
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   例如，假设你想要检索所有高于130的心率值。你可以使用下面的表达式来实现这一点:
<programlisting>
$.track.segments[*].HR ? (@ &gt; 130)
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   To get the start times of segments with such values, you have to
   filter out irrelevant segments before returning the start times, so the
   filter expression is applied to the previous step, and the path used
   in the condition is different:
<programlisting>
$.track.segments[*] ? (@.HR &gt; 130)."start time"
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   为了获得具有这些值的片段的开始时间，必须在返回开始时间之前过滤掉不相关的片段，所以过滤表达式应用于上一步，条件中使用的路径不同:
<programlisting>
$.track.segments[*] ? (@.HR &gt; 130)."start time"
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   You can use several filter expressions in sequence, if required. For
   example, the following expression selects start times of all segments that
   contain locations with relevant coordinates and high heart rate values:
<programlisting>
$.track.segments[*] ? (@.location[1] &lt; 13.4) ? (@.HR &gt; 130)."start time"
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   如果需要，可以按顺序使用几个过滤器表达式。例如，下面的表达式选择所有包含有相关坐标和高心率值的位置的段的开始时间:
<programlisting>
$.track.segments[*] ? (@.location[1] &lt; 13.4) ? (@.HR &gt; 130)."start time"
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Using filter expressions at different nesting levels is also allowed.
   The following example first filters all segments by location, and then
   returns high heart rate values for these segments, if available:
<programlisting>
$.track.segments[*] ? (@.location[1] &lt; 13.4).HR ? (@ &gt; 130)
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   也允许在不同嵌套层级中使用过滤器表达式。下面的例子首先根据位置筛选所有的片段，然后返回这些片段的高心率值，如果适用的话:
<programlisting>
$.track.segments[*] ? (@.location[1] &lt; 13.4).HR ? (@ &gt; 130)
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   You can also nest filter expressions within each other:
<programlisting>
$.track ? (exists(@.segments[*] ? (@.HR &gt; 130))).segments.size()
</programlisting>
   This expression returns the size of the track if it contains any
   segments with high heart rate values, or an empty sequence otherwise.
  </para>
____________________________________________________________________________-->
  <para>
   你也可以在彼此之间嵌套过滤器表达式:
<programlisting>
$.track ? (exists(@.segments[*] ? (@.HR &gt; 130))).segments.size()
</programlisting>
   如果包含任何具有高心率值的片段，则该表达式返回曲目的大小，否则返回空序列。
  </para>

<!--==========================orignal english content==========================
  <para>
   <productname>PostgreSQL</productname>'s implementation of the SQL/JSON path
   language has the following deviations from the SQL/JSON standard:
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>的SQL/JSON路径语言的实现与SQL/JSON标准有以下偏差:
  </para>

  <itemizedlist>
   <listitem>
<!--==========================orignal english content==========================
    <para>
     A path expression can be a Boolean predicate, although the SQL/JSON
     standard allows predicates only in filters.  This is necessary for
     implementation of the <literal>@@</literal> operator. For example,
     the following <type>jsonpath</type> expression is valid in
     <productname>PostgreSQL</productname>:
<programlisting>
$.track.segments[*].HR &lt; 70
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     路径表达式可以是布尔谓词，尽管SQL/JSON标准只允许在过滤器中使用谓词。
     这是实现<literal>@@</literal>操作符所必需的。例如，下面的<type>jsonpath</type>表达式在<productname>PostgreSQL</productname>中是有效的:
<programlisting>
$.track.segments[*].HR &lt; 70
</programlisting>
    </para>
   </listitem>

   <listitem>
<!--==========================orignal english content==========================
    <para>
     There are minor differences in the interpretation of regular
     expression patterns used in <literal>like_regex</literal> filters, as
     described in <xref linkend="jsonpath-regular-expressions"/>.
    </para>
____________________________________________________________________________-->
    <para>
     在解释<literal>like_regex</literal>过滤器中使用的正则表达式模式方面有一些小的差异，如<xref linkend="jsonpath-regular-expressions"/>中所述。
    </para>
   </listitem>
  </itemizedlist>

   <sect3 id="strict-and-lax-modes">
<!--==========================orignal english content==========================
   <title>Strict and Lax Modes</title>
____________________________________________________________________________-->
   <title>严格的(Strict) 和 不严格的(Lax) 模式</title>
<!--==========================orignal english content==========================
    <para>
     When you query JSON data, the path expression may not match the
     actual JSON data structure. An attempt to access a non-existent
     member of an object or element of an array results in a
     structural error. SQL/JSON path expressions have two modes
     of handling structural errors:
    </para>
____________________________________________________________________________-->
    <para>
     当查询JSON数据时，路径表达式可能与实际的JSON数据结构不匹配。
     试图访问不存在的对象成员或数组元素会导致结构错误。SQL/JSON路径表达式有两种处理结构错误的模式:
    </para>

   <itemizedlist>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      lax (default) &mdash; the path engine implicitly adapts
      the queried data to the specified path.
      Any remaining structural errors are suppressed and converted
      to empty SQL/JSON sequences.
     </para>
____________________________________________________________________________-->
     <para>
      不严格的(lax)(默认)&mdash;路径引擎隐式地将查询的数据适配到指定的路径。任何剩余的结构错误都将被抑制并转换为空SQL/JSON序列。
     </para>
    </listitem>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      strict &mdash; if a structural error occurs, an error is raised.
     </para>
____________________________________________________________________________-->
     <para>
      严格的(strict) &mdash;如果发生了结构错误，则会引发错误。
     </para>
    </listitem>
   </itemizedlist>

<!--==========================orignal english content==========================
   <para>
    The lax mode facilitates matching of a JSON document structure and path
    expression if the JSON data does not conform to the expected schema.
    If an operand does not match the requirements of a particular operation,
    it can be automatically wrapped as an SQL/JSON array or unwrapped by
    converting its elements into an SQL/JSON sequence before performing
    this operation. Besides, comparison operators automatically unwrap their
    operands in the lax mode, so you can compare SQL/JSON arrays
    out-of-the-box. An array of size 1 is considered equal to its sole element.
    Automatic unwrapping is not performed only when:
    <itemizedlist>
     <listitem>
      <para>
       The path expression contains <literal>type()</literal> or
       <literal>size()</literal> methods that return the type
       and the number of elements in the array, respectively.
      </para>
     </listitem>
     <listitem>
      <para>
       The queried JSON data contain nested arrays. In this case, only
       the outermost array is unwrapped, while all the inner arrays
       remain unchanged. Thus, implicit unwrapping can only go one
       level down within each path evaluation step.
      </para>
     </listitem>
    </itemizedlist>
   </para>
____________________________________________________________________________-->
   <para>
    如果JSON数据不符合期望的模式，不严格的(lax)模式有助于匹配JSON文档结构和路径表达式。
    如果操作不匹配特定操作的要求，可以自动将其包装为SQL/JSON数组，也可以在执行该操作之前将其元素转换为SQL/JSON序列来解包装。
    此外，比较操作符会自动以lax模式打开它们的操作数，因此你可以开包即用的就能比较SQL/JSON数组。
    大小为1的数组被认为等于它的唯一元素。只有在以下情况下才不会自动展开:
    <itemizedlist>
     <listitem>
      <para>
       路径表达式包含<literal>type()</literal>或<literal>size()</literal>方法，它们分别返回数组中的元素类型和数量。
      </para>
     </listitem>
     <listitem>
      <para>
       查询的JSON数据包含嵌套的数组。在本例中，只有最外层的数组被打开，而所有内部数组保持不变。
       因此，隐式展开在每个路径求值步骤中只能向下进行一级。
      </para>
     </listitem>
    </itemizedlist>
   </para>

<!--==========================orignal english content==========================
   <para>
    For example, when querying the GPS data listed above, you can
    abstract from the fact that it stores an array of segments
    when using the lax mode:
<programlisting>
lax $.track.segments.location
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    例如，当查询上面列出的GPS数据时，当使用不严格的(lax)模式时，你可以从它存储了一组片段的事实中抽象出来:
<programlisting>
lax $.track.segments.location
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    In the strict mode, the specified path must exactly match the structure of
    the queried JSON document to return an SQL/JSON item, so using this
    path expression will cause an error. To get the same result as in
    the lax mode, you have to explicitly unwrap the
    <literal>segments</literal> array:
<programlisting>
strict $.track.segments[*].location
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    在严格的(strict)模式中，指定的路径必须与查询的JSON文档的结构完全匹配才能返回SQL/JSON项，因此使用该路径表达式会导致错误。
	要得到与不严格的(lax)模式相同的结果，你必须显式地打开<literal>segments</literal>数组:
<programlisting>
strict $.track.segments[*].location
</programlisting>
   </para>

   </sect3>

   <sect3 id="functions-sqljson-path-operators">
<!--==========================orignal english content==========================
   <title>SQL/JSON Path Operators and Methods</title>
____________________________________________________________________________-->
   <title>SQL/JSON 路径操作符和方法</title>

<!--==========================orignal english content==========================
   <para>
    <xref linkend="functions-sqljson-op-table"/> shows the operators and
    methods available in <type>jsonpath</type>.  Note that while the unary
    operators and methods can be applied to multiple values resulting from a
    preceding path step, the binary operators (addition etc.) can only be
    applied to single values.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-sqljson-op-table"/>显示了jsonpath中可用的操作符和方法。
	请注意，虽然一元操作符和方法可以应用于由前一个路径步骤产生的多个值，二元操作符(加法等)只能应用于单个值。
   </para>

   <table id="functions-sqljson-op-table">
<!--==========================orignal english content==========================
    <title><type>jsonpath</type> Operators and Methods</title>
____________________________________________________________________________-->
    <title><type>jsonpath</type> 操作符和方法</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Operator/Method
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        操作符/方法
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>+</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Addition
       </para>
       <para>
        <literal>jsonb_path_query('[2]', '$[0] + 3')</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>+</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        加法
       </para>
       <para>
        <literal>jsonb_path_query('[2]', '$[0] + 3')</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>+</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Unary plus (no operation); unlike addition, this can iterate over
        multiple values
       </para>
       <para>
        <literal>jsonb_path_query_array('{"x": [2,3,4]}', '+ $.x')</literal>
        <returnvalue>[2, 3, 4]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>+</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        一元加号(无操作);与加法不同，这个可以迭代多个值
       </para>
       <para>
        <literal>jsonb_path_query_array('{"x": [2,3,4]}', '+ $.x')</literal>
        <returnvalue>[2, 3, 4]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>-</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Subtraction
       </para>
       <para>
        <literal>jsonb_path_query('[2]', '7 - $[0]')</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>-</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        减法
       </para>
       <para>
        <literal>jsonb_path_query('[2]', '7 - $[0]')</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>-</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Negation; unlike subtraction, this can iterate over
        multiple values
       </para>
       <para>
        <literal>jsonb_path_query_array('{"x": [2,3,4]}', '- $.x')</literal>
        <returnvalue>[-2, -3, -4]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>-</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        否定;与减法不同，它可以迭代多个值
       </para>
       <para>
        <literal>jsonb_path_query_array('{"x": [2,3,4]}', '- $.x')</literal>
        <returnvalue>[-2, -3, -4]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>*</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Multiplication
       </para>
       <para>
        <literal>jsonb_path_query('[4]', '2 * $[0]')</literal>
        <returnvalue>8</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>*</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        乘法
       </para>
       <para>
        <literal>jsonb_path_query('[4]', '2 * $[0]')</literal>
        <returnvalue>8</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>/</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Division
       </para>
       <para>
        <literal>jsonb_path_query('[8.5]', '$[0] / 2')</literal>
        <returnvalue>4.2500000000000000</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>/</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        除法
       </para>
       <para>
        <literal>jsonb_path_query('[8.5]', '$[0] / 2')</literal>
        <returnvalue>4.2500000000000000</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>%</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Modulo (remainder)
       </para>
       <para>
        <literal>jsonb_path_query('[32]', '$[0] % 10')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>%</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        模数 (余数)
       </para>
       <para>
        <literal>jsonb_path_query('[32]', '$[0] % 10')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>.</literal> <literal>type()</literal>
        <returnvalue><replaceable>string</replaceable></returnvalue>
       </para>
       <para>
        Type of the JSON item (see <function>json_typeof</function>)
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, "2", {}]', '$[*].type()')</literal>
        <returnvalue>["number", "string", "object"]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>.</literal> <literal>type()</literal>
        <returnvalue><replaceable>string</replaceable></returnvalue>
       </para>
       <para>
        JSON项的类型 (参见 <function>json_typeof</function>)
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, "2", {}]', '$[*].type()')</literal>
        <returnvalue>["number", "string", "object"]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>.</literal> <literal>size()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Size of the JSON item (number of array elements, or 1 if not an
        array)
       </para>
       <para>
        <literal>jsonb_path_query('{"m": [11, 15]}', '$.m.size()')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>.</literal> <literal>size()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        JSON项的大小(数组元素的数量，如果不是数组则为1)
       </para>
       <para>
        <literal>jsonb_path_query('{"m": [11, 15]}', '$.m.size()')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>.</literal> <literal>double()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Approximate floating-point number converted from a JSON number or
        string
       </para>
       <para>
        <literal>jsonb_path_query('{"len": "1.9"}', '$.len.double() * 2')</literal>
        <returnvalue>3.8</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>.</literal> <literal>double()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        从JSON数字或字符串转换过来的近似浮点数
       </para>
       <para>
        <literal>jsonb_path_query('{"len": "1.9"}', '$.len.double() * 2')</literal>
        <returnvalue>3.8</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>.</literal> <literal>ceiling()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Nearest integer greater than or equal to the given number
       </para>
       <para>
        <literal>jsonb_path_query('{"h": 1.3}', '$.h.ceiling()')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>.</literal> <literal>ceiling()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        大于或等于给定数字的最接近的整数
       </para>
       <para>
        <literal>jsonb_path_query('{"h": 1.3}', '$.h.ceiling()')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>.</literal> <literal>floor()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Nearest integer less than or equal to the given number
       </para>
       <para>
        <literal>jsonb_path_query('{"h": 1.7}', '$.h.floor()')</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>.</literal> <literal>floor()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        小于或等于给定数字的最近整数
       </para>
       <para>
        <literal>jsonb_path_query('{"h": 1.7}', '$.h.floor()')</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>.</literal> <literal>abs()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Absolute value of the given number
       </para>
       <para>
        <literal>jsonb_path_query('{"z": -0.3}', '$.z.abs()')</literal>
        <returnvalue>0.3</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>.</literal> <literal>abs()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        给定数字的绝对值
       </para>
       <para>
        <literal>jsonb_path_query('{"z": -0.3}', '$.z.abs()')</literal>
        <returnvalue>0.3</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>string</replaceable> <literal>.</literal> <literal>datetime()</literal>
        <returnvalue><replaceable>datetime_type</replaceable></returnvalue>
        (see note)
       </para>
       <para>
        Date/time value converted from a string
       </para>
       <para>
        <literal>jsonb_path_query('["2015-8-1", "2015-08-12"]', '$[*] ? (@.datetime() &lt; "2015-08-2".datetime())')</literal>
        <returnvalue>"2015-8-1"</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>string</replaceable> <literal>.</literal> <literal>datetime()</literal>
        <returnvalue><replaceable>datetime_type</replaceable></returnvalue>
        (see note)
       </para>
       <para>
        从字符串转换过来的日期/时间值
       </para>
       <para>
        <literal>jsonb_path_query('["2015-8-1", "2015-08-12"]', '$[*] ? (@.datetime() &lt; "2015-08-2".datetime())')</literal>
        <returnvalue>"2015-8-1"</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>string</replaceable> <literal>.</literal> <literal>datetime(<replaceable>template</replaceable>)</literal>
        <returnvalue><replaceable>datetime_type</replaceable></returnvalue>
        (see note)
       </para>
       <para>
        Date/time value converted from a string using the
        specified <function>to_timestamp</function> template
       </para>
       <para>
        <literal>jsonb_path_query_array('["12:30", "18:40"]', '$[*].datetime("HH24:MI")')</literal>
        <returnvalue>["12:30:00", "18:40:00"]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>string</replaceable> <literal>.</literal> <literal>datetime(<replaceable>template</replaceable>)</literal>
        <returnvalue><replaceable>datetime_type</replaceable></returnvalue>
        (see note)
       </para>
       <para>
        使用指定的<function>to_timestamp</function>模板从字符串转换过来的日期/时间值
       </para>
       <para>
        <literal>jsonb_path_query_array('["12:30", "18:40"]', '$[*].datetime("HH24:MI")')</literal>
        <returnvalue>["12:30:00", "18:40:00"]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>object</replaceable> <literal>.</literal> <literal>keyvalue()</literal>
        <returnvalue><replaceable>array</replaceable></returnvalue>
       </para>
       <para>
        The object's key-value pairs, represented as an array of objects
        containing three fields: <literal>"key"</literal>,
        <literal>"value"</literal>, and <literal>"id"</literal>;
        <literal>"id"</literal> is a unique identifier of the object the
        key-value pair belongs to
       </para>
       <para>
        <literal>jsonb_path_query_array('{"x": "20", "y": 32}', '$.keyvalue()')</literal>
        <returnvalue>[{"id": 0, "key": "x", "value": "20"}, {"id": 0, "key": "y", "value": 32}]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>object</replaceable> <literal>.</literal> <literal>keyvalue()</literal>
        <returnvalue><replaceable>array</replaceable></returnvalue>
       </para>
       <para>
        对象的键值对，表示为包含三个字段的对象数组:<literal>"key"</literal>， <literal>"value"</literal>，和<literal>"id"</literal>;<literal>"id"</literal>是键值对所归属对象的唯一标识符
       </para>
       <para>
        <literal>jsonb_path_query_array('{"x": "20", "y": 32}', '$.keyvalue()')</literal>
        <returnvalue>[{"id": 0, "key": "x", "value": "20"}, {"id": 0, "key": "y", "value": 32}]</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

    <note>
<!--==========================orignal english content==========================
     <para>
      The result type of the <literal>datetime()</literal> and
      <literal>datetime(<replaceable>template</replaceable>)</literal>
      methods can be <type>date</type>, <type>timetz</type>, <type>time</type>,
      <type>timestamptz</type>, or <type>timestamp</type>.
      Both methods determine their result type dynamically.
     </para>
____________________________________________________________________________-->
     <para>
      <literal>datetime()</literal> 和<literal>datetime(<replaceable>template</replaceable>)</literal>方法的结果类型可以是<type>date</type>, <type>timetz</type>, <type>time</type>,<type>timestamptz</type>, 或 <type>timestamp</type>。
      这两个方法都动态地确定它们的结果类型。
     </para>
<!--==========================orignal english content==========================
     <para>
      The <literal>datetime()</literal> method sequentially tries to
      match its input string to the ISO formats
      for <type>date</type>, <type>timetz</type>, <type>time</type>,
      <type>timestamptz</type>, and <type>timestamp</type>. It stops on
      the first matching format and emits the corresponding data type.
     </para>
____________________________________________________________________________-->
     <para>
      <literal>datetime()</literal>方法依次尝试将其输入字符串与<type>date</type>, <type>timetz</type>, <type>time</type>,<type>timestamptz</type>, 和 <type>timestamp</type>的ISO格式进行匹配。
      它在第一个匹配格式时停止，并发出相应的数据类型。
     </para>
<!--==========================orignal english content==========================
     <para>
      The <literal>datetime(<replaceable>template</replaceable>)</literal>
      method determines the result type according to the fields used in the
      provided template string.
     </para>
____________________________________________________________________________-->
     <para>
      <literal>datetime(<replaceable>template</replaceable>)</literal>方法根据所提供的模板字符串中使用的字段确定结果类型。
     </para>
<!--==========================orignal english content==========================
     <para>
      The <literal>datetime()</literal> and
      <literal>datetime(<replaceable>template</replaceable>)</literal> methods
      use the same parsing rules as the <literal>to_timestamp</literal> SQL
      function does (see <xref linkend="functions-formatting"/>), with three
      exceptions.  First, these methods don't allow unmatched template
      patterns.  Second, only the following separators are allowed in the
      template string: minus sign, period, solidus (slash), comma, apostrophe,
      semicolon, colon and space.  Third, separators in the template string
      must exactly match the input string.
     </para>
____________________________________________________________________________-->
     <para>
      <literal>datetime()</literal>和<literal>datetime(<replaceable>template</replaceable>)</literal>方法使用与<literal>to_timestamp</literal> SQL函数相同的解析规则(see <xref linkend="functions-formatting"/>)，但有三个例外。
      首先，这些方法不允许不匹配的模板模式。
      其次，模板字符串中只允许以下分隔符:减号、句点、solidus(斜杠)、逗号、撇号、分号、冒号和空格。
      第三，模板字符串中的分隔符必须与输入字符串完全匹配。
     </para>
<!--==========================orignal english content==========================
     <para>
      If different date/time types need to be compared, an implicit cast is
      applied. A <type>date</type> value can be cast to <type>timestamp</type>
      or <type>timestamptz</type>, <type>timestamp</type> can be cast to
      <type>timestamptz</type>, and <type>time</type> to <type>timetz</type>.
      However, all but the first of these conversions depend on the current
      <xref linkend="guc-timezone"/> setting, and thus can only be performed
      within timezone-aware <type>jsonpath</type> functions.
     </para>
____________________________________________________________________________-->
     <para>
      如果需要比较不同的日期/时间类型，则应用隐式转换。
      <type>date</type>值可以转换为<type>timestamp</type>或 <type>timestamptz</type>, <type>timestamp</type>可以转换为<type>timestamptz</type>, <type>time</type>可以转换为<type>timetz</type>。
      但是，除了第一个转换外，其他所有转换都依赖于当前<xref linkend="guc-timezone"/>设置，因此只能在时区感知的<type>jsonpath</type>函数中执行。
     </para>
    </note>

<!--==========================orignal english content==========================
   <para>
    <xref linkend="functions-sqljson-filter-ex-table"/> shows the available
    filter expression elements.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-sqljson-filter-ex-table"/>显示了适用的过滤器表达式元素。
   </para>

   <table id="functions-sqljson-filter-ex-table">
<!--==========================orignal english content==========================
    <title><type>jsonpath</type> Filter Expression Elements</title>
____________________________________________________________________________-->
    <title><type>jsonpath</type> 过滤器表达式元素</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Predicate/Value
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        谓词/值
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>==</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Equality comparison (this, and the other comparison operators, work on
        all JSON scalar values)
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, "a", 1, 3]', '$[*] ? (@ == 1)')</literal>
        <returnvalue>[1, 1]</returnvalue>
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, "a", 1, 3]', '$[*] ? (@ == "a")')</literal>
        <returnvalue>["a"]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>==</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        相等比较(这个，和其他比较操作符，适用于所有JSON标量值)
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, "a", 1, 3]', '$[*] ? (@ == 1)')</literal>
        <returnvalue>[1, 1]</returnvalue>
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, "a", 1, 3]', '$[*] ? (@ == "a")')</literal>
        <returnvalue>["a"]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>!=</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <replaceable>value</replaceable> <literal>&lt;&gt;</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Non-equality comparison
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, 2, 1, 3]', '$[*] ? (@ != 1)')</literal>
        <returnvalue>[2, 3]</returnvalue>
       </para>
       <para>
        <literal>jsonb_path_query_array('["a", "b", "c"]', '$[*] ? (@ &lt;&gt; "b")')</literal>
        <returnvalue>["a", "c"]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>!=</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <replaceable>value</replaceable> <literal>&lt;&gt;</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        不相等比较
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, 2, 1, 3]', '$[*] ? (@ != 1)')</literal>
        <returnvalue>[2, 3]</returnvalue>
       </para>
       <para>
        <literal>jsonb_path_query_array('["a", "b", "c"]', '$[*] ? (@ &lt;&gt; "b")')</literal>
        <returnvalue>["a", "c"]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>&lt;</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Less-than comparison
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, 2, 3]', '$[*] ? (@ &lt; 2)')</literal>
        <returnvalue>[1]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>&lt;</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        小于比较
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, 2, 3]', '$[*] ? (@ &lt; 2)')</literal>
        <returnvalue>[1]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>&lt;=</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Less-than-or-equal-to comparison
       </para>
       <para>
        <literal>jsonb_path_query_array('["a", "b", "c"]', '$[*] ? (@ &lt;= "b")')</literal>
        <returnvalue>["a", "b"]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>&lt;=</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        小于或等于比较
       </para>
       <para>
        <literal>jsonb_path_query_array('["a", "b", "c"]', '$[*] ? (@ &lt;= "b")')</literal>
        <returnvalue>["a", "b"]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>&gt;</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Greater-than comparison
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, 2, 3]', '$[*] ? (@ &gt; 2)')</literal>
        <returnvalue>[3]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>&gt;</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        大于比较
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, 2, 3]', '$[*] ? (@ &gt; 2)')</literal>
        <returnvalue>[3]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>&gt;=</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Greater-than-or-equal-to comparison
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, 2, 3]', '$[*] ? (@ &gt;= 2)')</literal>
        <returnvalue>[2, 3]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>&gt;=</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        大于或等于比较
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, 2, 3]', '$[*] ? (@ &gt;= 2)')</literal>
        <returnvalue>[2, 3]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>true</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        JSON constant <literal>true</literal>
       </para>
       <para>
        <literal>jsonb_path_query('[{"name": "John", "parent": false}, {"name": "Chris", "parent": true}]', '$[*] ? (@.parent == true)')</literal>
        <returnvalue>{"name": "Chris", "parent": true}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>true</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        JSON常数 <literal>真</literal>
       </para>
       <para>
        <literal>jsonb_path_query('[{"name": "John", "parent": false}, {"name": "Chris", "parent": true}]', '$[*] ? (@.parent == true)')</literal>
        <returnvalue>{"name": "Chris", "parent": true}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>false</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        JSON constant <literal>false</literal>
       </para>
       <para>
        <literal>jsonb_path_query('[{"name": "John", "parent": false}, {"name": "Chris", "parent": true}]', '$[*] ? (@.parent == false)')</literal>
        <returnvalue>{"name": "John", "parent": false}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>false</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        JSON常数 <literal>假</literal>
       </para>
       <para>
        <literal>jsonb_path_query('[{"name": "John", "parent": false}, {"name": "Chris", "parent": true}]', '$[*] ? (@.parent == false)')</literal>
        <returnvalue>{"name": "John", "parent": false}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>null</literal>
        <returnvalue><replaceable>value</replaceable></returnvalue>
       </para>
       <para>
        JSON constant <literal>null</literal> (note that, unlike in SQL,
        comparison to <literal>null</literal> works normally)
       </para>
       <para>
        <literal>jsonb_path_query('[{"name": "Mary", "job": null}, {"name": "Michael", "job": "driver"}]', '$[*] ? (@.job == null) .name')</literal>
        <returnvalue>"Mary"</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>null</literal>
        <returnvalue><replaceable>value</replaceable></returnvalue>
       </para>
       <para>
        JSON常数<literal>null</literal>(注意，与SQL不同，与<literal>null</literal>比较可以正常工作)
       </para>
       <para>
        <literal>jsonb_path_query('[{"name": "Mary", "job": null}, {"name": "Michael", "job": "driver"}]', '$[*] ? (@.job == null) .name')</literal>
        <returnvalue>"Mary"</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>boolean</replaceable> <literal>&amp;&amp;</literal> <replaceable>boolean</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Boolean AND
       </para>
       <para>
        <literal>jsonb_path_query('[1, 3, 7]', '$[*] ? (@ &gt; 1 &amp;&amp; @ &lt; 5)')</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>boolean</replaceable> <literal>&amp;&amp;</literal> <replaceable>boolean</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        布尔 AND
       </para>
       <para>
        <literal>jsonb_path_query('[1, 3, 7]', '$[*] ? (@ &gt; 1 &amp;&amp; @ &lt; 5)')</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>boolean</replaceable> <literal>||</literal> <replaceable>boolean</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Boolean OR
       </para>
       <para>
        <literal>jsonb_path_query('[1, 3, 7]', '$[*] ? (@ &lt; 1 || @ &gt; 5)')</literal>
        <returnvalue>7</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>boolean</replaceable> <literal>||</literal> <replaceable>boolean</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        布尔 OR
       </para>
       <para>
        <literal>jsonb_path_query('[1, 3, 7]', '$[*] ? (@ &lt; 1 || @ &gt; 5)')</literal>
        <returnvalue>7</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>!</literal> <replaceable>boolean</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Boolean NOT
       </para>
       <para>
        <literal>jsonb_path_query('[1, 3, 7]', '$[*] ? (!(@ &lt; 5))')</literal>
        <returnvalue>7</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>!</literal> <replaceable>boolean</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        布尔 NOT
       </para>
       <para>
        <literal>jsonb_path_query('[1, 3, 7]', '$[*] ? (!(@ &lt; 5))')</literal>
        <returnvalue>7</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>boolean</replaceable> <literal>is unknown</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Tests whether a Boolean condition is <literal>unknown</literal>.
       </para>
       <para>
        <literal>jsonb_path_query('[-1, 2, 7, "foo"]', '$[*] ? ((@ > 0) is unknown)')</literal>
        <returnvalue>"foo"</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>boolean</replaceable> <literal>is unknown</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试布尔条件是否为 <literal>unknown</literal>。
       </para>
       <para>
        <literal>jsonb_path_query('[-1, 2, 7, "foo"]', '$[*] ? ((@ > 0) is unknown)')</literal>
        <returnvalue>"foo"</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>string</replaceable> <literal>like_regex</literal> <replaceable>string</replaceable> <optional> <literal>flag</literal> <replaceable>string</replaceable> </optional>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Tests whether the first operand matches the regular expression
        given by the second operand, optionally with modifications
        described by a string of <literal>flag</literal> characters (see
        <xref linkend="jsonpath-regular-expressions"/>).
       </para>
       <para>
        <literal>jsonb_path_query_array('["abc", "abd", "aBdC", "abdacb", "babc"]', '$[*] ? (@ like_regex "^ab.*c")')</literal>
        <returnvalue>["abc", "abdacb"]</returnvalue>
       </para>
       <para>
        <literal>jsonb_path_query_array('["abc", "abd", "aBdC", "abdacb", "babc"]', '$[*] ? (@ like_regex "^ab.*c" flag "i")')</literal>
        <returnvalue>["abc", "aBdC", "abdacb"]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>string</replaceable> <literal>like_regex</literal> <replaceable>string</replaceable> <optional> <literal>flag</literal> <replaceable>string</replaceable> </optional>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试第一个操作数是否与第二个操作数给出的正则表达式匹配，可选使用由一串<literal>flag</literal>字符描述的修改(参见<xref linkend="jsonpath-regular-expressions"/>)。
       </para>
       <para>
        <literal>jsonb_path_query_array('["abc", "abd", "aBdC", "abdacb", "babc"]', '$[*] ? (@ like_regex "^ab.*c")')</literal>
        <returnvalue>["abc", "abdacb"]</returnvalue>
       </para>
       <para>
        <literal>jsonb_path_query_array('["abc", "abd", "aBdC", "abdacb", "babc"]', '$[*] ? (@ like_regex "^ab.*c" flag "i")')</literal>
        <returnvalue>["abc", "aBdC", "abdacb"]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>string</replaceable> <literal>starts with</literal> <replaceable>string</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Tests whether the second operand is an initial substring of the first
        operand.
       </para>
       <para>
        <literal>jsonb_path_query('["John Smith", "Mary Stone", "Bob Johnson"]', '$[*] ? (@ starts with "John")')</literal>
        <returnvalue>"John Smith"</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>string</replaceable> <literal>starts with</literal> <replaceable>string</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试第二个操作数是否为第一个操作数的初始子串。
       </para>
       <para>
        <literal>jsonb_path_query('["John Smith", "Mary Stone", "Bob Johnson"]', '$[*] ? (@ starts with "John")')</literal>
        <returnvalue>"John Smith"</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>exists</literal> <literal>(</literal> <replaceable>path_expression</replaceable> <literal>)</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Tests whether a path expression matches at least one SQL/JSON item.
        Returns <literal>unknown</literal> if the path expression would result
        in an error; the second example uses this to avoid a no-such-key error
        in strict mode.
       </para>
       <para>
        <literal>jsonb_path_query('{"x": [1, 2], "y": [2, 4]}', 'strict $.* ? (exists (@ ? (@[*] &gt; 2)))')</literal>
        <returnvalue>[2, 4]</returnvalue>
       </para>
       <para>
        <literal>jsonb_path_query_array('{"value": 41}', 'strict $ ? (exists (@.name)) .name')</literal>
        <returnvalue>[]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>exists</literal> <literal>(</literal> <replaceable>path_expression</replaceable> <literal>)</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试路径表达式是否至少匹配一个SQL/JSON项。
        如果路径表达式会导致错误，则返回<literal>unknown</literal>;第二个例子使用这个方法来避免在严格模式下出现无此键(no-such-key)错误。
       </para>
       <para>
        <literal>jsonb_path_query('{"x": [1, 2], "y": [2, 4]}', 'strict $.* ? (exists (@ ? (@[*] &gt; 2)))')</literal>
        <returnvalue>[2, 4]</returnvalue>
       </para>
       <para>
        <literal>jsonb_path_query_array('{"value": 41}', 'strict $ ? (exists (@.name)) .name')</literal>
        <returnvalue>[]</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   </sect3>

   <sect3 id="jsonpath-regular-expressions">
<!--==========================orignal english content==========================
    <title>SQL/JSON Regular Expressions</title>
____________________________________________________________________________-->
    <title>SQL/JSON 正则表达式</title>

<!--==========================orignal english content==========================
    <indexterm zone="jsonpath-regular-expressions">
     <primary><literal>LIKE_REGEX</literal></primary>
     <secondary>in SQL/JSON</secondary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm zone="jsonpath-regular-expressions">
     <primary><literal>LIKE_REGEX</literal></primary>
     <secondary>in SQL/JSON</secondary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     SQL/JSON path expressions allow matching text to a regular expression
     with the <literal>like_regex</literal> filter.  For example, the
     following SQL/JSON path query would case-insensitively match all
     strings in an array that start with an English vowel:
<programlisting>
$[*] ? (@ like_regex "^[aeiou]" flag "i")
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     SQL/JSON路径表达式允许通过<literal>like_regex</literal>过滤器将文本匹配为正则表达式。
     例如，下面的SQL/JSON路径查询将不区分大小写地匹配以英语元音开头的数组中的所有字符串:
<programlisting>
$[*] ? (@ like_regex "^[aeiou]" flag "i")
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     The optional <literal>flag</literal> string may include one or more of
     the characters
     <literal>i</literal> for case-insensitive match,
     <literal>m</literal> to allow <literal>^</literal>
     and <literal>$</literal> to match at newlines,
     <literal>s</literal> to allow <literal>.</literal> to match a newline,
     and <literal>q</literal> to quote the whole pattern (reducing the
     behavior to a simple substring match).
    </para>
____________________________________________________________________________-->
    <para>
     可选的<literal>flag</literal>字符串可以包括一个或多个字符<literal>i</literal>用于不区分大小写的匹配，<literal>m</literal>允许<literal>^</literal>和<literal>$</literal>在换行时匹配，<literal>s</literal>允许<literal>.</literal>匹配换行符，<literal>q</literal>引用整个模式(将行为简化为一个简单的子字符串匹配)。
    </para>

<!--==========================orignal english content==========================
    <para>
     The SQL/JSON standard borrows its definition for regular expressions
     from the <literal>LIKE_REGEX</literal> operator, which in turn uses the
     XQuery standard.  PostgreSQL does not currently support the
     <literal>LIKE_REGEX</literal> operator.  Therefore,
     the <literal>like_regex</literal> filter is implemented using the
     POSIX regular expression engine described in
     <xref linkend="functions-posix-regexp"/>.  This leads to various minor
     discrepancies from standard SQL/JSON behavior, which are cataloged in
     <xref linkend="posix-vs-xquery"/>.
     Note, however, that the flag-letter incompatibilities described there
     do not apply to SQL/JSON, as it translates the XQuery flag letters to
     match what the POSIX engine expects.
    </para>
____________________________________________________________________________-->
    <para>
     SQL/JSON标准借用了来自<literal>LIKE_REGEX</literal>操作符的正则表达式定义，其使用了XQuery标准。
     PostgreSQL目前不支持<literal>LIKE_REGEX</literal>操作符。因此，<literal>like_regex</literal>过滤器是使用<xref linkend="functions-posix-regexp"/>中描述的POSIX正则表达式引擎来实现的。
     这导致了与标准SQL/JSON行为的各种细微差异，这在<xref linkend="posix-vs-xquery"/>中进行了分类。
     但是请注意，这里描述的标志字母不兼容并不适用于SQL/JSON，因为它将XQuery标志字母翻译为符合POSIX引擎的预期。
    </para>

<!--==========================orignal english content==========================
    <para>
     Keep in mind that the pattern argument of <literal>like_regex</literal>
     is a JSON path string literal, written according to the rules given in
     <xref linkend="datatype-jsonpath"/>.  This means in particular that any
     backslashes you want to use in the regular expression must be doubled.
     For example, to match strings that contain only digits:
<programlisting>
$ ? (@ like_regex "^\\d+$")
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     请记住，<literal>like_regex</literal>的模式参数是一个JSON路径字符串文字，根据<xref linkend="datatype-jsonpath"/>给出的规则编写。
     这特别意味着在正则表达式中要使用的任何反斜杠都必须加倍。例如，匹配只包含数字的字符串:
<programlisting>
$ ? (@ like_regex "^\\d+$")
</programlisting>
    </para>
   </sect3>
  </sect2>
 </sect1>

 <sect1 id="functions-sequence">
<!--==========================orignal english content==========================
  <title>Sequence Manipulation Functions</title>
____________________________________________________________________________-->
  <title>序列操作函数</title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>sequence</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>sequence</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   This section describes functions for operating on <firstterm>sequence
   objects</firstterm>, also called sequence generators or just sequences.
   Sequence objects are special single-row tables created with <xref
   linkend="sql-createsequence"/>.
   Sequence objects are commonly used to generate unique identifiers
   for rows of a table.  The sequence functions, listed in <xref
   linkend="functions-sequence-table"/>, provide simple, multiuser-safe
   methods for obtaining successive sequence values from sequence
   objects.
  </para>
____________________________________________________________________________-->
  <para>
   本节描述对<firstterm>sequence objects</firstterm>进行操作的函数，也称为序列生成器或序列。
   序列对象是使用<xref linkend="sql-createsequence"/>创建的特殊单行表。
   序列对象通常用于为表中的行生成惟一标识符。在<xref linkend="functions-sequence-table"/>中列出的序列函数，提供了简单的、多用户安全方法，用于从序列对象中获取连续的序列值。
  </para>

   <table id="functions-sequence-table">
<!--==========================orignal english content==========================
    <title>Sequence Functions</title>
____________________________________________________________________________-->
    <title>序列函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>nextval</primary>
        </indexterm>
        <function>nextval</function> ( <type>regclass</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Advances the sequence object to its next value and returns that value.
        This is done atomically: even if multiple sessions
        execute <function>nextval</function> concurrently, each will safely
        receive a distinct sequence value.
        If the sequence object has been created with default parameters,
        successive <function>nextval</function> calls will return successive
        values beginning with 1.  Other behaviors can be obtained by using
        appropriate parameters in the <xref linkend="sql-createsequence"/>
        command.
      </para>
       <para>
        This function requires <literal>USAGE</literal>
        or <literal>UPDATE</literal> privilege on the sequence.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>nextval</primary>
        </indexterm>
        <function>nextval</function> ( <type>regclass</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        将序列对象推进到下一个值并返回该值。这是自动完成的:即使多个会话并发地执行<function>nextval</function>，每个会话也会安全地接收到不同的序列值。
        如果序列对象是用默认形参创建的，则连续的<function>nextval</function>调用将返回以1开始的连续值。
        其他行为可以通过在<xref linkend="sql-createsequence"/>命令中使用适当的参数获得。
      </para>
       <para>
        这个函数需要<literal>USAGE</literal>或<literal>UPDATE</literal>特权在序列上。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>setval</primary>
        </indexterm>
        <function>setval</function> ( <type>regclass</type>, <type>bigint</type> <optional>, <type>boolean</type> </optional> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Sets the sequence object's current value, and optionally
        its <literal>is_called</literal> flag.  The two-parameter
        form sets the sequence's <literal>last_value</literal> field to the
        specified value and sets its <literal>is_called</literal> field to
        <literal>true</literal>, meaning that the next
        <function>nextval</function> will advance the sequence before
        returning a value.  The value that will be reported
        by <function>currval</function> is also set to the specified value.
        In the three-parameter form, <literal>is_called</literal> can be set
        to either <literal>true</literal>
        or <literal>false</literal>.  <literal>true</literal> has the same
        effect as the two-parameter form. If it is set
        to <literal>false</literal>, the next <function>nextval</function>
        will return exactly the specified value, and sequence advancement
        commences with the following <function>nextval</function>.
        Furthermore, the value reported by <function>currval</function> is not
        changed in this case.  For example,
<programlisting>
SELECT setval('myseq', 42);           <lineannotation>Next <function>nextval</function> will return 43</lineannotation>
SELECT setval('myseq', 42, true);     <lineannotation>Same as above</lineannotation>
SELECT setval('myseq', 42, false);    <lineannotation>Next <function>nextval</function> will return 42</lineannotation>
</programlisting>
        The result returned by <function>setval</function> is just the value of its
        second argument.
       </para>
       <para>
        This function requires <literal>UPDATE</literal> privilege on the
        sequence.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>setval</primary>
        </indexterm>
        <function>setval</function> ( <type>regclass</type>, <type>bigint</type> <optional>, <type>boolean</type> </optional> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        设置序列对象的当前值，以及可选的它的<literal>is_called</literal>标志。
        双参数形式将序列的<literal>last_value</literal>字段设置为指定的值，并将其<literal>is_called</literal>字段设置为<literal>true</literal>，意味着下一个<function>nextval</function>将在返回值之前推进序列。
        <function>currval</function>将报告的值也设置为指定的值。在三参数形式中，<literal>is_called</literal>可以设置为<literal>true</literal> 或 <literal>false</literal>。
        <literal>true</literal>与双参数形式具有相同的效果。
        如果设置为<literal>false</literal>，下一个<function>nextval</function>将返回指定的值，序列推进从下面的<function>nextval</function>开始。
        而且，<function>currval</function>报告的值在这种情况下不会改变。例如,
<programlisting>
SELECT setval('myseq', 42);           <lineannotation>Next <function>nextval</function> will return 43</lineannotation>
SELECT setval('myseq', 42, true);     <lineannotation>Same as above</lineannotation>
SELECT setval('myseq', 42, false);    <lineannotation>Next <function>nextval</function> will return 42</lineannotation>
</programlisting>
        <function>setval</function>返回的结果就是它的第二个参数的值。
       </para>
       <para>
        这个函数在序列上需要<literal>UPDATE</literal>特权。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>currval</primary>
        </indexterm>
        <function>currval</function> ( <type>regclass</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Returns the value most recently obtained
        by <function>nextval</function> for this sequence in the current
        session.  (An error is reported if <function>nextval</function> has
        never been called for this sequence in this session.)  Because this is
        returning a session-local value, it gives a predictable answer whether
        or not other sessions have executed <function>nextval</function> since
        the current session did.
       </para>
       <para>
        This function requires <literal>USAGE</literal>
        or <literal>SELECT</literal> privilege on the sequence.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>currval</primary>
        </indexterm>
        <function>currval</function> ( <type>regclass</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        返回<function>nextval</function>在当前会话中为该序列最近获取的值。(如果在这个会话中没有为这个序列调用<function>nextval</function>会报告错误。)
        因为它返回的是一个会话本地值，所以它给出了一个可预测的答案，即自当前会话以来，其他会话是否执行了<function>nextval</function>。
       </para>
       <para>
        这个函数需要序列上的<literal>USAGE</literal> 或 <literal>SELECT</literal>特权。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lastval</primary>
        </indexterm>
        <function>lastval</function> ()
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Returns the value most recently returned by
        <function>nextval</function> in the current session. This function is
        identical to <function>currval</function>, except that instead
        of taking the sequence name as an argument it refers to whichever
        sequence <function>nextval</function> was most recently applied to
        in the current session. It is an error to call
        <function>lastval</function> if <function>nextval</function>
        has not yet been called in the current session.
       </para>
       <para>
        This function requires <literal>USAGE</literal>
        or <literal>SELECT</literal> privilege on the last used sequence.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lastval</primary>
        </indexterm>
        <function>lastval</function> ()
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        返回<function>nextval</function>在当前会话中最近返回的值。这个函数与<function>currval</function>相同，不同之处在于它没有使用序列名作为参数，而是引用当前会话中<function>nextval</function>最近应用到的序列。
        如果在当前会话中还没有调用<function>nextval</function>，那么调用<function>lastval</function>是一个错误。
       </para>
       <para>
        该函数在最后使用的序列上需要<literal>USAGE</literal>或<literal>SELECT</literal>特权。
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <caution>
<!--==========================orignal english content==========================
   <para>
    To avoid blocking concurrent transactions that obtain numbers from
    the same sequence, a <function>nextval</function> operation is never
    rolled back; that is, once a value has been fetched it is considered
    used and will not be returned again.  This is true even if the
    surrounding transaction later aborts, or if the calling query ends
    up not using the value.  For example an <command>INSERT</command> with
    an <literal>ON CONFLICT</literal> clause will compute the to-be-inserted
    tuple, including doing any required <function>nextval</function>
    calls, before detecting any conflict that would cause it to follow
    the <literal>ON CONFLICT</literal> rule instead.  Such cases will leave
    unused <quote>holes</quote> in the sequence of assigned values.
    Thus, <productname>PostgreSQL</productname> sequence
    objects <emphasis>cannot be used to obtain <quote>gapless</quote>
    sequences</emphasis>.
   </para>
____________________________________________________________________________-->
   <para>
    为了避免阻塞从相同序列中获取数字的并发事务，<function>nextval</function>操作永远不会回滚;也就是说，一旦获取了一个值，它就会被认为是已使用的，并且不会再次返回。
    即使周围的事务随后中止，或者调用查询最终没有使用该值，也会出现这种情况。
    例如，带有<literal>ON CONFLICT</literal>子句的<command>INSERT</command>将计算要插入的元组，包括执行任何必需的<function>nextval</function>调用，在检测到任何可能导致它遵循<literal>ON CONFLICT</literal>规则的冲突之前。
    这种情况会在赋值序列中留下未使用的<quote>holes</quote>。因此，<productname>PostgreSQL</productname>序列对象<emphasis>不能被用于获取 <quote>gapless</quote> 序列</emphasis>。
   </para>

<!--==========================orignal english content==========================
   <para>
    Likewise, any sequence state changes made by <function>setval</function>
    are not undone if the transaction rolls back.
   </para>
____________________________________________________________________________-->
   <para>
    同样的，如果事务回滚，<function>setval</function>所做的任何序列状态更改都不会撤消。
   </para>
  </caution>

<!--==========================orignal english content==========================
  <para>
   The sequence to be operated on by a sequence function is specified by
   a <type>regclass</type> argument, which is simply the OID of the sequence in the
   <structname>pg_class</structname> system catalog.  You do not have to look up the
   OID by hand, however, since the <type>regclass</type> data type's input
   converter will do the work for you.  Just write the sequence name enclosed
   in single quotes so that it looks like a literal constant.  For
   compatibility with the handling of ordinary
   <acronym>SQL</acronym> names, the string will be converted to lower case
   unless it contains double quotes around the sequence name.  Thus:
<programlisting>
nextval('foo')      <lineannotation>operates on sequence <literal>foo</literal></lineannotation>
nextval('FOO')      <lineannotation>operates on sequence <literal>foo</literal></lineannotation>
nextval('"Foo"')    <lineannotation>operates on sequence <literal>Foo</literal></lineannotation>
</programlisting>
   The sequence name can be schema-qualified if necessary:
<programlisting>
nextval('myschema.foo')     <lineannotation>operates on <literal>myschema.foo</literal></lineannotation>
nextval('"myschema".foo')   <lineannotation>same as above</lineannotation>
nextval('foo')              <lineannotation>searches search path for <literal>foo</literal></lineannotation>
</programlisting>
   See <xref linkend="datatype-oid"/> for more information about
   <type>regclass</type>.
  </para>
____________________________________________________________________________-->
  <para>
   序列函数所要操作的序列由<type>regclass</type>参数指定，该参数只是<structname>pg_class</structname>系统目录中序列的OID。
   你不必手工查找OID，不过，因为<type>regclass</type>数据类型的输入转换器将为您完成这项工作。
   只需将序列名用单引号括起来，这样它看起来就像一个文字常量。
   为了与处理普通<acronym>SQL</acronym>名称兼容，字符串将被转换为小写，除非它在序列名称周围包含双引号。因此:
<programlisting>
nextval('foo')      <lineannotation>序列上操作 <literal>foo</literal></lineannotation>
nextval('FOO')      <lineannotation>序列上操作 <literal>foo</literal></lineannotation>
nextval('"Foo"')    <lineannotation>序列上操作 <literal>Foo</literal></lineannotation>
</programlisting>
   如需要，序列名称可以是模式限定的:
<programlisting>
nextval('myschema.foo')     <lineannotation>操作 <literal>myschema.foo</literal></lineannotation>
nextval('"myschema".foo')   <lineannotation>同上</lineannotation>
nextval('foo')              <lineannotation>在搜索路径中查找 <literal>foo</literal></lineannotation>
</programlisting>
   关于<type>regclass</type>的更多信息请参见<xref linkend="datatype-oid"/>。
  </para>

  <note>
<!--==========================orignal english content==========================
   <para>
    Before <productname>PostgreSQL</productname> 8.1, the arguments of the
    sequence functions were of type <type>text</type>, not <type>regclass</type>, and
    the above-described conversion from a text string to an OID value would
    happen at run time during each call.  For backward compatibility, this
    facility still exists, but internally it is now handled as an implicit
    coercion from <type>text</type> to <type>regclass</type> before the function is
    invoked.
   </para>
____________________________________________________________________________-->
   <para>
    在<productname>PostgreSQL</productname> 8.1 之前，序列函数的参数类型是<type>text</type>， 而不是 <type>regclass</type>，并且前文所述的从文本串到 OID 值的转换将在每次调用的时候发生。 
    为了向后兼容，这个处理仍然存在，但是在内部实际上是通过在函数调用前隐式地将<type>text</type>转换成<type>regclass</type>实现的。
   </para>

<!--==========================orignal english content==========================
   <para>
    When you write the argument of a sequence function as an unadorned
    literal string, it becomes a constant of type <type>regclass</type>.
    Since this is really just an OID, it will track the originally
    identified sequence despite later renaming, schema reassignment,
    etc.  This <quote>early binding</quote> behavior is usually desirable for
    sequence references in column defaults and views.  But sometimes you might
    want <quote>late binding</quote> where the sequence reference is resolved
    at run time.  To get late-binding behavior, force the constant to be
    stored as a <type>text</type> constant instead of <type>regclass</type>:
<programlisting>
nextval('foo'::text)      <lineannotation><literal>foo</literal> is looked up at runtime</lineannotation>
</programlisting>
    Note that late binding was the only behavior supported in
    <productname>PostgreSQL</productname> releases before 8.1, so you
    might need to do this to preserve the semantics of old applications.
   </para>
____________________________________________________________________________-->
   <para>
    当你把一个序列函数的参数写成一个无修饰的文字串，那么它将变成类型为<type>regclass</type>的常量。
    因为这只是一个 OID，它将跟踪最初标识的序列，而不管后面是否改名、模式变化等等。 
    这种<quote>早期绑定</quote>的行为通常是列默认值和视图中引用的序列所需要的。 
    但是有时候你可能想要<quote>延迟绑定</quote>，其中序列的引用是在运行时解析的。
    要得到延迟绑定的行为，我们可以强制常量被存储为<type>text</type>常量，而不是<type>regclass</type>：
<programlisting>
nextval('foo'::text)      <lineannotation><literal>foo</literal> is looked up at runtime</lineannotation>
</programlisting>
    请注意，延迟绑定是<productname>PostgreSQL</productname>版本 8.1 之前唯一被支持的行为， 因此你可能需要做这些来保留旧应用的语义。
   </para>

<!--==========================orignal english content==========================
   <para>
    Of course, the argument of a sequence function can be an expression
    as well as a constant.  If it is a text expression then the implicit
    coercion will result in a run-time lookup.
   </para>
____________________________________________________________________________-->
   <para>
    当然，序列函数的参数也可以是表达式。如果它是一个文本表达式，那么隐式的转换将导致运行时的查找。
   </para>
  </note>

 </sect1>

 <sect1 id="functions-conditional">
<!--==========================orignal english content==========================
  <title>Conditional Expressions</title>
____________________________________________________________________________-->
  <title>条件表达式</title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>CASE</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>CASE</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>conditional expression</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>条件表达式</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   This section describes the <acronym>SQL</acronym>-compliant conditional expressions
   available in <productname>PostgreSQL</productname>.
  </para>
____________________________________________________________________________-->
  <para>
   本节描述在<productname>PostgreSQL</productname>中可用的<acronym>SQL</acronym>兼容的条件表达式。
  </para>

  <tip>
<!--==========================orignal english content==========================
   <para>
    If your needs go beyond the capabilities of these conditional
    expressions, you might want to consider writing a server-side function
    in a more expressive programming language.
   </para>
____________________________________________________________________________-->
   <para>
    如果你的需求超过这些条件表达式的能力，你可能会希望用一种更富表现力的编程语言写一个服务器端函数。
   </para>
  </tip>

   <note>
<!--==========================orignal english content==========================
    <para>
     Although <token>COALESCE</token>, <token>GREATEST</token>, and
     <token>LEAST</token> are syntactically similar to functions, they are
     not ordinary functions, and thus cannot be used with explicit
     <token>VARIADIC</token> array arguments.
    </para>
____________________________________________________________________________-->
    <para>
     尽管<token>COALESCE</token>、<token>GREATEST</token>和<token>LEAST</token>在语法上类似于函数，但它们不是普通的函数，因此不能使用显式<token>VARIADIC</token>数组参数。
    </para>
   </note>

  <sect2 id="functions-case">
<!--==========================orignal english content==========================
   <title><literal>CASE</literal></title>
____________________________________________________________________________-->
   <title><literal>CASE</literal></title>

<!--==========================orignal english content==========================
  <para>
   The <acronym>SQL</acronym> <token>CASE</token> expression is a
   generic conditional expression, similar to if/else statements in
   other programming languages:

<synopsis>
CASE WHEN <replaceable>condition</replaceable> THEN <replaceable>result</replaceable>
     <optional>WHEN ...</optional>
     <optional>ELSE <replaceable>result</replaceable></optional>
END
</synopsis>

   <token>CASE</token> clauses can be used wherever
   an expression is valid.  Each <replaceable>condition</replaceable> is an
   expression that returns a <type>boolean</type> result.  If the condition's
   result is true, the value of the <token>CASE</token> expression is the
   <replaceable>result</replaceable> that follows the condition, and the
   remainder of the <token>CASE</token> expression is not processed.  If the
   condition's result is not true, any subsequent <token>WHEN</token> clauses
   are examined in the same manner.  If no <token>WHEN</token>
   <replaceable>condition</replaceable> yields true, the value of the
   <token>CASE</token> expression is the <replaceable>result</replaceable> of the
   <token>ELSE</token> clause.  If the <token>ELSE</token> clause is
   omitted and no condition is true, the result is null.
  </para>
____________________________________________________________________________-->
  <para>
   <acronym>SQL</acronym> <token>CASE</token>表达式是一种通用的条件表达式，类似于其它编程语言中的 if/else 语句：

<synopsis>
CASE WHEN <replaceable>condition</replaceable> THEN <replaceable>result</replaceable>
     <optional>WHEN ...</optional>
     <optional>ELSE <replaceable>result</replaceable></optional>
END
</synopsis>

   <token>CASE</token>子句可以用于任何表达式可以出现的地方。每一个<replaceable>condition</replaceable>是一个返回<type>boolean</type>结果的表达式。如果结果为真，那么<token>CASE</token>表达式的结果就是符合条件的<replaceable>result</replaceable>，并且剩下的<token>CASE</token>表达式不会被处理。如果条件的结果不为真，那么以相同方式搜寻任何随后的<token>WHEN</token>子句。如果没有<token>WHEN</token> <replaceable>condition</replaceable>为真，那么<token>CASE</token>表达式的值就是在<token>ELSE</token>子句里的<replaceable>result</replaceable>。如果省略了<token>ELSE</token>子句而且没有条件为真，结果为空。
  </para>

<!--==========================orignal english content==========================
   <para>
    An example:
<screen>
SELECT * FROM test;

 a
-&minus;-
 1
 2
 3


SELECT a,
       CASE WHEN a=1 THEN 'one'
            WHEN a=2 THEN 'two'
            ELSE 'other'
       END
    FROM test;

 a | case
-&minus;-+-&minus;-&minus;-&minus;-
 1 | one
 2 | two
 3 | other
</screen>
   </para>
____________________________________________________________________________-->
   <para>
    例子：
<screen>
SELECT * FROM test;

 a
---
 1
 2
 3


SELECT a,
       CASE WHEN a=1 THEN 'one'
            WHEN a=2 THEN 'two'
            ELSE 'other'
       END
    FROM test;

 a | case
---+-------
 1 | one
 2 | two
 3 | other
</screen>
   </para>

<!--==========================orignal english content==========================
  <para>
   The data types of all the <replaceable>result</replaceable>
   expressions must be convertible to a single output type.
   See <xref linkend="typeconv-union-case"/> for more details.
  </para>
____________________________________________________________________________-->
  <para>
   所有<replaceable>result</replaceable>表达式的数据类型都必须可以转换成单一的输出类型。 参阅<xref linkend="typeconv-union-case"/>获取细节。
  </para>

<!--==========================orignal english content==========================
  <para>
   There is a <quote>simple</quote> form of <token>CASE</token> expression
   that is a variant of the general form above:

<synopsis>
CASE <replaceable>expression</replaceable>
    WHEN <replaceable>value</replaceable> THEN <replaceable>result</replaceable>
    <optional>WHEN ...</optional>
    <optional>ELSE <replaceable>result</replaceable></optional>
END
</synopsis>

   The first
   <replaceable>expression</replaceable> is computed, then compared to
   each of the <replaceable>value</replaceable> expressions in the
   <token>WHEN</token> clauses until one is found that is equal to it.  If
   no match is found, the <replaceable>result</replaceable> of the
   <token>ELSE</token> clause (or a null value) is returned.  This is similar
   to the <function>switch</function> statement in C.
  </para>
____________________________________________________________________________-->
  <para>
   下面这个<quote>简单</quote>形式的<token>CASE</token>表达式是上述通用形式的一个变种：

<synopsis>
CASE <replaceable>expression</replaceable>
    WHEN <replaceable>value</replaceable> THEN <replaceable>result</replaceable>
    <optional>WHEN ...</optional>
    <optional>ELSE <replaceable>result</replaceable></optional>
END
</synopsis>

   第一个<replaceable>expression</replaceable>会被计算，然后与所有在<token>WHEN</token>子句中的每一个<replaceable>value</replaceable>对比，直到找到一个相等的。如果没有找到匹配的，则返回在<token>ELSE</token>子句中的<replaceable>result</replaceable>（或者控制）。 这类似于 C 里的<function>switch</function>语句。
  </para>

<!--==========================orignal english content==========================
   <para>
    The example above can be written using the simple
    <token>CASE</token> syntax:
<screen>
SELECT a,
       CASE a WHEN 1 THEN 'one'
              WHEN 2 THEN 'two'
              ELSE 'other'
       END
    FROM test;

 a | case
-&minus;-+-&minus;-&minus;-&minus;-
 1 | one
 2 | two
 3 | other
</screen>
   </para>
____________________________________________________________________________-->
   <para>
    上面的例子可以用简单<token>CASE</token>语法来写：
<screen>
SELECT a,
       CASE a WHEN 1 THEN 'one'
              WHEN 2 THEN 'two'
              ELSE 'other'
       END
    FROM test;

 a | case
---+-------
 1 | one
 2 | two
 3 | other
</screen>
   </para>

<!--==========================orignal english content==========================
   <para>
    A <token>CASE</token> expression does not evaluate any subexpressions
    that are not needed to determine the result.  For example, this is a
    possible way of avoiding a division-by-zero failure:
<programlisting>
SELECT ... WHERE CASE WHEN x &lt;&gt; 0 THEN y/x &gt; 1.5 ELSE false END;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    <token>CASE</token>表达式并不计算任何无助于判断结果的子表达式。例如，下面是一个可以避免被零除错误的方法：
<programlisting>
SELECT ... WHERE CASE WHEN x &lt;&gt; 0 THEN y/x &gt; 1.5 ELSE false END;
</programlisting>
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     As described in <xref linkend="syntax-express-eval"/>, there are various
     situations in which subexpressions of an expression are evaluated at
     different times, so that the principle that <quote><token>CASE</token>
     evaluates only necessary subexpressions</quote> is not ironclad.  For
     example a constant <literal>1/0</literal> subexpression will usually result in
     a division-by-zero failure at planning time, even if it's within
     a <token>CASE</token> arm that would never be entered at run time.
    </para>
____________________________________________________________________________-->
    <para>
     如<xref linkend="syntax-express-eval"/>中所述，在有几种情况中一个表达式的子表达式
     会被计算多次，因此<quote><token>CASE</token>只计算必要的表达式</quote>这
     一原则并非不可打破。例如一个常量子表达式<literal>1/0</literal>通常将会在规划时导致一次
     除零错误，即便它位于一个执行时永远也不会进入的<token>CASE</token>分支时也是
     如此。
    </para>
   </note>
  </sect2>

  <sect2 id="functions-coalesce-nvl-ifnull">
<!--==========================orignal english content==========================
   <title><literal>COALESCE</literal></title>
____________________________________________________________________________-->
   <title><literal>COALESCE</literal></title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>COALESCE</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>COALESCE</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>NVL</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>NVL</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>IFNULL</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>IFNULL</primary>
  </indexterm>

<!--==========================orignal english content==========================
<synopsis>
<function>COALESCE</function>(<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
<function>COALESCE</function>(<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>

<!--==========================orignal english content==========================
  <para>
   The <function>COALESCE</function> function returns the first of its
   arguments that is not null.  Null is returned only if all arguments
   are null.  It is often used to substitute a default value for
   null values when data is retrieved for display, for example:
<programlisting>
SELECT COALESCE(description, short_description, '(none)') ...
</programlisting>
   This returns <varname>description</varname> if it is not null, otherwise
   <varname>short_description</varname> if it is not null, otherwise <literal>(none)</literal>.
  </para>
____________________________________________________________________________-->
  <para>
   <function>COALESCE</function>函数返回它的第一个非空参数的值。当且仅当所有参数都为空时才会返回空。它常用于在为显示目的检索数据时用缺省值替换空值。例如：
<programlisting>
SELECT COALESCE(description, short_description, '(none)') ...
</programlisting>
   如果<varname>description</varname>不为空，这将会返回它的值，否则如果<varname>short_description</varname>非空则返回<varname>short_description</varname>的值，如果前两个都为空则返回<literal>(none)</literal>。
  </para>

<!--==========================orignal english content==========================
   <para>
    The arguments must all be convertible to a common data type, which
    will be the type of the result (see
    <xref linkend="typeconv-union-case"/> for details).
   </para>
____________________________________________________________________________-->
   <para>
    所有参数都必须转换为一个公共数据类型，它将是结果的类型 (详请参见 <xref linkend="typeconv-union-case"/> )。
   </para>

<!--==========================orignal english content==========================
   <para>
    Like a <token>CASE</token> expression, <function>COALESCE</function> only
    evaluates the arguments that are needed to determine the result;
    that is, arguments to the right of the first non-null argument are
    not evaluated.  This SQL-standard function provides capabilities similar
    to <function>NVL</function> and <function>IFNULL</function>, which are used in some other
    database systems.
   </para>
____________________________________________________________________________-->
   <para>
    和<token>CASE</token>表达式一样，<function>COALESCE</function>将不会 计算无助于判断结果的参数；也就是说，在第一个非空参数右边的参数不会被计算。这个 SQL 标准函数提供了类似于<function>NVL</function>和<function>IFNULL</function>的能力，它们被用在某些其他数据库系统中。
   </para>
  </sect2>

  <sect2 id="functions-nullif">
<!--==========================orignal english content==========================
   <title><literal>NULLIF</literal></title>
____________________________________________________________________________-->
   <title><literal>NULLIF</literal></title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>NULLIF</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>NULLIF</primary>
  </indexterm>

<!--==========================orignal english content==========================
<synopsis>
<function>NULLIF</function>(<replaceable>value1</replaceable>, <replaceable>value2</replaceable>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
<function>NULLIF</function>(<replaceable>value1</replaceable>, <replaceable>value2</replaceable>)
</synopsis>

<!--==========================orignal english content==========================
  <para>
   The <function>NULLIF</function> function returns a null value if
   <replaceable>value1</replaceable> equals <replaceable>value2</replaceable>;
   otherwise it returns <replaceable>value1</replaceable>.
   This can be used to perform the inverse operation of the
   <function>COALESCE</function> example given above:
<programlisting>
SELECT NULLIF(value, '(none)') ...
</programlisting>
   In this example, if <literal>value</literal> is <literal>(none)</literal>,
   null is returned, otherwise the value of <literal>value</literal>
   is returned.
  </para>
____________________________________________________________________________-->
  <para>
   当<replaceable>value1</replaceable>和<replaceable>value2</replaceable>相等时，<function>NULLIF</function>返回一个空值。 
   否则它返回<replaceable>value1</replaceable>。 这些可以用于执行前文给出的<function>COALESCE</function>例子的逆操作：
<programlisting>
SELECT NULLIF(value, '(none)') ...
</programlisting>
   在这个例子中，如果<literal>value</literal>是<literal>(none)</literal>，将返回空值，否则返回<literal>value</literal>的值。
  </para>

<!--==========================orignal english content==========================
  <para>
   The two arguments must be of comparable types.
   To be specific, they are compared exactly as if you had
   written <literal><replaceable>value1</replaceable>
   = <replaceable>value2</replaceable></literal>, so there must be a
   suitable <literal>=</literal> operator available.
  </para>
____________________________________________________________________________-->
  <para>
   这两个参数必须具有可比较的类型。具体来说，它们的比较与你写的 <literal><replaceable>value1</replaceable> = <replaceable>value2</replaceable></literal>完全一样，因此必须有一个合适的<literal>=</literal>操作符可用。
  </para>

<!--==========================orignal english content==========================
  <para>
   The result has the same type as the first argument &mdash; but there is
   a subtlety.  What is actually returned is the first argument of the
   implied <literal>=</literal> operator, and in some cases that will have
   been promoted to match the second argument's type.  For
   example, <literal>NULLIF(1, 2.2)</literal> yields <type>numeric</type>,
   because there is no <type>integer</type> <literal>=</literal>
   <type>numeric</type> operator,
   only <type>numeric</type> <literal>=</literal> <type>numeric</type>.
  </para>
____________________________________________________________________________-->
  <para>
   结果的类型与第一个参数相同，但有一点细微的区别。实际上返回的是隐含 <literal>=</literal>操作符的第一个参数，在某些情况下，它将被提升以匹配第二个参数的类型。
   例如，<literal>NULLIF(1, 2.2)</literal> 生成 <type>numeric</type>，因为没有<type>integer</type> <literal>=</literal> <type>numeric</type>操作符，只有<type>numeric</type> <literal>=</literal> <type>numeric</type>。
  </para>

  </sect2>

  <sect2 id="functions-greatest-least">
<!--==========================orignal english content==========================
   <title><literal>GREATEST</literal> and <literal>LEAST</literal></title>
____________________________________________________________________________-->
   <title><literal>GREATEST</literal>和<literal>LEAST</literal></title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>GREATEST</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>GREATEST</primary>
  </indexterm>
<!--==========================orignal english content==========================
  <indexterm>
   <primary>LEAST</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>LEAST</primary>
  </indexterm>

<!--==========================orignal english content==========================
<synopsis>
<function>GREATEST</function>(<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
<function>GREATEST</function>(<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>
<!--==========================orignal english content==========================
<synopsis>
<function>LEAST</function>(<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
<function>LEAST</function>(<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>

<!--==========================orignal english content==========================
   <para>
    The <function>GREATEST</function> and <function>LEAST</function> functions select the
    largest or smallest value from a list of any number of expressions.
    The expressions must all be convertible to a common data type, which
    will be the type of the result
    (see <xref linkend="typeconv-union-case"/> for details).  NULL values
    in the list are ignored.  The result will be NULL only if all the
    expressions evaluate to NULL.
   </para>
____________________________________________________________________________-->
   <para>
    <function>GREATEST</function>和<function>LEAST</function>函数从一个任意的数字表达式列表里选取最大或者最小的数值。 这些表达式必须都可以转换成一个普通的数据类型，它将会是结果类型 （参阅<xref linkend="typeconv-union-case"/>获取细节）。列表中的 NULL 数值将被忽略。只有所有表达式的结果都是 NULL 的时候，结果才会是 NULL。
   </para>

<!--==========================orignal english content==========================
   <para>
    Note that <function>GREATEST</function> and <function>LEAST</function> are not in
    the SQL standard, but are a common extension.  Some other databases
    make them return NULL if any argument is NULL, rather than only when
    all are NULL.
   </para>
____________________________________________________________________________-->
   <para>
    请注意<function>GREATEST</function>和<function>LEAST</function>都不是 SQL 标准，但却是很常见的扩展。某些其他数据库让它们在任何参数为 NULL 时返回 NULL，而不是在所有参数都为 NULL 时才返回 NULL。
   </para>
  </sect2>
 </sect1>

 <sect1 id="functions-array">
<!--==========================orignal english content==========================
  <title>Array Functions and Operators</title>
____________________________________________________________________________-->
  <title>数组函数和操作符</title>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="array-operators-table"/> shows the specialized operators
   available for array types.
   In addition to those, the usual comparison operators shown in <xref
   linkend="functions-comparison-op-table"/> are available for
   arrays.  The comparison operators compare the array contents
   element-by-element, using the default B-tree comparison function for
   the element data type, and sort based on the first difference.
   In multidimensional arrays the elements are visited in row-major order
   (last subscript varies most rapidly).
   If the contents of two arrays are equal but the dimensionality is
   different, the first difference in the dimensionality information
   determines the sort order.  (This is a change from versions of
   <productname>PostgreSQL</productname> prior to 8.2: older versions would claim
   that two arrays with the same contents were equal, even if the
   number of dimensions or subscript ranges were different.)
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="array-operators-table"/>显示了可以用于数组类型的专用的操作符。
   除此之外，<xref linkend="functions-comparison-op-table"/>中所示的常用比较运算符也适用于数组。
   比较操作符逐个元素的比较数组内容，使用默认的元素数据类型的B-tree比较函数，并根据第一个差值进行排序。
   多维数组的元素按照行序进行访问（最后的下标变化最快）。
   如果两个数组的内容相同但维数不等，那么维度信息中的第一个不同将决定排序顺序（这是对<productname>PostgreSQL</productname> 8.2 之前版本的修改： 老版本认为内容相同的两个数组相等，即使它们的维数或下标范围并不相同）。
  </para>

   <table id="array-operators-table">
<!--==========================orignal english content==========================
    <title>Array Operators</title>
____________________________________________________________________________-->
    <title>数组操作符</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Operator
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        操作符
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyarray</type> <literal>@&gt;</literal> <type>anyarray</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does the first array contain the second, that is, does each element
        appearing in the second array equal some element of the first array?
        (Duplicates are not treated specially,
        thus <literal>ARRAY[1]</literal> and <literal>ARRAY[1,1]</literal> are
        each considered to contain the other.)
       </para>
       <para>
        <literal>ARRAY[1,4,3] @&gt; ARRAY[3,1,3]</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyarray</type> <literal>@&gt;</literal> <type>anyarray</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个数组是否包含第二个数组，也就是说，出现在第二个数组中的每个元素是否等于第一个数组中的某个元素?
        (重复值不需要特殊处理，因此<literal>ARRAY[1]</literal> 和 <literal>ARRAY[1,1]</literal>被认为包含对方。)
       </para>
       <para>
        <literal>ARRAY[1,4,3] @&gt; ARRAY[3,1,3]</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyarray</type> <literal>&lt;@</literal> <type>anyarray</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the first array contained by the second?
       </para>
       <para>
        <literal>ARRAY[2,2,7] &lt;@ ARRAY[1,7,4,2,6]</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyarray</type> <literal>&lt;@</literal> <type>anyarray</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个数组包含在第二个数组中么?
       </para>
       <para>
        <literal>ARRAY[2,2,7] &lt;@ ARRAY[1,7,4,2,6]</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyarray</type> <literal>&amp;&amp;</literal> <type>anyarray</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Do the arrays overlap, that is, have any elements in common?
       </para>
       <para>
        <literal>ARRAY[1,4,3] &amp;&amp; ARRAY[2,1]</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyarray</type> <literal>&amp;&amp;</literal> <type>anyarray</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        这些数组有重叠么，也就是说，它们有共同的元素么?
       </para>
       <para>
        <literal>ARRAY[1,4,3] &amp;&amp; ARRAY[2,1]</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyarray</type> <literal>||</literal> <type>anyarray</type>
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        Concatenates the two arrays.  Concatenating a null or empty array is a
        no-op; otherwise the arrays must have the same number of dimensions
        (as illustrated by the first example) or differ in number of
        dimensions by one (as illustrated by the second).
       </para>
       <para>
        <literal>ARRAY[1,2,3] || ARRAY[4,5,6,7]</literal>
        <returnvalue>{1,2,3,4,5,6,7}</returnvalue>
       </para>
       <para>
        <literal>ARRAY[1,2,3] || ARRAY[[4,5,6],[7,8,9]]</literal>
        <returnvalue>{{1,2,3},{4,5,6},{7,8,9}}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyarray</type> <literal>||</literal> <type>anyarray</type>
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        连接两个数组。连接空(null)或空数组是一个无操作(no-op);否则，数组必须具有相同的维度数(如第一个示例所示)，或者维度数相差一个(如第二个示例所示)。
       </para>
       <para>
        <literal>ARRAY[1,2,3] || ARRAY[4,5,6,7]</literal>
        <returnvalue>{1,2,3,4,5,6,7}</returnvalue>
       </para>
       <para>
        <literal>ARRAY[1,2,3] || ARRAY[[4,5,6],[7,8,9]]</literal>
        <returnvalue>{{1,2,3},{4,5,6},{7,8,9}}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyelement</type> <literal>||</literal> <type>anyarray</type>
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        Concatenates an element onto the front of an array (which must be
        empty or one-dimensional).
       </para>
       <para>
        <literal>3 || ARRAY[4,5,6]</literal>
        <returnvalue>{3,4,5,6}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyelement</type> <literal>||</literal> <type>anyarray</type>
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        将元素连接到数组的前面(数组必须为空或一维的[one-dimensional])。
       </para>
       <para>
        <literal>3 || ARRAY[4,5,6]</literal>
        <returnvalue>{3,4,5,6}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyarray</type> <literal>||</literal> <type>anyelement</type>
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        Concatenates an element onto the end of an array (which must be
        empty or one-dimensional).
       </para>
       <para>
        <literal>ARRAY[4,5,6] || 7</literal>
        <returnvalue>{4,5,6,7}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyarray</type> <literal>||</literal> <type>anyelement</type>
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        将元素连接到数组的末尾(数组必须为空或一维的[one-dimensional])。
       </para>
       <para>
        <literal>ARRAY[4,5,6] || 7</literal>
        <returnvalue>{4,5,6,7}</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
  <para>
   See <xref linkend="arrays"/> for more details about array operator
   behavior.  See <xref linkend="indexes-types"/> for more details about
   which operators support indexed operations.
  </para>
____________________________________________________________________________-->
  <para>
   参阅<xref linkend="arrays"/>获取有关数组操作符行为的更多细节。有关哪些操作符支持被索引的操作，请参阅<xref linkend="indexes-types"/>。
  </para>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="array-functions-table"/> shows the functions
   available for use with array types. See <xref linkend="arrays"/>
   for more information  and examples of the use of these functions.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="array-functions-table"/>展示了可以用于数组类型的函数。 参阅<xref linkend="arrays"/>获取更多信息以及使用这些函数的例子。
  </para>

   <table id="array-functions-table">
<!--==========================orignal english content==========================
    <title>Array Functions</title>
____________________________________________________________________________-->
    <title>数组函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_append</primary>
        </indexterm>
        <function>array_append</function> ( <type>anyarray</type>, <type>anyelement</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        Appends an element to the end of an array (same as
        the <type>anyarray</type> <literal>||</literal> <type>anyelement</type>
        operator).
       </para>
       <para>
        <literal>array_append(ARRAY[1,2], 3)</literal>
        <returnvalue>{1,2,3}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_append</primary>
        </indexterm>
        <function>array_append</function> ( <type>anyarray</type>, <type>anyelement</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        向一个数组的末端追加一个元素 (等同于 <type>anyarray</type> <literal>||</literal> <type>anyelement</type> 操作符)。
       </para>
       <para>
        <literal>array_append(ARRAY[1,2], 3)</literal>
        <returnvalue>{1,2,3}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_cat</primary>
        </indexterm>
        <function>array_cat</function> ( <type>anyarray</type>, <type>anyarray</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        Concatenates two arrays (same as
        the <type>anyarray</type> <literal>||</literal> <type>anyarray</type>
        operator).
       </para>
       <para>
        <literal>array_cat(ARRAY[1,2,3], ARRAY[4,5])</literal>
        <returnvalue>{1,2,3,4,5}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_cat</primary>
        </indexterm>
        <function>array_cat</function> ( <type>anyarray</type>, <type>anyarray</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        连接两个数组(等同于 <type>anyarray</type> <literal>||</literal> <type>anyarray</type> 操作符)。
       </para>
       <para>
        <literal>array_cat(ARRAY[1,2,3], ARRAY[4,5])</literal>
        <returnvalue>{1,2,3,4,5}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_dims</primary>
        </indexterm>
        <function>array_dims</function> ( <type>anyarray</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns a text representation of the array's dimensions.
       </para>
       <para>
        <literal>array_dims(ARRAY[[1,2,3], [4,5,6]])</literal>
        <returnvalue>[1:2][1:3]</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_dims</primary>
        </indexterm>
        <function>array_dims</function> ( <type>anyarray</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回数组维度的文本表示形式。
       </para>
       <para>
        <literal>array_dims(ARRAY[[1,2,3], [4,5,6]])</literal>
        <returnvalue>[1:2][1:3]</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_fill</primary>
        </indexterm>
        <function>array_fill</function> ( <type>anyelement</type>, <type>integer[]</type>
          <optional>, <type>integer[]</type> </optional> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        Returns an array filled with copies of the given value, having
        dimensions of the lengths specified by the second argument.
        The optional third argument supplies lower-bound values for each
        dimension (which default to all <literal>1</literal>).
       </para>
       <para>
        <literal>array_fill(11, ARRAY[2,3])</literal>
        <returnvalue>{{11,11,11},{11,11,11}}</returnvalue>
       </para>
       <para>
        <literal>array_fill(7, ARRAY[3], ARRAY[2])</literal>
        <returnvalue>[2:4]={7,7,7}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_fill</primary>
        </indexterm>
        <function>array_fill</function> ( <type>anyelement</type>, <type>integer[]</type>
          <optional>, <type>integer[]</type> </optional> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        返回一个包含给定值的拷贝的数组，其维数与第二个参数指定的长度相同。
        可选的第三个参数提供每个维度的下界值(默认为全部为 <literal>1</literal>)。
       </para>
       <para>
        <literal>array_fill(11, ARRAY[2,3])</literal>
        <returnvalue>{{11,11,11},{11,11,11}}</returnvalue>
       </para>
       <para>
        <literal>array_fill(7, ARRAY[3], ARRAY[2])</literal>
        <returnvalue>[2:4]={7,7,7}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_length</primary>
        </indexterm>
        <function>array_length</function> ( <type>anyarray</type>, <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the length of the requested array dimension.
       </para>
       <para>
        <literal>array_length(array[1,2,3], 1)</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_length</primary>
        </indexterm>
        <function>array_length</function> ( <type>anyarray</type>, <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回请求的数组维度的长度。
       </para>
       <para>
        <literal>array_length(array[1,2,3], 1)</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_lower</primary>
        </indexterm>
        <function>array_lower</function> ( <type>anyarray</type>, <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the lower bound of the requested array dimension.
       </para>
       <para>
        <literal>array_lower('[0:2]={1,2,3}'::integer[], 1)</literal>
        <returnvalue>0</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_lower</primary>
        </indexterm>
        <function>array_lower</function> ( <type>anyarray</type>, <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回请求的数组维度的下界。
       </para>
       <para>
        <literal>array_lower('[0:2]={1,2,3}'::integer[], 1)</literal>
        <returnvalue>0</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_ndims</primary>
        </indexterm>
        <function>array_ndims</function> ( <type>anyarray</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the number of dimensions of the array.
       </para>
       <para>
        <literal>array_ndims(ARRAY[[1,2,3], [4,5,6]])</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_ndims</primary>
        </indexterm>
        <function>array_ndims</function> ( <type>anyarray</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回数组的维度数。
       </para>
       <para>
        <literal>array_ndims(ARRAY[[1,2,3], [4,5,6]])</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_position</primary>
        </indexterm>
        <function>array_position</function> ( <type>anyarray</type>, <type>anyelement</type> <optional>, <type>integer</type> </optional> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the subscript of the first occurrence of the second argument
        in the array, or <literal>NULL</literal> if it's not present.
        If the third argument is given, the search begins at that subscript.
        The array must be one-dimensional.
        Comparisons are done using <literal>IS NOT DISTINCT FROM</literal>
        semantics, so it is possible to search for <literal>NULL</literal>.
       </para>
       <para>
        <literal>array_position(ARRAY['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'], 'mon')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_position</primary>
        </indexterm>
        <function>array_position</function> ( <type>anyarray</type>, <type>anyelement</type> <optional>, <type>integer</type> </optional> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回阵列中第二个参数中第一次发生的下标，如果它不存在，则返回<literal>NULL</literal>。
        如果给出了第三个参数，则搜索从该下标开始。数组必须是一维的。比较是使用<literal>IS NOT DISTINCT FROM</literal>语义进行的，所以可以搜索<literal>NULL</literal>。
       </para>
       <para>
        <literal>array_position(ARRAY['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'], 'mon')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_positions</primary>
        </indexterm>
        <function>array_positions</function> ( <type>anyarray</type>, <type>anyelement</type> )
        <returnvalue>integer[]</returnvalue>
       </para>
       <para>
        Returns an array of the subscripts of all occurrences of the second
        argument in the array given as first argument.
        The array must be one-dimensional.
        Comparisons are done using <literal>IS NOT DISTINCT FROM</literal>
        semantics, so it is possible to search for <literal>NULL</literal>.
        <literal>NULL</literal> is returned only if the array
        is <literal>NULL</literal>; if the value is not found in the array, an
        empty array is returned.
       </para>
       <para>
        <literal>array_positions(ARRAY['A','A','B','A'], 'A')</literal>
        <returnvalue>{1,2,4}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_positions</primary>
        </indexterm>
        <function>array_positions</function> ( <type>anyarray</type>, <type>anyelement</type> )
        <returnvalue>integer[]</returnvalue>
       </para>
       <para>
        返回作为第一个参数的数组中第二个参数所有出现的下标的数组。
        数组必须是一维的。使用<literal>IS NOT DISTINCT FROM</literal>语义完成比较，所以可以搜索<literal>NULL</literal>。
        只有当数组为<literal>NULL</literal>时才返回<literal>NULL</literal>;如果在数组中没有找到该值，则返回空数组。
       </para>
       <para>
        <literal>array_positions(ARRAY['A','A','B','A'], 'A')</literal>
        <returnvalue>{1,2,4}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_prepend</primary>
        </indexterm>
        <function>array_prepend</function> ( <type>anyelement</type>, <type>anyarray</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        Prepends an element to the beginning of an array (same as
        the <type>anyelement</type> <literal>||</literal> <type>anyarray</type>
        operator).
       </para>
       <para>
        <literal>array_prepend(1, ARRAY[2,3])</literal>
        <returnvalue>{1,2,3}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_prepend</primary>
        </indexterm>
        <function>array_prepend</function> ( <type>anyelement</type>, <type>anyarray</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        在数组的开头添加一个元素(等同于<type>anyelement</type> <literal>||</literal> <type>anyarray</type>操作符)。
       </para>
       <para>
        <literal>array_prepend(1, ARRAY[2,3])</literal>
        <returnvalue>{1,2,3}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_remove</primary>
        </indexterm>
        <function>array_remove</function> ( <type>anyarray</type>, <type>anyelement</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        Removes all elements equal to the given value from the array.
        The array must be one-dimensional.
        Comparisons are done using <literal>IS NOT DISTINCT FROM</literal>
        semantics, so it is possible to remove <literal>NULL</literal>s.
       </para>
       <para>
        <literal>array_remove(ARRAY[1,2,3,2], 2)</literal>
        <returnvalue>{1,3}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_remove</primary>
        </indexterm>
        <function>array_remove</function> ( <type>anyarray</type>, <type>anyelement</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        从数组中移除与给定值相等的所有元素。数组必须是一维的。使用<literal>IS NOT DISTINCT FROM</literal>语义完成比较，所以可以删除<literal>NULL</literal>。
       </para>
       <para>
        <literal>array_remove(ARRAY[1,2,3,2], 2)</literal>
        <returnvalue>{1,3}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_replace</primary>
        </indexterm>
        <function>array_replace</function> ( <type>anyarray</type>, <type>anyelement</type>, <type>anyelement</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        Replaces each array element equal to the second argument with the
        third argument.
       </para>
       <para>
        <literal>array_replace(ARRAY[1,2,5,4], 5, 3)</literal>
        <returnvalue>{1,2,3,4}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_replace</primary>
        </indexterm>
        <function>array_replace</function> ( <type>anyarray</type>, <type>anyelement</type>, <type>anyelement</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        将等于第二个参数的每个数组元素替换为第三个参数。
       </para>
       <para>
        <literal>array_replace(ARRAY[1,2,5,4], 5, 3)</literal>
        <returnvalue>{1,2,3,4}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_to_string</primary>
        </indexterm>
        <function>array_to_string</function> ( <parameter>array</parameter> <type>anyarray</type>, <parameter>delimiter</parameter> <type>text</type> <optional>, <parameter>null_string</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts each array element to its text representation, and
        concatenates those separated by
        the <parameter>delimiter</parameter> string.
        If <parameter>null_string</parameter> is given and is
        not <literal>NULL</literal>, then <literal>NULL</literal> array
        entries are represented by that string; otherwise, they are omitted.
       </para>
       <para>
        <literal>array_to_string(ARRAY[1, 2, 3, NULL, 5], ',', '*')</literal>
        <returnvalue>1,2,3,*,5</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_to_string</primary>
        </indexterm>
        <function>array_to_string</function> ( <parameter>array</parameter> <type>anyarray</type>, <parameter>delimiter</parameter> <type>text</type> <optional>, <parameter>null_string</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将每个数组元素转换为它的文本表现形式，并连接由<parameter>delimiter</parameter>符字符串分隔的元素。
        如果给出了<parameter>null_string</parameter>且不为<literal>NULL</literal>，则<literal>NULL</literal>数组项由该字符串表示;否则，它们将被省略。
       </para>
       <para>
        <literal>array_to_string(ARRAY[1, 2, 3, NULL, 5], ',', '*')</literal>
        <returnvalue>1,2,3,*,5</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_upper</primary>
        </indexterm>
        <function>array_upper</function> ( <type>anyarray</type>, <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the upper bound of the requested array dimension.
       </para>
       <para>
        <literal>array_upper(ARRAY[1,8,3,7], 1)</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_upper</primary>
        </indexterm>
        <function>array_upper</function> ( <type>anyarray</type>, <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回请求的数组维度的上界。
       </para>
       <para>
        <literal>array_upper(ARRAY[1,8,3,7], 1)</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cardinality</primary>
        </indexterm>
        <function>cardinality</function> ( <type>anyarray</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the total number of elements in the array, or 0 if the array
        is empty.
       </para>
       <para>
        <literal>cardinality(ARRAY[[1,2],[3,4]])</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cardinality</primary>
        </indexterm>
        <function>cardinality</function> ( <type>anyarray</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回数组中元素的总数，如果数组为空则返回0。
       </para>
       <para>
        <literal>cardinality(ARRAY[[1,2],[3,4]])</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>string_to_array</primary>
        </indexterm>
        <function>string_to_array</function> ( <parameter>string</parameter> <type>text</type>, <parameter>delimiter</parameter> <type>text</type> <optional>, <parameter>null_string</parameter> <type>text</type> </optional> )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
        Splits the <parameter>string</parameter> at occurrences
        of <parameter>delimiter</parameter> and forms the remaining data
        into a <type>text</type> array.
        If <parameter>delimiter</parameter> is <literal>NULL</literal>,
        each character in the <parameter>string</parameter> will become a
        separate element in the array.
        If <parameter>delimiter</parameter> is an empty string, then
        the <parameter>string</parameter> is treated as a single field.
        If <parameter>null_string</parameter> is supplied and is
        not <literal>NULL</literal>, fields matching that string are converted
        to <literal>NULL</literal> entries.
       </para>
       <para>
        <literal>string_to_array('xx~~yy~~zz', '~~', 'yy')</literal>
        <returnvalue>{xx,NULL,zz}</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>string_to_array</primary>
        </indexterm>
        <function>string_to_array</function> ( <parameter>string</parameter> <type>text</type>, <parameter>delimiter</parameter> <type>text</type> <optional>, <parameter>null_string</parameter> <type>text</type> </optional> )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
        在出现<parameter>分隔符</parameter>时拆分<parameter>字符串</parameter>，并将剩余数据形成<type>文本</type>数组。
        如果<parameter>分隔符</parameter>为<literal>NULL</literal>，则<parameter>字符串</parameter>中的每个字符将成为数组中的单独元素。
        如果<parameter>分隔符</parameter>为空字符串，则该<parameter>字符串</parameter>视为单个字段。
        如果提供了<parameter>null_string</parameter>且不为<literal>NULL</literal>，那么匹配该字符串的字段将被转换为<literal>NULL</literal>项。
       </para>
       <para>
        <literal>string_to_array('xx~~yy~~zz', '~~', 'yy')</literal>
        <returnvalue>{xx,NULL,zz}</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>unnest</primary>
        </indexterm>
        <function>unnest</function> ( <type>anyarray</type> )
        <returnvalue>setof anyelement</returnvalue>
       </para>
       <para>
        Expands an array to a set of rows.
       </para>
       <para>
        <literal>unnest(ARRAY[1,2])</literal>
        <returnvalue></returnvalue>
<programlisting>
 1
 2
</programlisting>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>unnest</primary>
        </indexterm>
        <function>unnest</function> ( <type>anyarray</type> )
        <returnvalue>setof anyelement</returnvalue>
       </para>
       <para>
        将数组展开为一组行。
       </para>
       <para>
        <literal>unnest(ARRAY[1,2])</literal>
        <returnvalue></returnvalue>
<programlisting>
 1
 2
</programlisting>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>unnest</function> ( <type>anyarray</type>, <type>anyarray</type> <optional>, ... </optional> )
        <returnvalue>setof anyelement, anyelement [, ... ]</returnvalue>
       </para>
       <para>
        Expands multiple arrays (possibly of different data types) to a set of
        rows.  If the arrays are not all the same length then the shorter ones
        are padded with <literal>NULL</literal>s.  This is only allowed in a
        query's FROM clause; see <xref linkend="queries-tablefunctions"/>.
       </para>
       <para>
        <literal>select * from unnest(ARRAY[1,2], ARRAY['foo','bar','baz']) as x(a,b)</literal>
        <returnvalue></returnvalue>
<programlisting>
 a |  b
-&minus;-+-&minus;-&minus;-
 1 | foo
 2 | bar
   | baz
</programlisting>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>unnest</function> ( <type>anyarray</type>, <type>anyarray</type> <optional>, ... </optional> )
        <returnvalue>setof anyelement, anyelement [, ... ]</returnvalue>
       </para>
       <para>
        将多个数组(可能是不同的数据类型)展开为一组行。
        如果数组的长度不完全相同，那么较短的数组将用<literal>NULL</literal>填充。
        这只在查询的FROM子句中允许;参见<xref linkend="queries-tablefunctions"/>。
       </para>
       <para>
        <literal>select * from unnest(ARRAY[1,2], ARRAY['foo','bar','baz']) as x(a,b)</literal>
        <returnvalue></returnvalue>
<programlisting>
 a |  b
---+-----
 1 | foo
 2 | bar
   | baz
</programlisting>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <note>
<!--==========================orignal english content==========================
    <para>
     There are two differences in the behavior of <function>string_to_array</function>
     from pre-9.1 versions of <productname>PostgreSQL</productname>.
     First, it will return an empty (zero-element) array rather
     than <literal>NULL</literal> when the input string is of zero length.
     Second, if the delimiter string is <literal>NULL</literal>, the function
     splits the input into individual characters, rather than
     returning <literal>NULL</literal> as before.
    </para>
____________________________________________________________________________-->
    <para>
     <function>string_to_array</function>的行为中有两点与<productname>PostgreSQL</productname> 9.1之前的版本不同。
     首先，当输入串的长度为零时，它将返回一个空（无元素）数组而不是 <literal>NULL</literal>。
     其次，如果定界符串为 <literal>NULL</literal>，该函数会将输入划分成独立字符，而不是像以前那样返回 <literal>NULL</literal>。
    </para>
   </note>

<!--==========================orignal english content==========================
   <para>
    See also <xref linkend="functions-aggregate"/> about the aggregate
    function <function>array_agg</function> for use with arrays.
   </para>
____________________________________________________________________________-->
   <para>
    也可参见<xref linkend="functions-aggregate"/>了解用于数组的聚集函数<function>array_agg</function>。
   </para>
  </sect1>

 <sect1 id="functions-range">
<!--==========================orignal english content==========================
  <title>Range Functions and Operators</title>
____________________________________________________________________________-->
  <title>范围函数和运算符</title>

<!--==========================orignal english content==========================
  <para>
   See <xref linkend="rangetypes"/> for an overview of range types.
  </para>
____________________________________________________________________________-->
  <para>
   范围类型的概述可参见 <xref linkend="rangetypes"/> 。
  </para>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="range-operators-table"/> shows the specialized operators
   available for range types.
   In addition to those, the usual comparison operators shown in
   <xref linkend="functions-comparison-op-table"/> are available for range
   types.  The comparison operators order first by the range lower bounds, and
   only if those are equal do they compare the upper bounds.  This does not
   usually result in a useful overall ordering, but the operators are provided
   to allow unique indexes to be constructed on ranges.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="range-operators-table"/>显示了范围类型的专用操作符。除此之外，<xref linkend="functions-comparison-op-table"/>中所示的常用比较操作符也适用于范围类型。
   比较操作符首先按范围下界排序，只有当它们相等时才比较上界。
   这通常不会导致有用的总体排序，但提供的操作符允许在范围上构造惟一索引。
  </para>

   <table id="range-operators-table">
<!--==========================orignal english content==========================
    <title>Range Operators</title>
____________________________________________________________________________-->
    <title>范围操作符</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Operator
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        操作符
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>@&gt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does the first range contain the second?
       </para>
       <para>
        <literal>int4range(2,4) @&gt; int4range(2,3)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>@&gt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个范围中包含第二个(范围)吗?
       </para>
       <para>
        <literal>int4range(2,4) @&gt; int4range(2,3)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>@&gt;</literal> <type>anyelement</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does the range contain the element?
       </para>
       <para>
        <literal>'[2011-01-01,2011-03-01)'::tsrange @&gt; '2011-01-10'::timestamp</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>@&gt;</literal> <type>anyelement</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        范围是否包含元素?
       </para>
       <para>
        <literal>'[2011-01-01,2011-03-01)'::tsrange @&gt; '2011-01-10'::timestamp</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&lt;@</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the first range contained by the second?
       </para>
       <para>
        <literal>int4range(2,4) &lt;@ int4range(1,7)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&lt;@</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个范围包含在第二个(范围)中吗?
       </para>
       <para>
        <literal>int4range(2,4) &lt;@ int4range(1,7)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyelement</type> <literal>&lt;@</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the element contained in the range?
       </para>
       <para>
        <literal>42 &lt;@ int4range(1,7)</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyelement</type> <literal>&lt;@</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        元素是否包含在范围内?
       </para>
       <para>
        <literal>42 &lt;@ int4range(1,7)</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&amp;&amp;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Do the ranges overlap, that is, have any elements in common?
       </para>
       <para>
        <literal>int8range(3,7) &amp;&amp; int8range(4,12)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&amp;&amp;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        范围是否重叠，也就是说，是否有相同的元素?
       </para>
       <para>
        <literal>int8range(3,7) &amp;&amp; int8range(4,12)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&lt;&lt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the first range strictly left of the second?
       </para>
       <para>
        <literal>int8range(1,10) &lt;&lt; int8range(100,110)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&lt;&lt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个范围是否严格地在第二个(范围)的左侧?
       </para>
       <para>
        <literal>int8range(1,10) &lt;&lt; int8range(100,110)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&gt;&gt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the first range strictly right of the second?
       </para>
       <para>
        <literal>int8range(50,60) &gt;&gt; int8range(20,30)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&gt;&gt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个范围是否严格符合第二个(范围)?
       </para>
       <para>
        <literal>int8range(50,60) &gt;&gt; int8range(20,30)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&amp;&lt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does the first range not extend to the right of the second?
       </para>
       <para>
        <literal>int8range(1,20) &amp;&lt; int8range(18,20)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&amp;&lt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个范围是否没有扩展到第二个(范围)的右侧?
       </para>
       <para>
        <literal>int8range(1,20) &amp;&lt; int8range(18,20)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&amp;&gt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does the first range not extend to the left of the second?
       </para>
       <para>
        <literal>int8range(7,20) &amp;&gt; int8range(5,10)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&amp;&gt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        第一个范围是否没有扩展到第二个(范围)的左侧?
       </para>
       <para>
        <literal>int8range(7,20) &amp;&gt; int8range(5,10)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>-|-</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Are the ranges adjacent?
       </para>
       <para>
        <literal>numrange(1.1,2.2) -|- numrange(2.2,3.3)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>-|-</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        范围是相邻的么？
       </para>
       <para>
        <literal>numrange(1.1,2.2) -|- numrange(2.2,3.3)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>+</literal> <type>anyrange</type>
        <returnvalue>anyrange</returnvalue>
       </para>
       <para>
        Computes the union of the ranges.  The ranges must overlap or be
        adjacent, so that the union is a single range (but
        see <function>range_merge()</function>).
       </para>
       <para>
        <literal>numrange(5,15) + numrange(10,20)</literal>
        <returnvalue>[5,20)</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>+</literal> <type>anyrange</type>
        <returnvalue>anyrange</returnvalue>
       </para>
       <para>
        计算范围的并集。范围必须重叠或相邻，这样的并集就是一个单一的范围(请参见<function>range_merge()</function>)。
       </para>
       <para>
        <literal>numrange(5,15) + numrange(10,20)</literal>
        <returnvalue>[5,20)</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>*</literal> <type>anyrange</type>
        <returnvalue>anyrange</returnvalue>
       </para>
       <para>
        Computes the intersection of the ranges.
       </para>
       <para>
        <literal>int8range(5,15) * int8range(10,20)</literal>
        <returnvalue>[10,15)</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>*</literal> <type>anyrange</type>
        <returnvalue>anyrange</returnvalue>
       </para>
       <para>
        计算范围的交集。
       </para>
       <para>
        <literal>int8range(5,15) * int8range(10,20)</literal>
        <returnvalue>[10,15)</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>-</literal> <type>anyrange</type>
        <returnvalue>anyrange</returnvalue>
       </para>
       <para>
        Computes the difference of the ranges.  The second range must not be
        contained in the first in such a way that the difference would not be
        a single range.
       </para>
       <para>
        <literal>int8range(5,15) - int8range(10,20)</literal>
        <returnvalue>[5,10)</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>-</literal> <type>anyrange</type>
        <returnvalue>anyrange</returnvalue>
       </para>
       <para>
        计算范围的差异。第二个范围必须不能包含在第一个(范围)中，以使差异不是一个单一的范围。
       </para>
       <para>
        <literal>int8range(5,15) - int8range(10,20)</literal>
        <returnvalue>[5,10)</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
  <para>
   The left-of/right-of/adjacent operators always return false when an empty
   range is involved; that is, an empty range is not considered to be either
   before or after any other range.
  </para>
____________________________________________________________________________-->
  <para>
   当涉及一个空范围时，左部/右部/相邻操作符总是返回假；即一个空范围被认为不在任何其他范围前面或者后面。
  </para>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="range-functions-table"/> shows the functions
   available for use with range types.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="range-functions-table"/> 显示可用于范围类型的函数。
  </para>

   <table id="range-functions-table">
<!--==========================orignal english content==========================
    <title>Range Functions</title>
____________________________________________________________________________-->
    <title>范围函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lower</primary>
        </indexterm>
        <function>lower</function> ( <type>anyrange</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        Extracts the lower bound of the range (<literal>NULL</literal> if the
        range is empty or the lower bound is infinite).
       </para>
       <para>
        <literal>lower(numrange(1.1,2.2))</literal>
        <returnvalue>1.1</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lower</primary>
        </indexterm>
        <function>lower</function> ( <type>anyrange</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        提取范围的下界(如果范围为空或下界为无限，则为<literal>NULL</literal>)。
       </para>
       <para>
        <literal>lower(numrange(1.1,2.2))</literal>
        <returnvalue>1.1</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>upper</primary>
        </indexterm>
        <function>upper</function> ( <type>anyrange</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        Extracts the upper bound of the range (<literal>NULL</literal> if the
        range is empty or the upper bound is infinite).
       </para>
       <para>
        <literal>upper(numrange(1.1,2.2))</literal>
        <returnvalue>2.2</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>upper</primary>
        </indexterm>
        <function>upper</function> ( <type>anyrange</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        提取范围的上限(如果范围为空或上限为无限，则为<literal>NULL</literal>)。
       </para>
       <para>
        <literal>upper(numrange(1.1,2.2))</literal>
        <returnvalue>2.2</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>isempty</primary>
        </indexterm>
        <function>isempty</function> ( <type>anyrange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the range empty?
       </para>
       <para>
        <literal>isempty(numrange(1.1,2.2))</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>isempty</primary>
        </indexterm>
        <function>isempty</function> ( <type>anyrange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        范围为空吗?
       </para>
       <para>
        <literal>isempty(numrange(1.1,2.2))</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lower_inc</primary>
        </indexterm>
        <function>lower_inc</function> ( <type>anyrange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the range's lower bound inclusive?
       </para>
       <para>
        <literal>lower_inc(numrange(1.1,2.2))</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lower_inc</primary>
        </indexterm>
        <function>lower_inc</function> ( <type>anyrange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        范围的下界是否包含在内?
       </para>
       <para>
        <literal>lower_inc(numrange(1.1,2.2))</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>upper_inc</primary>
        </indexterm>
        <function>upper_inc</function> ( <type>anyrange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the range's upper bound inclusive?
       </para>
       <para>
        <literal>upper_inc(numrange(1.1,2.2))</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>upper_inc</primary>
        </indexterm>
        <function>upper_inc</function> ( <type>anyrange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        范围的上界是否包含在内?
       </para>
       <para>
        <literal>upper_inc(numrange(1.1,2.2))</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lower_inf</primary>
        </indexterm>
        <function>lower_inf</function> ( <type>anyrange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the range's lower bound infinite?
       </para>
       <para>
        <literal>lower_inf('(,)'::daterange)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lower_inf</primary>
        </indexterm>
        <function>lower_inf</function> ( <type>anyrange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        范围的下界是无限的吗?
       </para>
       <para>
        <literal>lower_inf('(,)'::daterange)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>upper_inf</primary>
        </indexterm>
        <function>upper_inf</function> ( <type>anyrange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the range's upper bound infinite?
       </para>
       <para>
        <literal>upper_inf('(,)'::daterange)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>upper_inf</primary>
        </indexterm>
        <function>upper_inf</function> ( <type>anyrange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        范围的上界是无限的吗?
       </para>
       <para>
        <literal>upper_inf('(,)'::daterange)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>range_merge</primary>
        </indexterm>
        <function>range_merge</function> ( <type>anyrange</type>, <type>anyrange</type> )
        <returnvalue>anyrange</returnvalue>
       </para>
       <para>
        Computes the smallest range that includes both of the given ranges.
       </para>
       <para>
        <literal>range_merge('[1,2)'::int4range, '[3,4)'::int4range)</literal>
        <returnvalue>[1,4)</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>range_merge</primary>
        </indexterm>
        <function>range_merge</function> ( <type>anyrange</type>, <type>anyrange</type> )
        <returnvalue>anyrange</returnvalue>
       </para>
       <para>
        计算包含两个给定范围的最小范围。
       </para>
       <para>
        <literal>range_merge('[1,2)'::int4range, '[3,4)'::int4range)</literal>
        <returnvalue>[1,4)</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
  <para>
   The <function>lower_inc</function>, <function>upper_inc</function>,
   <function>lower_inf</function>, and <function>upper_inf</function>
   functions all return false for an empty range.
  </para>
____________________________________________________________________________-->
  <para>
   <function>lower_inc</function>、<function>upper_inc</function>、<function>lower_inf</function>、 和 <function>upper_inf</function> 函数对空范围(empty range)都返回假(false)。
  </para>
  </sect1>

 <sect1 id="functions-aggregate">
<!--==========================orignal english content==========================
  <title>Aggregate Functions</title>
____________________________________________________________________________-->
  <title>聚集函数</title>

<!--==========================orignal english content==========================
  <indexterm zone="functions-aggregate">
   <primary>aggregate function</primary>
   <secondary>built-in</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="functions-aggregate">
   <primary>聚集函数</primary>
   <secondary>内建</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   <firstterm>Aggregate functions</firstterm> compute a single result
   from a set of input values.  The built-in general-purpose aggregate
   functions are listed in <xref linkend="functions-aggregate-table"/>
   while statistical aggregates are in <xref
   linkend="functions-aggregate-statistics-table"/>.
   The built-in within-group ordered-set aggregate functions
   are listed in <xref linkend="functions-orderedset-table"/>
   while the built-in within-group hypothetical-set ones are in <xref
   linkend="functions-hypothetical-table"/>.  Grouping operations,
   which are closely related to aggregate functions, are listed in
   <xref linkend="functions-grouping-table"/>.
   The special syntax considerations for aggregate
   functions are explained in <xref linkend="syntax-aggregates"/>.
   Consult <xref linkend="tutorial-agg"/> for additional introductory
   information.
  </para>
____________________________________________________________________________-->
  <para>
   <firstterm>聚集函数</firstterm>从一个输入值的集合计算出一个单一值。
   内建的通用聚集函数在<xref linkend="functions-aggregate-table"/>中列出，而统计性聚集是在<xref linkend="functions-aggregate-statistics-table"/>中列出。
   内建的组内有序集聚集函数在<xref linkend="functions-orderedset-table"/>中列出，而内建的组内假想集聚集在<xref linkend="functions-hypothetical-table"/>中列出。
   与聚集函数紧密相关的分组操作在<xref linkend="functions-grouping-table"/>中列出。
   <xref linkend="syntax-aggregates"/>中会解释针对聚集函数的特殊语法考虑。额外的介绍信息请参考<xref linkend="tutorial-agg"/>。
  </para>

<!--==========================orignal english content==========================
  <para>
   Aggregate functions that support <firstterm>Partial Mode</firstterm>
   are eligible to participate in various optimizations, such as parallel
   aggregation.
  </para>
____________________________________________________________________________-->
  <para>
   支持<firstterm>部分模式</firstterm>的聚合函数具备参与各种优化的条件，例如并行聚合。
  </para>

   <table id="functions-aggregate-table">
<!--==========================orignal english content==========================
    <title>General-Purpose Aggregate Functions</title>
____________________________________________________________________________-->
    <title>通用聚集函数</title>
    <tgroup cols="2">
     <colspec colname="col1" colwidth="10*"/>
     <colspec colname="col2" colwidth="1*"/>
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
       <entry>Partial Mode</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
       <entry>部分模式</entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_agg</primary>
        </indexterm>
        <function>array_agg</function> ( <type>anynonarray</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        Collects all the input values, including nulls, into an array.
       </para></entry>
       <entry>No</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_agg</primary>
        </indexterm>
        <function>array_agg</function> ( <type>anynonarray</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        将所有输入值，包括空值，收集到一个数组中。
       </para></entry>
       <entry>No</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>array_agg</function> ( <type>anyarray</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        Concatenates all the input arrays into an array of one higher
        dimension.  (The inputs must all have the same dimensionality, and
        cannot be empty or null.)
       </para></entry>
       <entry>No</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>array_agg</function> ( <type>anyarray</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        将所有输入数组连接到一个更高维度的数组中。(输入必须都具有相同的维度，并且不能为空的(empty)或空值(null)。)
       </para></entry>
       <entry>No</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>average</primary>
        </indexterm>
        <indexterm>
         <primary>avg</primary>
        </indexterm>
        <function>avg</function> ( <type>smallint</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>avg</function> ( <type>integer</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>avg</function> ( <type>bigint</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>avg</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>avg</function> ( <type>real</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para role="func_signature">
        <function>avg</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para role="func_signature">
        <function>avg</function> ( <type>interval</type> )
        <returnvalue>interval</returnvalue>
       </para>
       <para>
        Computes the average (arithmetic mean) of all the non-null input
        values.
       </para></entry>
       <entry>Yes</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>average</primary>
        </indexterm>
        <indexterm>
         <primary>avg</primary>
        </indexterm>
        <function>avg</function> ( <type>smallint</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>avg</function> ( <type>integer</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>avg</function> ( <type>bigint</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>avg</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>avg</function> ( <type>real</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para role="func_signature">
        <function>avg</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para role="func_signature">
        <function>avg</function> ( <type>interval</type> )
        <returnvalue>interval</returnvalue>
       </para>
       <para>
        计算所有非空输入值的平均值(算术平均值)。
       </para></entry>
       <entry>Yes</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bit_and</primary>
        </indexterm>
        <function>bit_and</function> ( <type>smallint</type> )
        <returnvalue>smallint</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_and</function> ( <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_and</function> ( <type>bigint</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_and</function> ( <type>bit</type> )
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        Computes the bitwise AND of all non-null input values.
       </para></entry>
       <entry>Yes</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bit_and</primary>
        </indexterm>
        <function>bit_and</function> ( <type>smallint</type> )
        <returnvalue>smallint</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_and</function> ( <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_and</function> ( <type>bigint</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_and</function> ( <type>bit</type> )
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        计算所有非空输入值的逐位AND。
       </para></entry>
       <entry>Yes</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bit_or</primary>
        </indexterm>
        <function>bit_or</function> ( <type>smallint</type> )
        <returnvalue>smallint</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_or</function> ( <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_or</function> ( <type>bigint</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_or</function> ( <type>bit</type> )
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        Computes the bitwise OR of all non-null input values.
       </para></entry>
       <entry>Yes</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bit_or</primary>
        </indexterm>
        <function>bit_or</function> ( <type>smallint</type> )
        <returnvalue>smallint</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_or</function> ( <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_or</function> ( <type>bigint</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_or</function> ( <type>bit</type> )
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        计算所有非空输入值的逐位OR。
       </para></entry>
       <entry>Yes</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bool_and</primary>
        </indexterm>
        <function>bool_and</function> ( <type>boolean</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Returns true if all non-null input values are true, otherwise false.
       </para></entry>
       <entry>Yes</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bool_and</primary>
        </indexterm>
        <function>bool_and</function> ( <type>boolean</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        如果全部非空输入值都为真则返回真，否则返回假。
       </para></entry>
       <entry>Yes</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bool_or</primary>
        </indexterm>
        <function>bool_or</function> ( <type>boolean</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Returns true if any non-null input value is true, otherwise false.
       </para></entry>
       <entry>Yes</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bool_or</primary>
        </indexterm>
        <function>bool_or</function> ( <type>boolean</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        如果任何非空输入值为真则返回真，否则返回假。
       </para></entry>
       <entry>Yes</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>count</primary>
        </indexterm>
        <function>count</function> ( <literal>*</literal> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Computes the number of input rows.
       </para></entry>
       <entry>Yes</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>count</primary>
        </indexterm>
        <function>count</function> ( <literal>*</literal> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        计算输入行的数量。
       </para></entry>
       <entry>Yes</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>count</function> ( <type>"any"</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Computes the number of input rows in which the input value is not
        null.
       </para></entry>
       <entry>Yes</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>count</function> ( <type>"any"</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        计算输入值不为空的输入行的数量。
       </para></entry>
       <entry>Yes</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>every</primary>
        </indexterm>
        <function>every</function> ( <type>boolean</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        This is the SQL standard's equivalent to <function>bool_and</function>.
       </para></entry>
       <entry>Yes</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>every</primary>
        </indexterm>
        <function>every</function> ( <type>boolean</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        这是对应<function>bool_and</function>的SQL标准的等效物。
       </para></entry>
       <entry>Yes</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_agg</primary>
        </indexterm>
        <function>json_agg</function> ( <type>anyelement</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_agg</primary>
        </indexterm>
        <function>jsonb_agg</function> ( <type>anyelement</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Collects all the input values, including nulls, into a JSON array.
        Values are converted to JSON as per <function>to_json</function>
        or <function>to_jsonb</function>.
       </para></entry>
       <entry>No</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_agg</primary>
        </indexterm>
        <function>json_agg</function> ( <type>anyelement</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_agg</primary>
        </indexterm>
        <function>jsonb_agg</function> ( <type>anyelement</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        收集所有输入值，包括空值，到一个JSON数组。根据<function>to_json</function>或<function>to_jsonb</function>将值转换为JSON。
       </para></entry>
       <entry>No</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_object_agg</primary>
        </indexterm>
        <function>json_object_agg</function> ( <parameter>key</parameter>
         <type>"any"</type>, <parameter>value</parameter>
         <type>"any"</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_object_agg</primary>
        </indexterm>
        <function>jsonb_object_agg</function> ( <parameter>key</parameter>
         <type>"any"</type>, <parameter>value</parameter>
         <type>"any"</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Collects all the key/value pairs into a JSON object.  Key arguments
        are coerced to text; value arguments are converted as
        per <function>to_json</function> or <function>to_jsonb</function>.
        Values can be null, but not keys.
       </para></entry>
       <entry>No</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_object_agg</primary>
        </indexterm>
        <function>json_object_agg</function> ( <parameter>key</parameter>
         <type>"any"</type>, <parameter>value</parameter>
         <type>"any"</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_object_agg</primary>
        </indexterm>
        <function>jsonb_object_agg</function> ( <parameter>key</parameter>
         <type>"any"</type>, <parameter>value</parameter>
         <type>"any"</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        将所有键/值对收集到一个JSON对象中。关键参数强制转换为文本；值参数按照<function>to_json</function>或<function>to_jsonb</function>进行转换。
        值可以为空，但键不能（为空）。
       </para></entry>
       <entry>No</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>max</primary>
        </indexterm>
        <function>max</function> ( <replaceable>see text</replaceable> )
        <returnvalue><replaceable>same as input type</replaceable></returnvalue>
       </para>
       <para>
        Computes the maximum of the non-null input
        values.  Available for any numeric, string, date/time, or enum type,
        as well as <type>inet</type>, <type>interval</type>,
        <type>money</type>, <type>oid</type>, <type>pg_lsn</type>,
        <type>tid</type>,
        and arrays of any of these types.
       </para></entry>
       <entry>Yes</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>max</primary>
        </indexterm>
        <function>max</function> ( <replaceable>see text</replaceable> )
        <returnvalue><replaceable>same as input type</replaceable></returnvalue>
       </para>
       <para>
        计算非空输入值的最大值。适用于任何数字、字符串、日期/时间或enum类型，
        以及<type>inet</type>, <type>interval</type>, <type>money</type>, <type>oid</type>, <type>pg_lsn</type>,<type>tid</type>和任何这些类型的数组。
       </para></entry>
       <entry>Yes</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>min</primary>
        </indexterm>
        <function>min</function> ( <replaceable>see text</replaceable> )
        <returnvalue><replaceable>same as input type</replaceable></returnvalue>
       </para>
       <para>
        Computes the minimum of the non-null input
        values.  Available for any numeric, string, date/time, or enum type,
        as well as <type>inet</type>, <type>interval</type>,
        <type>money</type>, <type>oid</type>, <type>pg_lsn</type>,
        <type>tid</type>,
        and arrays of any of these types.
       </para></entry>
       <entry>Yes</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>min</primary>
        </indexterm>
        <function>min</function> ( <replaceable>see text</replaceable> )
        <returnvalue><replaceable>same as input type</replaceable></returnvalue>
       </para>
       <para>
        计算非空输入值的最小值。可用于任何数字、字符串、日期/时间或enum类型，
        以及<type>inet</type>, <type>interval</type>,<type>money</type>, <type>oid</type>, <type>pg_lsn</type>,<type>tid</type>和任何这些类型的数组。
       </para></entry>
       <entry>Yes</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>string_agg</primary>
        </indexterm>
        <function>string_agg</function> ( <parameter>value</parameter>
         <type>text</type>, <parameter>delimiter</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>string_agg</function> ( <parameter>value</parameter>
         <type>bytea</type>, <parameter>delimiter</parameter> <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        Concatenates the non-null input values into a string.  Each value
        after the first is preceded by the
        corresponding <parameter>delimiter</parameter> (if it's not null).
       </para></entry>
       <entry>No</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>string_agg</primary>
        </indexterm>
        <function>string_agg</function> ( <parameter>value</parameter>
         <type>text</type>, <parameter>delimiter</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>string_agg</function> ( <parameter>value</parameter>
         <type>bytea</type>, <parameter>delimiter</parameter> <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        连接非空输入值到字符串中。第一个值之后的每个值前面都有相应的<parameter>分隔符(delimiter)</parameter>(如果它不为空)。
       </para></entry>
       <entry>No</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sum</primary>
        </indexterm>
        <function>sum</function> ( <type>smallint</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para role="func_signature">
        <function>sum</function> ( <type>integer</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para role="func_signature">
        <function>sum</function> ( <type>bigint</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>sum</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>sum</function> ( <type>real</type> )
        <returnvalue>real</returnvalue>
       </para>
       <para role="func_signature">
        <function>sum</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para role="func_signature">
        <function>sum</function> ( <type>interval</type> )
        <returnvalue>interval</returnvalue>
       </para>
       <para role="func_signature">
        <function>sum</function> ( <type>money</type> )
        <returnvalue>money</returnvalue>
       </para>
       <para>
        Computes the sum of the non-null input values.
       </para></entry>
       <entry>Yes</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sum</primary>
        </indexterm>
        <function>sum</function> ( <type>smallint</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para role="func_signature">
        <function>sum</function> ( <type>integer</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para role="func_signature">
        <function>sum</function> ( <type>bigint</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>sum</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>sum</function> ( <type>real</type> )
        <returnvalue>real</returnvalue>
       </para>
       <para role="func_signature">
        <function>sum</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para role="func_signature">
        <function>sum</function> ( <type>interval</type> )
        <returnvalue>interval</returnvalue>
       </para>
       <para role="func_signature">
        <function>sum</function> ( <type>money</type> )
        <returnvalue>money</returnvalue>
       </para>
       <para>
        计算非空输入值的总和。
       </para></entry>
       <entry>Yes</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>xmlagg</primary>
        </indexterm>
        <function>xmlagg</function> ( <type>xml</type> )
        <returnvalue>xml</returnvalue>
       </para>
       <para>
        Concatenates the non-null XML input values (see
        <xref linkend="functions-xml-xmlagg"/>).
       </para></entry>
       <entry>No</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>xmlagg</primary>
        </indexterm>
        <function>xmlagg</function> ( <type>xml</type> )
        <returnvalue>xml</returnvalue>
       </para>
       <para>
        连接非空的XML输入值(参见<xref linkend="functions-xml-xmlagg"/>)。
       </para></entry>
       <entry>No</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
  <para>
   It should be noted that except for <function>count</function>,
   these functions return a null value when no rows are selected.  In
   particular, <function>sum</function> of no rows returns null, not
   zero as one might expect, and <function>array_agg</function>
   returns null rather than an empty array when there are no input
   rows.  The <function>coalesce</function> function can be used to
   substitute zero or an empty array for null when necessary.
  </para>
____________________________________________________________________________-->
  <para>
   应该注意的是，除了<function>count</function>之外，这些函数在没有选择行时返回空值。
   特别地，行数的<function>sum</function>返回空(null)，而不是预期的零，<function>array_agg</function>在没有输入行时返回空(null)而不是空数组。
   <function>coalesce</function>函数可以在必要时用零或空数组代替空(null)。
  </para>

<!--==========================orignal english content==========================
  <para>
   The aggregate functions <function>array_agg</function>,
   <function>json_agg</function>, <function>jsonb_agg</function>,
   <function>json_object_agg</function>, <function>jsonb_object_agg</function>,
   <function>string_agg</function>,
   and <function>xmlagg</function>, as well as similar user-defined
   aggregate functions, produce meaningfully different result values
   depending on the order of the input values.  This ordering is
   unspecified by default, but can be controlled by writing an
   <literal>ORDER BY</literal> clause within the aggregate call, as shown in
   <xref linkend="syntax-aggregates"/>.
   Alternatively, supplying the input values from a sorted subquery
   will usually work.  For example:

<screen><![CDATA[
SELECT xmlagg(x) FROM (SELECT x FROM test ORDER BY y DESC) AS tab;
]]></screen>

   Beware that this approach can fail if the outer query level contains
   additional processing, such as a join, because that might cause the
   subquery's output to be reordered before the aggregate is computed.
  </para>
____________________________________________________________________________-->
  <para>
   聚合函数 <function>array_agg</function>,<function>json_agg</function>, <function>jsonb_agg</function>,<function>json_object_agg</function>, <function>jsonb_object_agg</function>,
   <function>string_agg</function>,和 <function>xmlagg</function>,以及类似的用户定义的聚合函数，根据输入值的顺序产生富有意义的不同的结果值。 
   默认情况下，这种排序是不指定的，但可以通过在聚合调用中写入<literal>ORDER BY</literal>子句来控制，如<xref linkend="syntax-aggregates"/>所示。
   或者，从排序的子查询提供输入值通常也可以。例如：

<screen><![CDATA[
SELECT xmlagg(x) FROM (SELECT x FROM test ORDER BY y DESC) AS tab;
]]></screen>

   注意，如果外部查询级别包含其他处理，例如关联，则此方法可能会失败，因为这可能导致子查询的输出在计算聚合之前重新排序。
  </para>

  <note>
<!--==========================orignal english content==========================
    <indexterm>
      <primary>ANY</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
      <primary>ANY</primary>
    </indexterm>
<!--==========================orignal english content==========================
    <indexterm>
      <primary>SOME</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
      <primary>SOME</primary>
    </indexterm>
<!--==========================orignal english content==========================
    <para>
      The boolean aggregates <function>bool_and</function> and
      <function>bool_or</function> correspond to the standard SQL aggregates
      <function>every</function> and <function>any</function> or
      <function>some</function>.
      <productname>PostgreSQL</productname>
      supports <function>every</function>, but not <function>any</function>
      or <function>some</function>, because there is an ambiguity built into
      the standard syntax:
<programlisting>
SELECT b1 = ANY((SELECT b2 FROM t2 ...)) FROM t1 ...;
</programlisting>
      Here <function>ANY</function> can be considered either as introducing
      a subquery, or as being an aggregate function, if the subquery
      returns one row with a Boolean value.
      Thus the standard name cannot be given to these aggregates.
    </para>
____________________________________________________________________________-->
    <para>
      布尔聚合 <function>bool_and</function> 和 <function>bool_or</function> 对应于标准SQL聚合 <function>every</function> 和 <function>any</function> 或 <function>some</function>.
      <productname>PostgreSQL</productname> 支持 <function>every</function>, 但不支持 <function>any</function> 或 <function>some</function>, 因为标准语法中存在模糊性:
<programlisting>
SELECT b1 = ANY((SELECT b2 FROM t2 ...)) FROM t1 ...;
</programlisting>
      这里<function>ANY</function>可以被认为是引入子查询，或者是聚合函数，如果子查询返回一行布尔值。因此，不能为这些聚合提供标准名称。
    </para>
  </note>

  <note>
<!--==========================orignal english content==========================
   <para>
    Users accustomed to working with other SQL database management
    systems might be disappointed by the performance of the
    <function>count</function> aggregate when it is applied to the
    entire table. A query like:
<programlisting>
SELECT count(*) FROM sometable;
</programlisting>
    will require effort proportional to the size of the table:
    <productname>PostgreSQL</productname> will need to scan either the
    entire table or the entirety of an index that includes all rows in
    the table.
   </para>
____________________________________________________________________________-->
   <para>
    习惯使用其他SQL数据库管理系统的用户可能会对<function>count</function>聚合应用于整个表时的性能感到失望。一个类似下面的查询:
<programlisting>
SELECT count(*) FROM sometable;
</programlisting>
    将需要与表大小成比例的工作:<productname>PostgreSQL</productname>将需要扫描整个表或包含表中所有行的索引。
   </para>
  </note>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="functions-aggregate-statistics-table"/> shows
   aggregate functions typically used in statistical analysis.
   (These are separated out merely to avoid cluttering the listing
   of more-commonly-used aggregates.)  Functions shown as
   accepting <replaceable>numeric_type</replaceable> are available for all
   the types <type>smallint</type>, <type>integer</type>,
   <type>bigint</type>, <type>numeric</type>, <type>real</type>,
   and <type>double precision</type>.
   Where the description mentions
   <parameter>N</parameter>, it means the
   number of input rows for which all the input expressions are non-null.
   In all cases, null is returned if the computation is meaningless,
   for example when <parameter>N</parameter> is zero.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="functions-aggregate-statistics-table"/>显示了统计分析中常用的聚合函数。
   (这些被分离出来仅仅是为了避免使更常用的聚合列表混乱。)
   显示为接受<replaceable>numeric_type</replaceable>的函数可用于所有类型<type>smallint</type>, <type>integer</type>,<type>bigint</type>, <type>numeric</type>, <type>real</type>, 和 <type>double precision</type>。
   在描述中提及<parameter>N</parameter>时，它意味着所有输入表达式都非空的输入行数。在所有情况下，如果计算没有意义，则返回null，例如当<parameter>N</parameter>为0时。
  </para>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>statistics</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>统计</primary>
  </indexterm>
<!--==========================orignal english content==========================
  <indexterm>
   <primary>linear regression</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>线性回归</primary>
  </indexterm>

   <table id="functions-aggregate-statistics-table">
<!--==========================orignal english content==========================
    <title>Aggregate Functions for Statistics</title>
____________________________________________________________________________-->
    <title>用于统计的聚集函数</title>
    <tgroup cols="2">
     <colspec colname="col1" colwidth="10*"/>
     <colspec colname="col2" colwidth="1*"/>
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
       <entry>Partial Mode</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
       <entry>部分模式</entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>correlation</primary>
        </indexterm>
        <indexterm>
         <primary>corr</primary>
        </indexterm>
        <function>corr</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the correlation coefficient.
       </para></entry>
       <entry>Yes</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>correlation</primary>
        </indexterm>
        <indexterm>
         <primary>corr</primary>
        </indexterm>
        <function>corr</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算相关系数。
       </para></entry>
       <entry>Yes</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>covariance</primary>
         <secondary>population</secondary>
        </indexterm>
        <indexterm>
         <primary>covar_pop</primary>
        </indexterm>
        <function>covar_pop</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the population covariance.
       </para></entry>
       <entry>Yes</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>covariance</primary>
         <secondary>population</secondary>
        </indexterm>
        <indexterm>
         <primary>covar_pop</primary>
        </indexterm>
        <function>covar_pop</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算总体协方差。
       </para></entry>
       <entry>Yes</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>covariance</primary>
         <secondary>sample</secondary>
        </indexterm>
        <indexterm>
         <primary>covar_samp</primary>
        </indexterm>
        <function>covar_samp</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the sample covariance.
       </para></entry>
       <entry>Yes</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>covariance</primary>
         <secondary>sample</secondary>
        </indexterm>
        <indexterm>
         <primary>covar_samp</primary>
        </indexterm>
        <function>covar_samp</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算样本协方差。
       </para></entry>
       <entry>Yes</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regr_avgx</primary>
        </indexterm>
        <function>regr_avgx</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the average of the independent variable,
        <literal>sum(<parameter>X</parameter>)/<parameter>N</parameter></literal>.
       </para></entry>
       <entry>Yes</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regr_avgx</primary>
        </indexterm>
        <function>regr_avgx</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算自变量的平均值,<literal>sum(<parameter>X</parameter>)/<parameter>N</parameter></literal>.
       </para></entry>
       <entry>Yes</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regr_avgy</primary>
        </indexterm>
        <function>regr_avgy</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the average of the dependent variable,
        <literal>sum(<parameter>Y</parameter>)/<parameter>N</parameter></literal>.
       </para></entry>
       <entry>Yes</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regr_avgy</primary>
        </indexterm>
        <function>regr_avgy</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算因变量的平均值，<literal>sum(<parameter>Y</parameter>)/<parameter>N</parameter></literal>.
       </para></entry>
       <entry>Yes</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regr_count</primary>
        </indexterm>
        <function>regr_count</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Computes the number of rows in which both inputs are non-null.
       </para></entry>
       <entry>Yes</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regr_count</primary>
        </indexterm>
        <function>regr_count</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        计算两个输入都非空的行数。
       </para></entry>
       <entry>Yes</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regression intercept</primary>
        </indexterm>
        <indexterm>
         <primary>regr_intercept</primary>
        </indexterm>
        <function>regr_intercept</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the y-intercept of the least-squares-fit linear equation
        determined by the
        (<parameter>X</parameter>, <parameter>Y</parameter>) pairs.
       </para></entry>
       <entry>Yes</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regression intercept</primary>
        </indexterm>
        <indexterm>
         <primary>regr_intercept</primary>
        </indexterm>
        <function>regr_intercept</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算由(<parameter>X</parameter>，<parameter>Y</parameter>)对决定的最小二乘拟合的线性方程的Y-截距。
       </para></entry>
       <entry>Yes</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regr_r2</primary>
        </indexterm>
        <function>regr_r2</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the square of the correlation coefficient.
       </para></entry>
       <entry>Yes</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regr_r2</primary>
        </indexterm>
        <function>regr_r2</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算相关系数的平方。
       </para></entry>
       <entry>Yes</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regression slope</primary>
        </indexterm>
        <indexterm>
         <primary>regr_slope</primary>
        </indexterm>
        <function>regr_slope</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the slope of the least-squares-fit linear equation determined
        by the (<parameter>X</parameter>, <parameter>Y</parameter>)
        pairs.
       </para></entry>
       <entry>Yes</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regression slope</primary>
        </indexterm>
        <indexterm>
         <primary>regr_slope</primary>
        </indexterm>
        <function>regr_slope</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算由(<parameter>X</parameter>, <parameter>Y</parameter>)对决定的最小二乘拟合的线性方程的斜率。
       </para></entry>
       <entry>Yes</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regr_sxx</primary>
        </indexterm>
        <function>regr_sxx</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the <quote>sum of squares</quote> of the independent
        variable,
        <literal>sum(<parameter>X</parameter>^2) - sum(<parameter>X</parameter>)^2/<parameter>N</parameter></literal>.
       </para></entry>
       <entry>Yes</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regr_sxx</primary>
        </indexterm>
        <function>regr_sxx</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算自变量的<quote>平方和</quote>
        <literal>sum(<parameter>X</parameter>^2) - sum(<parameter>X</parameter>)^2/<parameter>N</parameter></literal>.
       </para></entry>
       <entry>Yes</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regr_sxy</primary>
        </indexterm>
        <function>regr_sxy</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the <quote>sum of products</quote> of independent times
        dependent variables,
        <literal>sum(<parameter>X</parameter>*<parameter>Y</parameter>) - sum(<parameter>X</parameter>) * sum(<parameter>Y</parameter>)/<parameter>N</parameter></literal>.
       </para></entry>
       <entry>Yes</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regr_sxy</primary>
        </indexterm>
        <function>regr_sxy</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算独立变量乘以因变量的<quote>sum of products</quote>，
        <literal>sum(<parameter>X</parameter>*<parameter>Y</parameter>) - sum(<parameter>X</parameter>) * sum(<parameter>Y</parameter>)/<parameter>N</parameter></literal>.
       </para></entry>
       <entry>Yes</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regr_syy</primary>
        </indexterm>
        <function>regr_syy</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the <quote>sum of squares</quote> of the dependent
        variable,
        <literal>sum(<parameter>Y</parameter>^2) - sum(<parameter>Y</parameter>)^2/<parameter>N</parameter></literal>.
       </para></entry>
       <entry>Yes</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regr_syy</primary>
        </indexterm>
        <function>regr_syy</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算因变量的<quote>平方和</quote>，
        <literal>sum(<parameter>Y</parameter>^2) - sum(<parameter>Y</parameter>)^2/<parameter>N</parameter></literal>.
       </para></entry>
       <entry>Yes</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>standard deviation</primary>
        </indexterm>
        <indexterm>
         <primary>stddev</primary>
        </indexterm>
        <function>stddev</function> ( <replaceable>numeric_type</replaceable> )
        <returnvalue></returnvalue> <type>double precision</type>
        for <type>real</type> or <type>double precision</type>,
        otherwise <type>numeric</type>
       </para>
       <para>
        This is a historical alias for <function>stddev_samp</function>.
       </para></entry>
       <entry>Yes</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>standard deviation</primary>
        </indexterm>
        <indexterm>
         <primary>stddev</primary>
        </indexterm>
        <function>stddev</function> ( <replaceable>numeric_type</replaceable> )
        <returnvalue></returnvalue> <type>double precision</type>
        for <type>real</type> or <type>double precision</type>,
        otherwise <type>numeric</type>
       </para>
       <para>
        这是<function>stddev_samp</function>的一个历史别称。
       </para></entry>
       <entry>Yes</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>standard deviation</primary>
         <secondary>population</secondary>
        </indexterm>
        <indexterm>
         <primary>stddev_pop</primary>
        </indexterm>
        <function>stddev_pop</function> ( <replaceable>numeric_type</replaceable> )
        <returnvalue></returnvalue> <type>double precision</type>
        for <type>real</type> or <type>double precision</type>,
        otherwise <type>numeric</type>
       </para>
       <para>
        Computes the population standard deviation of the input values.
       </para></entry>
       <entry>Yes</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>standard deviation</primary>
         <secondary>population</secondary>
        </indexterm>
        <indexterm>
         <primary>stddev_pop</primary>
        </indexterm>
        <function>stddev_pop</function> ( <replaceable>numeric_type</replaceable> )
        <returnvalue></returnvalue> <type>double precision</type>
        for <type>real</type> or <type>double precision</type>,
        otherwise <type>numeric</type>
       </para>
       <para>
        计算输入值的总体标准差。
       </para></entry>
       <entry>Yes</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>standard deviation</primary>
         <secondary>sample</secondary>
        </indexterm>
        <indexterm>
         <primary>stddev_samp</primary>
        </indexterm>
        <function>stddev_samp</function> ( <replaceable>numeric_type</replaceable> )
        <returnvalue></returnvalue> <type>double precision</type>
        for <type>real</type> or <type>double precision</type>,
        otherwise <type>numeric</type>
       </para>
       <para>
        Computes the sample standard deviation of the input values.
       </para></entry>
       <entry>Yes</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>standard deviation</primary>
         <secondary>sample</secondary>
        </indexterm>
        <indexterm>
         <primary>stddev_samp</primary>
        </indexterm>
        <function>stddev_samp</function> ( <replaceable>numeric_type</replaceable> )
        <returnvalue></returnvalue> <type>double precision</type>
        for <type>real</type> or <type>double precision</type>,
        otherwise <type>numeric</type>
       </para>
       <para>
        计算输入值的样本标准差。
       </para></entry>
       <entry>Yes</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>variance</primary>
        </indexterm>
        <function>variance</function> ( <replaceable>numeric_type</replaceable> )
        <returnvalue></returnvalue> <type>double precision</type>
        for <type>real</type> or <type>double precision</type>,
        otherwise <type>numeric</type>
       </para>
       <para>
        This is a historical alias for <function>var_samp</function>.
       </para></entry>
       <entry>Yes</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>variance</primary>
        </indexterm>
        <function>variance</function> ( <replaceable>numeric_type</replaceable> )
        <returnvalue></returnvalue> <type>double precision</type>
        for <type>real</type> or <type>double precision</type>,
        otherwise <type>numeric</type>
       </para>
       <para>
        这是 <function>var_samp</function> 的一个历史别称。
       </para></entry>
       <entry>Yes</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>variance</primary>
         <secondary>population</secondary>
        </indexterm>
        <indexterm>
         <primary>var_pop</primary>
        </indexterm>
        <function>var_pop</function> ( <replaceable>numeric_type</replaceable> )
        <returnvalue></returnvalue> <type>double precision</type>
        for <type>real</type> or <type>double precision</type>,
        otherwise <type>numeric</type>
       </para>
       <para>
        Computes the population variance of the input values (square of the
        population standard deviation).
       </para></entry>
       <entry>Yes</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>variance</primary>
         <secondary>population</secondary>
        </indexterm>
        <indexterm>
         <primary>var_pop</primary>
        </indexterm>
        <function>var_pop</function> ( <replaceable>numeric_type</replaceable> )
        <returnvalue></returnvalue> <type>double precision</type>
        for <type>real</type> or <type>double precision</type>,
        otherwise <type>numeric</type>
       </para>
       <para>
        计算输入值的总体方差(总体标准差的平方)。
       </para></entry>
       <entry>Yes</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>variance</primary>
         <secondary>sample</secondary>
        </indexterm>
        <indexterm>
         <primary>var_samp</primary>
        </indexterm>
        <function>var_samp</function> ( <replaceable>numeric_type</replaceable> )
        <returnvalue></returnvalue> <type>double precision</type>
        for <type>real</type> or <type>double precision</type>,
        otherwise <type>numeric</type>
       </para>
       <para>
        Computes the sample variance of the input values (square of the sample
        standard deviation).
       </para></entry>
       <entry>Yes</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>variance</primary>
         <secondary>sample</secondary>
        </indexterm>
        <indexterm>
         <primary>var_samp</primary>
        </indexterm>
        <function>var_samp</function> ( <replaceable>numeric_type</replaceable> )
        <returnvalue></returnvalue> <type>double precision</type>
        for <type>real</type> or <type>double precision</type>,
        otherwise <type>numeric</type>
       </para>
       <para>
        计算输入值的样本方差(样本标准差的平方)。
       </para></entry>
       <entry>Yes</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="functions-orderedset-table"/> shows some
   aggregate functions that use the <firstterm>ordered-set aggregate</firstterm>
   syntax.  These functions are sometimes referred to as <quote>inverse
   distribution</quote> functions.  Their aggregated input is introduced by
   <literal>ORDER BY</literal>, and they may also take a <firstterm>direct
   argument</firstterm> that is not aggregated, but is computed only once.
   All these functions ignore null values in their aggregated input.
   For those that take a <parameter>fraction</parameter> parameter, the
   fraction value must be between 0 and 1; an error is thrown if not.
   However, a null <parameter>fraction</parameter> value simply produces a
   null result.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="functions-orderedset-table"/>显示了一些使用<firstterm>ordered-set aggregate</firstterm>语法的聚合函数。
   这些函数有时被称为<quote>inverse distribution</quote>函数。
   它们的聚合输入是通过<literal>ORDER BY</literal>引入的，它们还可以接受未聚合的<firstterm>direct argument</firstterm>，但只计算一次。
   所有这些函数在其聚合的输入中都忽略空(null)值。
   对于使用<parameter>fraction(fraction)</parameter>参数的函数，分数值必须在0到1之间;否则将抛出一个错误。但是，空<parameter>分数</parameter>值简单地产生一个空结果。
  </para>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>ordered-set aggregate</primary>
   <secondary>built-in</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>ordered-set aggregate</primary>
   <secondary>内建</secondary>
  </indexterm>
<!--==========================orignal english content==========================
  <indexterm>
   <primary>inverse distribution</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>逆分布</primary>
  </indexterm>

   <table id="functions-orderedset-table">
<!--==========================orignal english content==========================
    <title>Ordered-Set Aggregate Functions</title>
____________________________________________________________________________-->
    <title>有序集聚集函数</title>
    <tgroup cols="2">
     <colspec colname="col1" colwidth="10*"/>
     <colspec colname="col2" colwidth="1*"/>
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
       <entry>Partial Mode</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
       <entry>部分模式</entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>mode</primary>
         <secondary>statistical</secondary>
        </indexterm>
        <function>mode</function> () <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>anyelement</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        Computes the <firstterm>mode</firstterm>, the most frequent
        value of the aggregated argument (arbitrarily choosing the first one
        if there are multiple equally-frequent values).  The aggregated
        argument must be of a sortable type.
       </para></entry>
       <entry>No</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>mode</primary>
         <secondary>statistical</secondary>
        </indexterm>
        <function>mode</function> () <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>anyelement</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        计算<firstterm>mode</firstterm>，即聚合参数最频繁的值(如果有多个相同频繁的值，第一个可以任意选择)。聚合参数必须是可排序类型。
       </para></entry>
       <entry>No</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>percentile</primary>
         <secondary>continuous</secondary>
        </indexterm>
        <function>percentile_cont</function> ( <parameter>fraction</parameter> <type>double precision</type> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para role="func_signature">
        <function>percentile_cont</function> ( <parameter>fraction</parameter> <type>double precision</type> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>interval</type> )
        <returnvalue>interval</returnvalue>
       </para>
       <para>
        Computes the <firstterm>continuous percentile</firstterm>, a value
        corresponding to the specified <parameter>fraction</parameter>
        within the ordered set of aggregated argument values.  This will
        interpolate between adjacent input items if needed.
       </para></entry>
       <entry>No</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>percentile</primary>
         <secondary>continuous</secondary>
        </indexterm>
        <function>percentile_cont</function> ( <parameter>fraction</parameter> <type>double precision</type> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para role="func_signature">
        <function>percentile_cont</function> ( <parameter>fraction</parameter> <type>double precision</type> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>interval</type> )
        <returnvalue>interval</returnvalue>
       </para>
       <para>
        计算<firstterm>continuous percentile</firstterm>，该值对应于聚合参数值的有序集合中的指定<parameter>分数(fraction)</parameter>。
        如果需要，这将在相邻的输入项之间插入。
       </para></entry>
       <entry>No</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>percentile_cont</function> ( <parameter>fractions</parameter> <type>double precision[]</type> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>double precision</type> )
        <returnvalue>double precision[]</returnvalue>
       </para>
       <para role="func_signature">
        <function>percentile_cont</function> ( <parameter>fractions</parameter> <type>double precision[]</type> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>interval</type> )
        <returnvalue>interval[]</returnvalue>
       </para>
       <para>
        Computes multiple continuous percentiles.  The result is an array of
        the same dimensions as the <parameter>fractions</parameter>
        parameter, with each non-null element replaced by the (possibly
        interpolated) value corresponding to that percentile.
       </para></entry>
       <entry>No</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>percentile_cont</function> ( <parameter>fractions</parameter> <type>double precision[]</type> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>double precision</type> )
        <returnvalue>double precision[]</returnvalue>
       </para>
       <para role="func_signature">
        <function>percentile_cont</function> ( <parameter>fractions</parameter> <type>double precision[]</type> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>interval</type> )
        <returnvalue>interval[]</returnvalue>
       </para>
       <para>
        计算多个连续的百分位数。结果是一个与<parameter>分数(fractions)</parameter>参数具有相同维数的数组，每个非空元素都被对应于该百分位的(可能插值的)值所替换。
       </para></entry>
       <entry>No</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>percentile</primary>
         <secondary>discrete</secondary>
        </indexterm>
        <function>percentile_disc</function> ( <parameter>fraction</parameter> <type>double precision</type> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>anyelement</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        Computes the <firstterm>discrete percentile</firstterm>, the first
        value within the ordered set of aggregated argument values whose
        position in the ordering equals or exceeds the
        specified <parameter>fraction</parameter>.  The aggregated
        argument must be of a sortable type.
       </para></entry>
       <entry>No</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>percentile</primary>
         <secondary>discrete</secondary>
        </indexterm>
        <function>percentile_disc</function> ( <parameter>fraction</parameter> <type>double precision</type> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>anyelement</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        计算<firstterm>离散百分比(discrete percentile)</firstterm>，即聚合参数值的有序集合中的第一个值，该值在排序中的位置等于或超过指定的<parameter>fraction</parameter>。
        聚合参数必须是可排序类型。
       </para></entry>
       <entry>No</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>percentile_disc</function> ( <parameter>fractions</parameter> <type>double precision[]</type> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>anyelement</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        Computes multiple discrete percentiles.  The result is an array of the
        same dimensions as the <parameter>fractions</parameter> parameter,
        with each non-null element replaced by the input value corresponding
        to that percentile.
        The aggregated argument must be of a sortable type.
       </para></entry>
       <entry>No</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>percentile_disc</function> ( <parameter>fractions</parameter> <type>double precision[]</type> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>anyelement</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        计算多个离散百分位数。
        结果是一个与<parameter>fractions</parameter>参数具有相同维数的数组，每个非空元素都被对应于该百分位的输入值替换。
        聚合参数必须是可排序类型。
       </para></entry>
       <entry>No</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>hypothetical-set aggregate</primary>
   <secondary>built-in</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>hypothetical-set aggregate</primary>
   <secondary>内建</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   Each of the <quote>hypothetical-set</quote> aggregates listed in
   <xref linkend="functions-hypothetical-table"/> is associated with a
   window function of the same name defined in
   <xref linkend="functions-window"/>.  In each case, the aggregate's result
   is the value that the associated window function would have
   returned for the <quote>hypothetical</quote> row constructed from
   <replaceable>args</replaceable>, if such a row had been added to the sorted
   group of rows represented by the <replaceable>sorted_args</replaceable>.
   For each of these functions, the list of direct arguments
   given in <replaceable>args</replaceable> must match the number and types of
   the aggregated arguments given in <replaceable>sorted_args</replaceable>.
   Unlike most built-in aggregates, these aggregates are not strict, that is
   they do not drop input rows containing nulls.  Null values sort according
   to the rule specified in the <literal>ORDER BY</literal> clause.
  </para>
____________________________________________________________________________-->
  <para>
   列在<xref linkend="functions-hypothetical-table"/>中的每个<quote>hypothetical-set</quote>聚合都与<xref linkend="functions-window"/>中定义的同名窗口函数相关联。
   在每种情况下，聚合的结果都是相关的窗口函数将为由<replaceable>args</replaceable>构造的<quote>hypothetical</quote>行返回的值，如果将这样的行添加到<replaceable>sorted_args</replaceable>表示的已排序行组中。
   对于这些函数中的每一个，<replaceable>args</replaceable>中给出的直接参数列表必须与<replaceable>sorted_args</replaceable>中给出的聚合参数的数量和类型匹配。
   与大多数内置聚合不同，这些聚合不是严格的，也就是说它们不会删除包含空值的输入行。空值根据<literal>ORDER BY</literal>子句中指定的规则排序。
  </para>

   <table id="functions-hypothetical-table">
<!--==========================orignal english content==========================
    <title>Hypothetical-Set Aggregate Functions</title>
____________________________________________________________________________-->
    <title>假想集聚集函数</title>
    <tgroup cols="2">
     <colspec colname="col1" colwidth="10*"/>
     <colspec colname="col2" colwidth="1*"/>
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
       <entry>Partial Mode</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
       <entry>部分模式</entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>rank</primary>
         <secondary>hypothetical</secondary>
        </indexterm>
        <function>rank</function> ( <replaceable>args</replaceable> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <replaceable>sorted_args</replaceable> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Computes the rank of the hypothetical row, with gaps; that is, the row
        number of the first row in its peer group.
       </para></entry>
       <entry>No</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>rank</primary>
         <secondary>hypothetical</secondary>
        </indexterm>
        <function>rank</function> ( <replaceable>args</replaceable> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <replaceable>sorted_args</replaceable> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        计算假设行的排名，包括间隔，就是说在它的对等组中第一行的行号。
       </para></entry>
       <entry>No</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>dense_rank</primary>
         <secondary>hypothetical</secondary>
        </indexterm>
        <function>dense_rank</function> ( <replaceable>args</replaceable> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <replaceable>sorted_args</replaceable> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Computes the rank of the hypothetical row, without gaps; this function
        effectively counts peer groups.
       </para></entry>
       <entry>No</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>dense_rank</primary>
         <secondary>hypothetical</secondary>
        </indexterm>
        <function>dense_rank</function> ( <replaceable>args</replaceable> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <replaceable>sorted_args</replaceable> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        计算假设行的排名，没有间隔；这个功能有效地计数对等组。
       </para></entry>
       <entry>No</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>percent_rank</primary>
         <secondary>hypothetical</secondary>
        </indexterm>
        <function>percent_rank</function> ( <replaceable>args</replaceable> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <replaceable>sorted_args</replaceable> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the relative rank of the hypothetical row, that is
        (<function>rank</function> - 1) / (total rows - 1).
        The value thus ranges from 0 to 1 inclusive.
       </para></entry>
       <entry>No</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>percent_rank</primary>
         <secondary>hypothetical</secondary>
        </indexterm>
        <function>percent_rank</function> ( <replaceable>args</replaceable> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <replaceable>sorted_args</replaceable> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算假设行的相关排行，也就是(<function>rank</function> - 1) / (total rows - 1)。取值范围为 0 到 1（含）。
       </para></entry>
       <entry>No</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cume_dist</primary>
         <secondary>hypothetical</secondary>
        </indexterm>
        <function>cume_dist</function> ( <replaceable>args</replaceable> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <replaceable>sorted_args</replaceable> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the cumulative distribution, that is (number of rows
        preceding or peers with hypothetical row) / (total rows).  The value
        thus ranges from 1/<parameter>N</parameter> to 1.
       </para></entry>
       <entry>No</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cume_dist</primary>
         <secondary>hypothetical</secondary>
        </indexterm>
        <function>cume_dist</function> ( <replaceable>args</replaceable> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <replaceable>sorted_args</replaceable> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        计算累积分布，也就是(前面或具有假设行的对等行数)/(总行数)。取值范围为 1/<parameter>N</parameter> 到 1。
       </para></entry>
       <entry>No</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <table id="functions-grouping-table">
<!--==========================orignal english content==========================
   <title>Grouping Operations</title>
____________________________________________________________________________-->
   <title>分组操作</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>GROUPING</primary>
        </indexterm>
        <function>GROUPING</function> ( <replaceable>group_by_expression(s)</replaceable> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns a bit mask indicating which <literal>GROUP BY</literal>
        expressions are not included in the current grouping set.
        Bits are assigned with the rightmost argument corresponding to the
        least-significant bit; each bit is 0 if the corresponding expression
        is included in the grouping criteria of the grouping set generating
        the current result row, and 1 if it is not included.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>GROUPING</primary>
        </indexterm>
        <function>GROUPING</function> ( <replaceable>group_by_expression(s)</replaceable> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回一个位掩码以指示哪个<literal>GROUP BY</literal>表达式没有包含在当前分组集中。
        比特位被分配给最右边的参数对应于最低有效位;如果对应的表达式包含在生成当前结果行的分组集的分组条件中，则每个位为0，如果不包含则为1。
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    The grouping operations shown in
    <xref linkend="functions-grouping-table"/> are used in conjunction with
    grouping sets (see <xref linkend="queries-grouping-sets"/>) to distinguish
    result rows.  The arguments to the <literal>GROUPING</literal> function
    are not actually evaluated, but they must exactly match expressions given
    in the <literal>GROUP BY</literal> clause of the associated query level.
    For example:
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT * FROM items_sold;</userinput>
 make  | model | sales
-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-
 Foo   | GT    |  10
 Foo   | Tour  |  20
 Bar   | City  |  15
 Bar   | Sport |  5
(4 rows)

<prompt>=&gt;</prompt> <userinput>SELECT make, model, GROUPING(make,model), sum(sales) FROM items_sold GROUP BY ROLLUP(make,model);</userinput>
 make  | model | grouping | sum
-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-
 Foo   | GT    |        0 | 10
 Foo   | Tour  |        0 | 20
 Bar   | City  |        0 | 15
 Bar   | Sport |        0 | 5
 Foo   |       |        1 | 30
 Bar   |       |        1 | 20
       |       |        3 | 50
(7 rows)
</screen>
    Here, the <literal>grouping</literal> value <literal>0</literal> in the
    first four rows shows that those have been grouped normally, over both the
    grouping columns.  The value <literal>1</literal> indicates
    that <literal>model</literal> was not grouped by in the next-to-last two
    rows, and the value <literal>3</literal> indicates that
    neither <literal>make</literal> nor <literal>model</literal> was grouped
    by in the last row (which therefore is an aggregate over all the input
    rows).
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-grouping-table"/>所示的分组操作与分组集(参见<xref linkend="queries-grouping-sets"/>)共同使用，以区分结果行。
    <literal>GROUPING</literal>函数的参数实际上并不求值，但它们必须与相关查询级别的<literal>GROUP BY</literal>子句中给出的表达式完全匹配。例如:
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT * FROM items_sold;</userinput>
 make  | model | sales
-------+-------+-------
 Foo   | GT    |  10
 Foo   | Tour  |  20
 Bar   | City  |  15
 Bar   | Sport |  5
(4 rows)

<prompt>=&gt;</prompt> <userinput>SELECT make, model, GROUPING(make,model), sum(sales) FROM items_sold GROUP BY ROLLUP(make,model);</userinput>
 make  | model | grouping | sum
-------+-------+----------+-----
 Foo   | GT    |        0 | 10
 Foo   | Tour  |        0 | 20
 Bar   | City  |        0 | 15
 Bar   | Sport |        0 | 5
 Foo   |       |        1 | 30
 Bar   |       |        1 | 20
       |       |        3 | 50
(7 rows)
</screen>
    在这里，前四行中的<literal>grouping</literal>值<literal>0</literal>表明这些已经正常分组，在两个分组列上。
    值<literal>1</literal>表示<literal>model</literal>没有在倒数两行中分组，值<literal>3</literal>表示无论是<literal>make</literal>还是<literal>model</literal>都没有在最后一行中分组(因此，这是所有输入行的聚合)。
   </para>

 </sect1>

 <sect1 id="functions-window">
<!--==========================orignal english content==========================
  <title>Window Functions</title>
____________________________________________________________________________-->
  <title>窗口函数</title>

<!--==========================orignal english content==========================
  <indexterm zone="functions-window">
   <primary>window function</primary>
   <secondary>built-in</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="functions-window">
   <primary>窗口函数</primary>
   <secondary>内建</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   <firstterm>Window functions</firstterm> provide the ability to perform
   calculations across sets of rows that are related to the current query
   row.  See <xref linkend="tutorial-window"/> for an introduction to this
   feature, and <xref linkend="syntax-window-functions"/> for syntax
   details.
  </para>
____________________________________________________________________________-->
  <para>
   <firstterm>Window functions</firstterm>提供了跨越与当前查询行相关的行集执行计算的能力。
   该特性的介绍请参见<xref linkend="tutorial-window"/>，语法细节请参见<xref linkend="syntax-window-functions"/>。
  </para>

<!--==========================orignal english content==========================
  <para>
   The built-in window functions are listed in
   <xref linkend="functions-window-table"/>.  Note that these functions
   <emphasis>must</emphasis> be invoked using window function syntax, i.e., an
   <literal>OVER</literal> clause is required.
  </para>
____________________________________________________________________________-->
  <para>
   内置的窗口函数罗列在<xref linkend="functions-window-table"/>中。注意，这些函数<emphasis>必须</emphasis>使用窗口函数语法来调用，也就是说，需要一个<literal>OVER</literal>子句。
  </para>

<!--==========================orignal english content==========================
  <para>
   In addition to these functions, any built-in or user-defined
   ordinary aggregate (i.e., not ordered-set or hypothetical-set aggregates)
   can be used as a window function; see
   <xref linkend="functions-aggregate"/> for a list of the built-in aggregates.
   Aggregate functions act as window functions only when an <literal>OVER</literal>
   clause follows the call; otherwise they act as plain aggregates
   and return a single row for the entire set.
  </para>
____________________________________________________________________________-->
  <para>
   除了这些函数之外，任何内置的或用户定义的普通聚合(例如非有序集或假设集聚合)都可以作为窗口函数使用;关于内置聚合的列表，参见<xref linkend="functions-aggregate"/>。
   聚合函数只有在调用之后有一个<literal>OVER</literal>子句时才作为窗口函数;否则，它们充当普通的聚合，并为整个集合返回一行。
  </para>

   <table id="functions-window-table">
<!--==========================orignal english content==========================
    <title>General-Purpose Window Functions</title>
____________________________________________________________________________-->
    <title>通用窗口函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>row_number</primary>
        </indexterm>
        <function>row_number</function> ()
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Returns the number of the current row within its partition, counting
        from 1.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>row_number</primary>
        </indexterm>
        <function>row_number</function> ()
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        返回其分区内的当前行数，从1开始计数。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>rank</primary>
        </indexterm>
        <function>rank</function> ()
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Returns the rank of the current row, with gaps; that is,
        the <function>row_number</function> of the first row in its peer
        group.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>rank</primary>
        </indexterm>
        <function>rank</function> ()
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        返回当前行的排名，包含间隔;即对等组中第一行的<function>row_number</function>。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>dense_rank</primary>
        </indexterm>
        <function>dense_rank</function> ()
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Returns the rank of the current row, without gaps; this function
        effectively counts peer groups.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>dense_rank</primary>
        </indexterm>
        <function>dense_rank</function> ()
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        返回当前行的排名，不包括间隔;这个功能有效地计数对等组。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>percent_rank</primary>
        </indexterm>
        <function>percent_rank</function> ()
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Returns the relative rank of the current row, that is
        (<function>rank</function> - 1) / (total partition rows - 1).
        The value thus ranges from 0 to 1 inclusive.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>percent_rank</primary>
        </indexterm>
        <function>percent_rank</function> ()
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        返回当前行的相对排名，即(<function>rank</function> - 1) / (总的分区行数 - 1)。因此，该值的范围从0到1(包含在内)。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cume_dist</primary>
        </indexterm>
        <function>cume_dist</function> ()
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Returns the cumulative distribution, that is (number of partition rows
        preceding or peers with current row) / (total partition rows).
        The value thus ranges from 1/<parameter>N</parameter> to 1.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cume_dist</primary>
        </indexterm>
        <function>cume_dist</function> ()
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        返回累积分布，也就是(当前行之前或对等的分区行数)/(总的分区行数)。取值范围为1/<parameter>N</parameter> 到 1。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ntile</primary>
        </indexterm>
        <function>ntile</function> ( <parameter>num_buckets</parameter> <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns an integer ranging from 1 to the argument value, dividing the
        partition as equally as possible.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ntile</primary>
        </indexterm>
        <function>ntile</function> ( <parameter>num_buckets</parameter> <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回一个从1到参数值的整数，并将分区划分为尽可能相等的值。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lag</primary>
        </indexterm>
        <function>lag</function> ( <parameter>value</parameter> <type>anyelement</type>
          <optional>, <parameter>offset</parameter> <type>integer</type>
          <optional>, <parameter>default</parameter> <type>anyelement</type> </optional></optional> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        Returns <parameter>value</parameter> evaluated at
        the row that is <parameter>offset</parameter>
        rows before the current row within the partition; if there is no such
        row, instead returns <parameter>default</parameter>
        (which must be of the same type as
        <parameter>value</parameter>).
        Both <parameter>offset</parameter> and
        <parameter>default</parameter> are evaluated
        with respect to the current row.  If omitted,
        <parameter>offset</parameter> defaults to 1 and
        <parameter>default</parameter> to <literal>NULL</literal>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lag</primary>
        </indexterm>
        <function>lag</function> ( <parameter>value</parameter> <type>anyelement</type>
          <optional>, <parameter>offset</parameter> <type>integer</type>
          <optional>, <parameter>default</parameter> <type>anyelement</type> </optional></optional> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        返回分区中在当前行之前<parameter>offset</parameter>行的<parameter>value</parameter>;如果没有这样的行，则返回<parameter>default</parameter>(必须与<parameter>value</parameter>具有相同的类型)。
        <parameter>offset</parameter>和<parameter>default</parameter>都是针对当前行求值的。如果省略，<parameter>offset</parameter>默认为1，<parameter>default</parameter>为<literal>NULL</literal>。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lead</primary>
        </indexterm>
        <function>lead</function> ( <parameter>value</parameter> <type>anyelement</type>
          <optional>, <parameter>offset</parameter> <type>integer</type>
          <optional>, <parameter>default</parameter> <type>anyelement</type> </optional></optional> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        Returns <parameter>value</parameter> evaluated at
        the row that is <parameter>offset</parameter>
        rows after the current row within the partition; if there is no such
        row, instead returns <parameter>default</parameter>
        (which must be of the same type as
        <parameter>value</parameter>).
        Both <parameter>offset</parameter> and
        <parameter>default</parameter> are evaluated
        with respect to the current row.  If omitted,
        <parameter>offset</parameter> defaults to 1 and
        <parameter>default</parameter> to <literal>NULL</literal>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lead</primary>
        </indexterm>
        <function>lead</function> ( <parameter>value</parameter> <type>anyelement</type>
          <optional>, <parameter>offset</parameter> <type>integer</type>
          <optional>, <parameter>default</parameter> <type>anyelement</type> </optional></optional> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        返回分区中在当前行之后<parameter>offset</parameter>行的<parameter>value</parameter>；
        如果没有这样的行，则返回<parameter>default</parameter>(必须与<parameter>value</parameter>具有相同的类型)。
        <parameter>offset</parameter>和<parameter>default</parameter>都是针对当前行求值的。如果省略，<parameter>offset</parameter>默认为1，<parameter>default</parameter>为<literal>NULL</literal>。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>first_value</primary>
        </indexterm>
        <function>first_value</function> ( <parameter>value</parameter> <type>anyelement</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        Returns <parameter>value</parameter> evaluated
        at the row that is the first row of the window frame.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>first_value</primary>
        </indexterm>
        <function>first_value</function> ( <parameter>value</parameter> <type>anyelement</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        返回在窗口框架的第一行求得的<parameter>value</parameter>。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>last_value</primary>
        </indexterm>
        <function>last_value</function> ( <parameter>value</parameter> <type>anyelement</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        Returns <parameter>value</parameter> evaluated
        at the row that is the last row of the window frame.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>last_value</primary>
        </indexterm>
        <function>last_value</function> ( <parameter>value</parameter> <type>anyelement</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        返回在窗口框架的最后一行求得的<parameter>value</parameter>。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>nth_value</primary>
        </indexterm>
        <function>nth_value</function> ( <parameter>value</parameter> <type>anyelement</type>, <parameter>n</parameter> <type>integer</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        Returns <parameter>value</parameter> evaluated
        at the row that is the <parameter>n</parameter>'th
        row of the window frame (counting from 1);
        returns <literal>NULL</literal> if there is no such row.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>nth_value</primary>
        </indexterm>
        <function>nth_value</function> ( <parameter>value</parameter> <type>anyelement</type>, <parameter>n</parameter> <type>integer</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        返回在窗口框架的第<parameter>n</parameter>行求得的<parameter>value</parameter>(从1开始计数);如果没有这样的行，则返回<literal>NULL</literal>。
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
  <para>
   All of the functions listed in
   <xref linkend="functions-window-table"/> depend on the sort ordering
   specified by the <literal>ORDER BY</literal> clause of the associated window
   definition.  Rows that are not distinct when considering only the
   <literal>ORDER BY</literal> columns are said to be <firstterm>peers</firstterm>.
   The four ranking functions (including <function>cume_dist</function>) are
   defined so that they give the same answer for all rows of a peer group.
  </para>
____________________________________________________________________________-->
  <para>
   在<xref linkend="functions-window-table"/>中列出的所有函数都依赖于相关窗口定义的<literal>ORDER BY</literal>子句指定的排序顺序。
   仅考虑<literal>ORDER BY</literal>列时不能区分的行被称为是<firstterm>同等行</firstterm>。
   定义的这四个排名函数（包括 <function>cume_dist</function>），对于对等组的所有行的答案相同。
  </para>

<!--==========================orignal english content==========================
  <para>
   Note that <function>first_value</function>, <function>last_value</function>, and
   <function>nth_value</function> consider only the rows within the <quote>window
   frame</quote>, which by default contains the rows from the start of the
   partition through the last peer of the current row.  This is
   likely to give unhelpful results for <function>last_value</function> and
   sometimes also <function>nth_value</function>.  You can redefine the frame by
   adding a suitable frame specification (<literal>RANGE</literal>,
   <literal>ROWS</literal> or <literal>GROUPS</literal>) to
   the <literal>OVER</literal> clause.
   See <xref linkend="syntax-window-functions"/> for more information
   about frame specifications.
  </para>
____________________________________________________________________________-->
  <para>
   注意<function>first_value</function>、<function>last_value</function>和<function>nth_value</function>只考虑<quote>窗口帧</quote>内的行，它默认情况下包含从分区的开始行直到当前行的最后一个同等行。
   这对<function>last_value</function>可能不会给出有用的结果，有时对<function>nth_value</function>也一样。
   你可以通过向<literal>OVER</literal>子句增加一个合适的帧声明（<literal>RANGE</literal>或<literal>GROUPS</literal>）来重定义帧。
   关于帧声明的更多信息请参考<xref linkend="syntax-window-functions"/>。
  </para>

<!--==========================orignal english content==========================
  <para>
   When an aggregate function is used as a window function, it aggregates
   over the rows within the current row's window frame.
   An aggregate used with <literal>ORDER BY</literal> and the default window frame
   definition produces a <quote>running sum</quote> type of behavior, which may or
   may not be what's wanted.  To obtain
   aggregation over the whole partition, omit <literal>ORDER BY</literal> or use
   <literal>ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING</literal>.
   Other frame specifications can be used to obtain other effects.
  </para>
____________________________________________________________________________-->
  <para>
   当一个聚集函数被用作窗口函数时，它将在当前行的窗口帧内的行上聚集。 
   一个使用<literal>ORDER BY</literal>和默认窗口帧定义的聚集产生一种<quote>运行时求和</quote>类型的行为，这可能是或者不是想要的结果。
   为了获取在整个分区上的聚集，忽略<literal>ORDER BY</literal>或者使用<literal>ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING</literal>。 
   其它窗口帧声明可以用来获得其它的效果。
  </para>

  <note>
<!--==========================orignal english content==========================
   <para>
    The SQL standard defines a <literal>RESPECT NULLS</literal> or
    <literal>IGNORE NULLS</literal> option for <function>lead</function>, <function>lag</function>,
    <function>first_value</function>, <function>last_value</function>, and
    <function>nth_value</function>.  This is not implemented in
    <productname>PostgreSQL</productname>: the behavior is always the
    same as the standard's default, namely <literal>RESPECT NULLS</literal>.
    Likewise, the standard's <literal>FROM FIRST</literal> or <literal>FROM LAST</literal>
    option for <function>nth_value</function> is not implemented: only the
    default <literal>FROM FIRST</literal> behavior is supported.  (You can achieve
    the result of <literal>FROM LAST</literal> by reversing the <literal>ORDER BY</literal>
    ordering.)
   </para>
____________________________________________________________________________-->
   <para>
    SQL 标准为<function>lead</function>、<function>lag</function>、<function>first_value</function>、<function>last_value</function>和<function>nth_value</function>定义了一个<literal>RESPECT NULLS</literal>或<literal>IGNORE NULLS</literal>选项。 
    这在<productname>PostgreSQL</productname>中没有实现：行为总是与标准的默认相同，即<literal>RESPECT NULLS</literal>。 
    同样，标准中用于<function>nth_value</function>的<literal>FROM FIRST</literal>或<literal>FROM LAST</literal>选项没有实现： 只有支持默认的<literal>FROM FIRST</literal>行为（你可以通过反转<literal>ORDER BY</literal>的排序达到<literal>FROM LAST</literal>的结果）。
   </para>
  </note>

 </sect1>

 <sect1 id="functions-subquery">
<!--==========================orignal english content==========================
  <title>Subquery Expressions</title>
____________________________________________________________________________-->
  <title>子查询表达式</title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>EXISTS</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>EXISTS</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>IN</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>IN</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>NOT IN</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>NOT IN</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>ANY</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>ANY</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>ALL</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>ALL</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>SOME</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>SOME</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>subquery</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>subquery</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   This section describes the <acronym>SQL</acronym>-compliant subquery
   expressions available in <productname>PostgreSQL</productname>.
   All of the expression forms documented in this section return
   Boolean (true/false) results.
  </para>
____________________________________________________________________________-->
  <para>
   本节描述<productname>PostgreSQL</productname>中可用的<acronym>SQL</acronym>兼容的子查询表达式。所有本节中成文的表达式都返回布尔值（真/假）结果。
  </para>

  <sect2 id="functions-subquery-exists">
<!--==========================orignal english content==========================
   <title><literal>EXISTS</literal></title>
____________________________________________________________________________-->
   <title><literal>EXISTS</literal></title>

<!--==========================orignal english content==========================
<synopsis>
EXISTS (<replaceable>subquery</replaceable>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
EXISTS (<replaceable>subquery</replaceable>)
</synopsis>

<!--==========================orignal english content==========================
  <para>
   The argument of <token>EXISTS</token> is an arbitrary <command>SELECT</command> statement,
   or <firstterm>subquery</firstterm>.  The
   subquery is evaluated to determine whether it returns any rows.
   If it returns at least one row, the result of <token>EXISTS</token> is
   <quote>true</quote>; if the subquery returns no rows, the result of <token>EXISTS</token>
   is <quote>false</quote>.
  </para>
____________________________________________________________________________-->
  <para>
   <token>EXISTS</token>的参数是一个任意的<command>SELECT</command>语句， 或者说<firstterm>子查询</firstterm>。系统对子查询进行运算以判断它是否返回行。如果它至少返回一行，那么<token>EXISTS</token>的结果就为<quote>真</quote>； 如果子查询没有返回行，那么<token>EXISTS</token>的结果是<quote>假</quote>。
  </para>

<!--==========================orignal english content==========================
  <para>
   The subquery can refer to variables from the surrounding query,
   which will act as constants during any one evaluation of the subquery.
  </para>
____________________________________________________________________________-->
  <para>
   子查询可以引用来自周围的查询的变量，这些变量在该子查询的任何一次计算中都起常量的作用。
  </para>

<!--==========================orignal english content==========================
  <para>
   The subquery will generally only be executed long enough to determine
   whether at least one row is returned, not all the way to completion.
   It is unwise to write a subquery that has side effects (such as
   calling sequence functions); whether the side effects occur
   might be unpredictable.
  </para>
____________________________________________________________________________-->
  <para>
   这个子查询通常只是运行到能判断它是否可以返回至少一行为止， 而不是等到全部结束。在这里写任何有副作用的子查询都是不明智的（例如调用序列函数）；这些副作用是否发生是很难判断的。
  </para>

<!--==========================orignal english content==========================
  <para>
   Since the result depends only on whether any rows are returned,
   and not on the contents of those rows, the output list of the
   subquery is normally unimportant.  A common coding convention is
   to write all <literal>EXISTS</literal> tests in the form
   <literal>EXISTS(SELECT 1 WHERE ...)</literal>.  There are exceptions to
   this rule however, such as subqueries that use <token>INTERSECT</token>.
  </para>
____________________________________________________________________________-->
  <para>
   因为结果只取决于是否会返回行，而不取决于这些行的内容， 所以这个子查询的输出列表通常是无关紧要的。一个常用的编码习惯是用<literal>EXISTS(SELECT 1 WHERE ...)</literal>的形式写所有的<literal>EXISTS</literal>测试。不过这条规则有例外，例如那些使用<token>INTERSECT</token>的子查询。
  </para>

<!--==========================orignal english content==========================
  <para>
   This simple example is like an inner join on <literal>col2</literal>, but
   it produces at most one output row for each <literal>tab1</literal> row,
   even if there are several matching <literal>tab2</literal> rows:
<screen>
SELECT col1
FROM tab1
WHERE EXISTS (SELECT 1 FROM tab2 WHERE col2 = tab1.col2);
</screen>
  </para>
____________________________________________________________________________-->
  <para>
   下面这个简单的例子类似在<literal>col2</literal>上的一次内联接，但是它为每个 <literal>tab1</literal>的行生成最多一个输出，即使存在多个匹配<literal>tab2</literal>的行也如此∶
<screen>
SELECT col1
FROM tab1
WHERE EXISTS (SELECT 1 FROM tab2 WHERE col2 = tab1.col2);
</screen>
  </para>
  </sect2>

  <sect2 id="functions-subquery-in">
<!--==========================orignal english content==========================
   <title><literal>IN</literal></title>
____________________________________________________________________________-->
   <title><literal>IN</literal></title>

<!--==========================orignal english content==========================
<synopsis>
<replaceable>expression</replaceable> IN (<replaceable>subquery</replaceable>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>expression</replaceable> IN (<replaceable>subquery</replaceable>)
</synopsis>

<!--==========================orignal english content==========================
  <para>
   The right-hand side is a parenthesized
   subquery, which must return exactly one column.  The left-hand expression
   is evaluated and compared to each row of the subquery result.
   The result of <token>IN</token> is <quote>true</quote> if any equal subquery row is found.
   The result is <quote>false</quote> if no equal row is found (including the
   case where the subquery returns no rows).
  </para>
____________________________________________________________________________-->
  <para>
   右手边是一个圆括弧括起来的子查询， 它必须正好只返回一个列。左手边表达式将被计算并与子查询结果逐行进行比较。 如果找到任何等于子查询行的情况，那么<token>IN</token>的结果就是<quote>真</quote>。 如果没有找到相等行，那么结果是<quote>假</quote>（包括子查询没有返回任何行的情况）。
  </para>

<!--==========================orignal english content==========================
  <para>
   Note that if the left-hand expression yields null, or if there are
   no equal right-hand values and at least one right-hand row yields
   null, the result of the <token>IN</token> construct will be null, not false.
   This is in accordance with SQL's normal rules for Boolean combinations
   of null values.
  </para>
____________________________________________________________________________-->
  <para>
   请注意如果左手边表达式得到空值，或者没有相等的右手边值， 并且至少有一个右手边行得到空值，那么<token>IN</token>结构的结果将是空值，而不是假。这个行为是遵照 SQL 处理空值的一般规则的。
  </para>

<!--==========================orignal english content==========================
  <para>
   As with <token>EXISTS</token>, it's unwise to assume that the subquery will
   be evaluated completely.
  </para>
____________________________________________________________________________-->
  <para>
   和<token>EXISTS</token>一样，假设子查询将被完成运行完全是不明智的。
  </para>

<!--==========================orignal english content==========================
<synopsis>
<replaceable>row_constructor</replaceable> IN (<replaceable>subquery</replaceable>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>row_constructor</replaceable> IN (<replaceable>subquery</replaceable>)
</synopsis>

<!--==========================orignal english content==========================
  <para>
   The left-hand side of this form of <token>IN</token> is a row constructor,
   as described in <xref linkend="sql-syntax-row-constructors"/>.
   The right-hand side is a parenthesized
   subquery, which must return exactly as many columns as there are
   expressions in the left-hand row.  The left-hand expressions are
   evaluated and compared row-wise to each row of the subquery result.
   The result of <token>IN</token> is <quote>true</quote> if any equal subquery row is found.
   The result is <quote>false</quote> if no equal row is found (including the
   case where the subquery returns no rows).
  </para>
____________________________________________________________________________-->
  <para>
   这种形式的<token>IN</token>的左手边是一个行构造器， 如<xref linkend="sql-syntax-row-constructors"/>中所述。 右手边是一个圆括弧子查询，它必须返回和左手边返回的行中表达式所构成的完全一样多的列。 左手边表达式将被计算并与子查询结果逐行进行比较。如果找到任意相等的子查询行，则<token>IN</token>的结果为<quote>真</quote>。如果没有找到相等行， 那么结果为<quote>假</quote>（包括子查询不返回行的情况）。
  </para>

<!--==========================orignal english content==========================
  <para>
   As usual, null values in the rows are combined per
   the normal rules of SQL Boolean expressions.  Two rows are considered
   equal if all their corresponding members are non-null and equal; the rows
   are unequal if any corresponding members are non-null and unequal;
   otherwise the result of that row comparison is unknown (null).
   If all the per-row results are either unequal or null, with at least one
   null, then the result of <token>IN</token> is null.
  </para>
____________________________________________________________________________-->
  <para>
   通常，表达式或者子查询行里的空值是按照 SQL 布尔表达式的一般规则进行组合的。 如果两个行对应的成员都非空并且相等，那么认为这两行相等；如果任意对应成员为非空且不等，那么这两行不等； 否则这样的行比较的结果是未知（空值）。如果所有行的结果要么是不等， 要么是空值，并且至少有一个空值，那么<token>IN</token>的结果是空值。
  </para>
  </sect2>

  <sect2 id="functions-subquery-notin">
<!--==========================orignal english content==========================
   <title><literal>NOT IN</literal></title>
____________________________________________________________________________-->
   <title><literal>NOT IN</literal></title>

<!--==========================orignal english content==========================
<synopsis>
<replaceable>expression</replaceable> NOT IN (<replaceable>subquery</replaceable>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>expression</replaceable> NOT IN (<replaceable>subquery</replaceable>)
</synopsis>

<!--==========================orignal english content==========================
  <para>
   The right-hand side is a parenthesized
   subquery, which must return exactly one column.  The left-hand expression
   is evaluated and compared to each row of the subquery result.
   The result of <token>NOT IN</token> is <quote>true</quote> if only unequal subquery rows
   are found (including the case where the subquery returns no rows).
   The result is <quote>false</quote> if any equal row is found.
  </para>
____________________________________________________________________________-->
  <para>
   右手边是一个用圆括弧包围的子查询，它必须返回正好一个列。左手边表达式将被计算并与子查询结果逐行进行比较。 如果只找到不相等的子查询行（包括子查询不返回行的情况），那么<token>NOT IN</token>的结果是<quote>真</quote>。 如果找到任何相等行，则结果为<quote>假</quote>。
  </para>

<!--==========================orignal english content==========================
  <para>
   Note that if the left-hand expression yields null, or if there are
   no equal right-hand values and at least one right-hand row yields
   null, the result of the <token>NOT IN</token> construct will be null, not true.
   This is in accordance with SQL's normal rules for Boolean combinations
   of null values.
  </para>
____________________________________________________________________________-->
  <para>
   请注意如果左手边表达式得到空值，或者没有相等的右手边值， 并且至少有一个右手边行得到空值，那么<token>NOT IN</token>结构的结果将是空值，而不是真。这个行为是遵照 SQL 处理空值的一般规则的。
  </para>

<!--==========================orignal english content==========================
  <para>
   As with <token>EXISTS</token>, it's unwise to assume that the subquery will
   be evaluated completely.
  </para>
____________________________________________________________________________-->
  <para>
   和<token>EXISTS</token>一样，假设子查询会完全结束是不明智的。
  </para>

<!--==========================orignal english content==========================
<synopsis>
<replaceable>row_constructor</replaceable> NOT IN (<replaceable>subquery</replaceable>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>row_constructor</replaceable> NOT IN (<replaceable>subquery</replaceable>)
</synopsis>

<!--==========================orignal english content==========================
  <para>
   The left-hand side of this form of <token>NOT IN</token> is a row constructor,
   as described in <xref linkend="sql-syntax-row-constructors"/>.
   The right-hand side is a parenthesized
   subquery, which must return exactly as many columns as there are
   expressions in the left-hand row.  The left-hand expressions are
   evaluated and compared row-wise to each row of the subquery result.
   The result of <token>NOT IN</token> is <quote>true</quote> if only unequal subquery rows
   are found (including the case where the subquery returns no rows).
   The result is <quote>false</quote> if any equal row is found.
  </para>
____________________________________________________________________________-->
  <para>
   这种形式的<token>NOT IN</token>的左手边是一个行构造器， 如<xref linkend="sql-syntax-row-constructors"/>中所述。 右手边是一个圆括弧子查询，它必须返回和左手边返回的行中表达式所构成的完全一样多的列。 左手边表达式将被计算并与子查询结果逐行进行比较。如果找到不等于子查询行的行，则<token>NOT IN</token>的结果为<quote>真</quote>。如果找到相等行， 那么结果为<quote>假</quote>（包括子查询不返回行的情况）。
  </para>

<!--==========================orignal english content==========================
  <para>
   As usual, null values in the rows are combined per
   the normal rules of SQL Boolean expressions.  Two rows are considered
   equal if all their corresponding members are non-null and equal; the rows
   are unequal if any corresponding members are non-null and unequal;
   otherwise the result of that row comparison is unknown (null).
   If all the per-row results are either unequal or null, with at least one
   null, then the result of <token>NOT IN</token> is null.
  </para>
____________________________________________________________________________-->
  <para>
   通常，表达式或者子查询行里的空值是按照 SQL 布尔表达式的一般规则进行组合的。 如果两个行对应的成员都非空并且相等，那么认为这两行相等；如果任意对应成员为非空且不等，那么这两行不等； 否则这样的行比较的结果是未知（空值）。如果所有行的结果要么是不等， 要么是空值，并且至少有一个空值，那么<token>NOT IN</token>的结果是空值。
  </para>
  </sect2>

  <sect2 id="functions-subquery-any-some">
<!--==========================orignal english content==========================
   <title><literal>ANY</literal>/<literal>SOME</literal></title>
____________________________________________________________________________-->
   <title><literal>ANY</literal>/<literal>SOME</literal></title>

<!--==========================orignal english content==========================
<synopsis>
<replaceable>expression</replaceable> <replaceable>operator</replaceable> ANY (<replaceable>subquery</replaceable>)
<replaceable>expression</replaceable> <replaceable>operator</replaceable> SOME (<replaceable>subquery</replaceable>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>expression</replaceable> <replaceable>operator</replaceable> ANY (<replaceable>subquery</replaceable>)
<replaceable>expression</replaceable> <replaceable>operator</replaceable> SOME (<replaceable>subquery</replaceable>)
</synopsis>

<!--==========================orignal english content==========================
  <para>
   The right-hand side is a parenthesized
   subquery, which must return exactly one column.  The left-hand expression
   is evaluated and compared to each row of the subquery result using the
   given <replaceable>operator</replaceable>, which must yield a Boolean
   result.
   The result of <token>ANY</token> is <quote>true</quote> if any true result is obtained.
   The result is <quote>false</quote> if no true result is found (including the
   case where the subquery returns no rows).
  </para>
____________________________________________________________________________-->
  <para>
   这种形式的右手边是一个圆括弧括起来的子查询， 它必须返回正好一个列。左手边表达式将被计算并使用给出的 <replaceable>操作符</replaceable>对子查询结果逐行进行比较。如果获得任何真值结果，那么<token>ANY</token>的结果就是<quote>真</quote>。 如果没有找到真值结果，那么结果是<quote>假</quote>（包括子查询没有返回任何行的情况）。
  </para>

<!--==========================orignal english content==========================
  <para>
   <token>SOME</token> is a synonym for <token>ANY</token>.
   <token>IN</token> is equivalent to <literal>= ANY</literal>.
  </para>
____________________________________________________________________________-->
  <para>
   <token>SOME</token>是<token>ANY</token>的同义词。<token>IN</token>等价于<literal>= ANY</literal>。
  </para>

<!--==========================orignal english content==========================
  <para>
   Note that if there are no successes and at least one right-hand row yields
   null for the operator's result, the result of the <token>ANY</token> construct
   will be null, not false.
   This is in accordance with SQL's normal rules for Boolean combinations
   of null values.
  </para>
____________________________________________________________________________-->
  <para>
   请注意如果没有任何成功并且至少有一个右手边行为该操作符结果生成空值， 那么<token>ANY</token>结构的结果将是空值，而不是假。 这个行为是遵照 SQL 处理空值布尔组合的一般规则制定的。
  </para>

<!--==========================orignal english content==========================
  <para>
   As with <token>EXISTS</token>, it's unwise to assume that the subquery will
   be evaluated completely.
  </para>
____________________________________________________________________________-->
  <para>
   和<token>EXISTS</token>一样，假设子查询将被完全运行是不明智的。
  </para>

<!--==========================orignal english content==========================
<synopsis>
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> ANY (<replaceable>subquery</replaceable>)
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> SOME (<replaceable>subquery</replaceable>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> ANY (<replaceable>subquery</replaceable>)
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> SOME (<replaceable>subquery</replaceable>)
</synopsis>

<!--==========================orignal english content==========================
  <para>
   The left-hand side of this form of <token>ANY</token> is a row constructor,
   as described in <xref linkend="sql-syntax-row-constructors"/>.
   The right-hand side is a parenthesized
   subquery, which must return exactly as many columns as there are
   expressions in the left-hand row.  The left-hand expressions are
   evaluated and compared row-wise to each row of the subquery result,
   using the given <replaceable>operator</replaceable>.
   The result of <token>ANY</token> is <quote>true</quote> if the comparison
   returns true for any subquery row.
   The result is <quote>false</quote> if the comparison returns false for every
   subquery row (including the case where the subquery returns no
   rows).
   The result is NULL if no comparison with a subquery row returns true,
   and at least one comparison returns NULL.
  </para>
____________________________________________________________________________-->
  <para>
   这种形式的左手边是一个行构造器，如<xref linkend="sql-syntax-row-constructors"/>所述。右手边是一个圆括弧括起来的子查询， 它必须返回和左手边列表给出的表达式一样多的列。左手边表达式将被计算并使用给出的<replaceable>操作符</replaceable>对子查询结果逐行进行比较。如果比较为任何子查询行返回真，则<token>ANY</token>的结果为<quote>真</quote>。如果比较对每一个子查询行都返回假，则结果为<quote>假</quote>（包括子查询不返回行的情况）。如果比较不对任何行返回真并且至少对一行返回 NULL，则结果为 NULL。
  </para>

<!--==========================orignal english content==========================
  <para>
   See <xref linkend="row-wise-comparison"/> for details about the meaning
   of a row constructor comparison.
  </para>
____________________________________________________________________________-->
  <para>
   关于行构造器比较的详细含义请见<xref linkend="row-wise-comparison"/>。
  </para>
  </sect2>

  <sect2 id="functions-subquery-all">
<!--==========================orignal english content==========================
   <title><literal>ALL</literal></title>
____________________________________________________________________________-->
   <title><literal>ALL</literal></title>

<!--==========================orignal english content==========================
<synopsis>
<replaceable>expression</replaceable> <replaceable>operator</replaceable> ALL (<replaceable>subquery</replaceable>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>expression</replaceable> <replaceable>operator</replaceable> ALL (<replaceable>subquery</replaceable>)
</synopsis>

<!--==========================orignal english content==========================
  <para>
   The right-hand side is a parenthesized
   subquery, which must return exactly one column.  The left-hand expression
   is evaluated and compared to each row of the subquery result using the
   given <replaceable>operator</replaceable>, which must yield a Boolean
   result.
   The result of <token>ALL</token> is <quote>true</quote> if all rows yield true
   (including the case where the subquery returns no rows).
   The result is <quote>false</quote> if any false result is found.
   The result is NULL if no comparison with a subquery row returns false,
   and at least one comparison returns NULL.
  </para>
____________________________________________________________________________-->
  <para>
   ALL 的这种形式的右手边是一个圆括弧括起来的子查询， 它必须只返回一列。左手边表达式将被计算并使用给出的 <replaceable>操作符</replaceable>对子查询结果逐行进行比较。该操作符必须生成布尔结果。 如果所有行得到真（包括子查询没有返回任何行的情况），<token>ALL</token>的结果就是<quote>真</quote>。如果没有存在任何假值结果，那么结果是<quote>假</quote>。如果比较为任何行都不返回假并且对至少一行返回 NULL，则结果为 NULL。
  </para>

<!--==========================orignal english content==========================
  <para>
   <token>NOT IN</token> is equivalent to <literal>&lt;&gt; ALL</literal>.
  </para>
____________________________________________________________________________-->
  <para>
   <token>NOT IN</token>等价于<literal>&lt;&gt; ALL</literal>。
  </para>

<!--==========================orignal english content==========================
  <para>
   As with <token>EXISTS</token>, it's unwise to assume that the subquery will
   be evaluated completely.
  </para>
____________________________________________________________________________-->
  <para>
   和<token>EXISTS</token>一样，假设子查询将被完全运行是不明智的。
  </para>

<!--==========================orignal english content==========================
<synopsis>
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> ALL (<replaceable>subquery</replaceable>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> ALL (<replaceable>subquery</replaceable>)
</synopsis>

<!--==========================orignal english content==========================
  <para>
   The left-hand side of this form of <token>ALL</token> is a row constructor,
   as described in <xref linkend="sql-syntax-row-constructors"/>.
   The right-hand side is a parenthesized
   subquery, which must return exactly as many columns as there are
   expressions in the left-hand row.  The left-hand expressions are
   evaluated and compared row-wise to each row of the subquery result,
   using the given <replaceable>operator</replaceable>.
   The result of <token>ALL</token> is <quote>true</quote> if the comparison
   returns true for all subquery rows (including the
   case where the subquery returns no rows).
   The result is <quote>false</quote> if the comparison returns false for any
   subquery row.
   The result is NULL if no comparison with a subquery row returns false,
   and at least one comparison returns NULL.
  </para>
____________________________________________________________________________-->
  <para>
   <token>ALL</token>的这种形式的左手边是一个行构造器，如<xref linkend="sql-syntax-row-constructors"/>所述。 右手边是一个圆括弧括起来的子查询，它必须返回和左手边行中表达式一样多的列。 左手边表达式将被计算并使用给出的 <replaceable>操作符</replaceable>对子查询结果逐行进行比较。如果对所有子查询行该比较都返回真，那么<token>ALL</token>的结果就是<quote>真</quote>（包括子查询没有返回任何行的情况）。如果对任何子查询行比较返回假，则结果为<quote>假</quote>。如果比较对任何子查询行都不返回假并且对至少一行返回 NULL，则结果为 NULL。
  </para>

<!--==========================orignal english content==========================
  <para>
   See <xref linkend="row-wise-comparison"/> for details about the meaning
   of a row constructor comparison.
  </para>
____________________________________________________________________________-->
  <para>
   关于行构造器比较的详细含义请见<xref linkend="row-wise-comparison"/>。
  </para>
  </sect2>

  <sect2>
<!--==========================orignal english content==========================
   <title>Single-Row Comparison</title>
____________________________________________________________________________-->
   <title>单一行比较</title>

<!--==========================orignal english content==========================
   <indexterm zone="functions-subquery">
    <primary>comparison</primary>
    <secondary>subquery result row</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="functions-subquery">
    <primary>比较</primary>
    <secondary>子查询结果行</secondary>
   </indexterm>

<!--==========================orignal english content==========================
<synopsis>
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> (<replaceable>subquery</replaceable>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> (<replaceable>subquery</replaceable>)
</synopsis>

<!--==========================orignal english content==========================
  <para>
   The left-hand side is a row constructor,
   as described in <xref linkend="sql-syntax-row-constructors"/>.
   The right-hand side is a parenthesized subquery, which must return exactly
   as many columns as there are expressions in the left-hand row. Furthermore,
   the subquery cannot return more than one row.  (If it returns zero rows,
   the result is taken to be null.)  The left-hand side is evaluated and
   compared row-wise to the single subquery result row.
  </para>
____________________________________________________________________________-->
  <para>
   左手边是一个行构造器，如<xref linkend="sql-syntax-row-constructors"/>所述。 右手边是一个圆括弧括起来的子查询，该查询必须返回和左手边行中表达式数目完全一样的列。 另外，该子查询不能返回超过一行的数量（如果它返回零行，那么结果就是空值）。 左手边被计算并逐行与右手边的子查询结果行比较。
  </para>

<!--==========================orignal english content==========================
  <para>
   See <xref linkend="row-wise-comparison"/> for details about the meaning
   of a row constructor comparison.
  </para>
____________________________________________________________________________-->
  <para>
   关于行构造器比较的详细含义请见<xref linkend="row-wise-comparison"/>。
  </para>
  </sect2>
 </sect1>


 <sect1 id="functions-comparisons">
<!--==========================orignal english content==========================
  <title>Row and Array Comparisons</title>
____________________________________________________________________________-->
  <title>行和数组比较</title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>IN</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>IN</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>NOT IN</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>NOT IN</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>ANY</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>ANY</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>ALL</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>ALL</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>SOME</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>SOME</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>composite type</primary>
   <secondary>comparison</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>组合类型</primary>
   <secondary>比较</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>row-wise comparison</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>逐行比较</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>comparison</primary>
   <secondary>composite type</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>比较</primary>
   <secondary>逐行</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>comparison</primary>
   <secondary>row constructor</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>比较</primary>
   <secondary>行构造器</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>IS DISTINCT FROM</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>IS DISTINCT FROM</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>IS NOT DISTINCT FROM</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>IS NOT DISTINCT FROM</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   This section describes several specialized constructs for making
   multiple comparisons between groups of values.  These forms are
   syntactically related to the subquery forms of the previous section,
   but do not involve subqueries.
   The forms involving array subexpressions are
   <productname>PostgreSQL</productname> extensions; the rest are
   <acronym>SQL</acronym>-compliant.
   All of the expression forms documented in this section return
   Boolean (true/false) results.
  </para>
____________________________________________________________________________-->
  <para>
   本节描述几个特殊的结构，用于在值的组之间进行多重比较。这些形式语法上和前面一节的子查询形式相关，但是不涉及子查询。 这种形式涉及的数组子表达式是<productname>PostgreSQL</productname>的扩展； 其它的是<acronym>SQL</acronym>兼容的。所有本节记录的表达式形式都返回布尔（Boolean）结果（真/假）。
  </para>

  <sect2 id="functions-comparisons-in-scalar">
<!--==========================orignal english content==========================
   <title><literal>IN</literal></title>
____________________________________________________________________________-->
   <title><literal>IN</literal></title>

<!--==========================orignal english content==========================
<synopsis>
<replaceable>expression</replaceable> IN (<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>expression</replaceable> IN (<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>

<!--==========================orignal english content==========================
  <para>
   The right-hand side is a parenthesized list
   of scalar expressions.  The result is <quote>true</quote> if the left-hand expression's
   result is equal to any of the right-hand expressions.  This is a shorthand
   notation for

<synopsis>
<replaceable>expression</replaceable> = <replaceable>value1</replaceable>
OR
<replaceable>expression</replaceable> = <replaceable>value2</replaceable>
OR
...
</synopsis>
  </para>
____________________________________________________________________________-->
  <para>
   右手边是一个圆括弧包围的标量列表。如果左手边表达式的结果等于任何右手边表达式中的一个，结果为<quote>真</quote>。它是下面形式的缩写

<synopsis>
<replaceable>expression</replaceable> = <replaceable>value1</replaceable>
OR
<replaceable>expression</replaceable> = <replaceable>value2</replaceable>
OR
...
</synopsis>
  </para>

<!--==========================orignal english content==========================
  <para>
   Note that if the left-hand expression yields null, or if there are
   no equal right-hand values and at least one right-hand expression yields
   null, the result of the <token>IN</token> construct will be null, not false.
   This is in accordance with SQL's normal rules for Boolean combinations
   of null values.
  </para>
____________________________________________________________________________-->
  <para>
   请注意如果左手边表达式得到空值，或者没有相等的右手边值并且至少有一个右手边的表达式得到空值，那么<token>IN</token>结构的结果将为空值，而不是假。这符合 SQL 处理空值的布尔组合的一般规则。
  </para>
  </sect2>

  <sect2>
<!--==========================orignal english content==========================
   <title><literal>NOT IN</literal></title>
____________________________________________________________________________-->
   <title><literal>NOT IN</literal></title>

<!--==========================orignal english content==========================
<synopsis>
<replaceable>expression</replaceable> NOT IN (<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>expression</replaceable> NOT IN (<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>

<!--==========================orignal english content==========================
  <para>
   The right-hand side is a parenthesized list
   of scalar expressions.  The result is <quote>true</quote> if the left-hand expression's
   result is unequal to all of the right-hand expressions.  This is a shorthand
   notation for

<synopsis>
<replaceable>expression</replaceable> &lt;&gt; <replaceable>value1</replaceable>
AND
<replaceable>expression</replaceable> &lt;&gt; <replaceable>value2</replaceable>
AND
...
</synopsis>
  </para>
____________________________________________________________________________-->
  <para>
   右手边是一个圆括弧包围的标量列表。如果左手边表达式的结果不等于所有右手边表达式，结果为<quote>真</quote>。它是下面形式的缩写

<synopsis>
<replaceable>expression</replaceable> &lt;&gt; <replaceable>value1</replaceable>
AND
<replaceable>expression</replaceable> &lt;&gt; <replaceable>value2</replaceable>
AND
...
</synopsis>
  </para>

<!--==========================orignal english content==========================
  <para>
   Note that if the left-hand expression yields null, or if there are
   no equal right-hand values and at least one right-hand expression yields
   null, the result of the <token>NOT IN</token> construct will be null, not true
   as one might naively expect.
   This is in accordance with SQL's normal rules for Boolean combinations
   of null values.
  </para>
____________________________________________________________________________-->
  <para>
   请注意如果左手边表达式得到空值，或者没有相等的右手边值并且至少有一个右手边的表达式得到空值，那么<token>NOT IN</token>结构的结果将为空值， 而不是我们可能天真地认为的真值。这符合 SQL 处理空值的布尔组合的一般规则。
  </para>

  <tip>
<!--==========================orignal english content==========================
  <para>
   <literal>x NOT IN y</literal> is equivalent to <literal>NOT (x IN y)</literal> in all
   cases.  However, null values are much more likely to trip up the novice when
   working with <token>NOT IN</token> than when working with <token>IN</token>.
   It is best to express your condition positively if possible.
  </para>
____________________________________________________________________________-->
  <para>
   <literal>x NOT IN y</literal>在所有情况下都等效于<literal>NOT (x IN y)</literal>。但是，在处理空值的时候，用<token>NOT IN</token>比用<token>IN</token>更可能迷惑新手。最好尽可能用正逻辑来表达你的条件。
  </para>
  </tip>
  </sect2>

  <sect2>
<!--==========================orignal english content==========================
   <title><literal>ANY</literal>/<literal>SOME</literal> (array)</title>
____________________________________________________________________________-->
   <title><literal>ANY</literal>/<literal>SOME</literal> (array)</title>

<!--==========================orignal english content==========================
<synopsis>
<replaceable>expression</replaceable> <replaceable>operator</replaceable> ANY (<replaceable>array expression</replaceable>)
<replaceable>expression</replaceable> <replaceable>operator</replaceable> SOME (<replaceable>array expression</replaceable>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>expression</replaceable> <replaceable>operator</replaceable> ANY (<replaceable>array expression</replaceable>)
<replaceable>expression</replaceable> <replaceable>operator</replaceable> SOME (<replaceable>array expression</replaceable>)
</synopsis>

<!--==========================orignal english content==========================
  <para>
   The right-hand side is a parenthesized expression, which must yield an
   array value.
   The left-hand expression
   is evaluated and compared to each element of the array using the
   given <replaceable>operator</replaceable>, which must yield a Boolean
   result.
   The result of <token>ANY</token> is <quote>true</quote> if any true result is obtained.
   The result is <quote>false</quote> if no true result is found (including the
   case where the array has zero elements).
  </para>
____________________________________________________________________________-->
  <para>
   右手边是一个圆括弧包围的表达式，它必须得到一个数组值。左手边表达式被计算并且使用给出的<replaceable>操作符</replaceable>对数组的每个元素进行比较，这个操作符必须得到布尔结果。如果得到了任何真值结果，那么<token>ANY</token>的结果是<quote>真</quote>。 如果没有找到真值结果（包括数组只有零个元素的情况），那么结果是<quote>假</quote>。
  </para>

<!--==========================orignal english content==========================
  <para>
   If the array expression yields a null array, the result of
   <token>ANY</token> will be null.  If the left-hand expression yields null,
   the result of <token>ANY</token> is ordinarily null (though a non-strict
   comparison operator could possibly yield a different result).
   Also, if the right-hand array contains any null elements and no true
   comparison result is obtained, the result of <token>ANY</token>
   will be null, not false (again, assuming a strict comparison operator).
   This is in accordance with SQL's normal rules for Boolean combinations
   of null values.
  </para>
____________________________________________________________________________-->
  <para>
   如果数组表达式得到一个空数组，<token>ANY</token>的结果将为空值。如果左手边的表达式得到空值，<token>ANY</token>通常是空值（尽管一个非严格比较操作符可能得到一个不同的结果）。另外，如果右手边的数组包含任何空值元素或者没有得到真值比较结果，<token>ANY</token>的结果将是空值而不是假（再次，假设是一个严格的比较操作符）。这符合 SQL 对空值的布尔组合的一般规则。
  </para>

<!--==========================orignal english content==========================
  <para>
   <token>SOME</token> is a synonym for <token>ANY</token>.
  </para>
____________________________________________________________________________-->
  <para>
   <token>SOME</token>是<token>ANY</token>的同义词。
  </para>
  </sect2>

  <sect2>
<!--==========================orignal english content==========================
   <title><literal>ALL</literal> (array)</title>
____________________________________________________________________________-->
   <title><literal>ALL</literal> (array)</title>

<!--==========================orignal english content==========================
<synopsis>
<replaceable>expression</replaceable> <replaceable>operator</replaceable> ALL (<replaceable>array expression</replaceable>)
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>expression</replaceable> <replaceable>operator</replaceable> ALL (<replaceable>array expression</replaceable>)
</synopsis>

<!--==========================orignal english content==========================
  <para>
   The right-hand side is a parenthesized expression, which must yield an
   array value.
   The left-hand expression
   is evaluated and compared to each element of the array using the
   given <replaceable>operator</replaceable>, which must yield a Boolean
   result.
   The result of <token>ALL</token> is <quote>true</quote> if all comparisons yield true
   (including the case where the array has zero elements).
   The result is <quote>false</quote> if any false result is found.
  </para>
____________________________________________________________________________-->
  <para>
   右手边是一个圆括弧包围的表达式，它必须得到一个数组值。左手边表达式将被计算并使用给出的<replaceable>操作符</replaceable>与数组的每个元素进行比较，这个操作符必须得到一个布尔结果。如果所有比较都得到真值结果，那么<token>ALL</token>的结果是 <quote>真</quote>（包括数组只有零个元素的情况）。如果有任何假值结果，那么结果是<quote>假</quote>。
  </para>

<!--==========================orignal english content==========================
  <para>
   If the array expression yields a null array, the result of
   <token>ALL</token> will be null.  If the left-hand expression yields null,
   the result of <token>ALL</token> is ordinarily null (though a non-strict
   comparison operator could possibly yield a different result).
   Also, if the right-hand array contains any null elements and no false
   comparison result is obtained, the result of <token>ALL</token>
   will be null, not true (again, assuming a strict comparison operator).
   This is in accordance with SQL's normal rules for Boolean combinations
   of null values.
  </para>
____________________________________________________________________________-->
  <para>
   如果数组表达式得到一个空数组，<token>ALL</token>的结果将为空值。如果左手边的表达式得到空值，<token>ALL</token>通常是空值（尽管一个非严格比较操作符可能得到一个不同的结果）。另外，如果右手边的数组包含任何空值元素或者没有得到假值比较结果，<token>ALL</token>的结果将是空值而不是真（再次，假设是一个严格的比较操作符）。这符合 SQL 对空值的布尔组合的一般规则。
  </para>
  </sect2>

  <sect2 id="row-wise-comparison">
<!--==========================orignal english content==========================
   <title>Row Constructor Comparison</title>
____________________________________________________________________________-->
   <title>行构造器比较</title>

<!--==========================orignal english content==========================
<synopsis>
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> <replaceable>row_constructor</replaceable>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> <replaceable>row_constructor</replaceable>
</synopsis>

<!--==========================orignal english content==========================
  <para>
   Each side is a row constructor,
   as described in <xref linkend="sql-syntax-row-constructors"/>.
   The two row values must have the same number of fields.
   Each side is evaluated and they are compared row-wise.  Row constructor
   comparisons are allowed when the <replaceable>operator</replaceable> is
   <literal>=</literal>,
   <literal>&lt;&gt;</literal>,
   <literal>&lt;</literal>,
   <literal>&lt;=</literal>,
   <literal>&gt;</literal> or
   <literal>&gt;=</literal>.
   Every row element must be of a type which has a default B-tree operator
   class or the attempted comparison may generate an error.
  </para>
____________________________________________________________________________-->
  <para>
   每一边都是一个行构造器，如<xref linkend="sql-syntax-row-constructors"/>所述。两个行值必须具有相同数量的域。每一边被计算并且被逐行比较。当<replaceable>操作符</replaceable>是
   <literal>=</literal>、
   <literal>&lt;&gt;</literal>、
   <literal>&lt;</literal>
   <literal>&lt;=</literal>、
   <literal>&gt;</literal>、
   <literal>&gt;=</literal>时，允许进行行构造器比较。每一个行元素必须是具有一个默认 B 树操作符类的类型，否则尝试比较会产生一个错误。
  </para>

  <note>
<!--==========================orignal english content==========================
   <para>
    Errors related to the number or types of elements might not occur if
    the comparison is resolved using earlier columns.
   </para>
____________________________________________________________________________-->
   <para>
    Errors related to the number or types of elements might not occur if
    the comparison is resolved using earlier columns.
   </para>
  </note>

<!--==========================orignal english content==========================
  <para>
   The <literal>=</literal> and <literal>&lt;&gt;</literal> cases work slightly differently
   from the others.  Two rows are considered
   equal if all their corresponding members are non-null and equal; the rows
   are unequal if any corresponding members are non-null and unequal;
   otherwise the result of the row comparison is unknown (null).
  </para>
____________________________________________________________________________-->
  <para>
   <literal>=</literal>和<literal>&lt;&gt;</literal>情况略有不同。如果两行的所有对应成员都是非空且相等则这两行被认为相等；如果任何对应成员是非空但是不相等则这两行不相等；否则行比较的结果为未知（空值）。
  </para>

<!--==========================orignal english content==========================
  <para>
   For the <literal>&lt;</literal>, <literal>&lt;=</literal>, <literal>&gt;</literal> and
   <literal>&gt;=</literal> cases, the row elements are compared left-to-right,
   stopping as soon as an unequal or null pair of elements is found.
   If either of this pair of elements is null, the result of the
   row comparison is unknown (null); otherwise comparison of this pair
   of elements determines the result.  For example,
   <literal>ROW(1,2,NULL) &lt; ROW(1,3,0)</literal>
   yields true, not null, because the third pair of elements are not
   considered.
  </para>
____________________________________________________________________________-->
  <para>
   对于<literal>&lt;</literal>、<literal>&lt;=</literal>、<literal>&gt;</literal>和<literal>&gt;=</literal>情况，行元素被从左至右比较，在找到一处不等的或为空的元素对就立刻停下来。如果这一对元素都为空值，则行比较的结果为未知（空值）；否则这一对元素的比较结果决定行比较的结果。例如，<literal>ROW(1,2,NULL) &lt; ROW(1,3,0)</literal>得到真，而不是空值，因为第三对元素并没有被考虑。
  </para>

  <note>
<!--==========================orignal english content==========================
   <para>
    Prior to <productname>PostgreSQL</productname> 8.2, the
    <literal>&lt;</literal>, <literal>&lt;=</literal>, <literal>&gt;</literal> and <literal>&gt;=</literal>
    cases were not handled per SQL specification.  A comparison like
    <literal>ROW(a,b) &lt; ROW(c,d)</literal>
    was implemented as
    <literal>a &lt; c AND b &lt; d</literal>
    whereas the correct behavior is equivalent to
    <literal>a &lt; c OR (a = c AND b &lt; d)</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    在<productname>PostgreSQL</productname> 8.2之前，<literal>&lt;</literal>、<literal>&lt;=</literal>、<literal>&gt;</literal>和<literal>&gt;=</literal>情况不是按照每个 SQL 声明来处理的。一个像<literal>ROW(a,b) &lt; ROW(c,d)</literal>的比较会被实现为<literal>a &lt; c AND b &lt; d</literal>，而结果行为等价于<literal>a &lt; c OR (a = c AND b &lt; d)</literal>。
   </para>
  </note>

<!--==========================orignal english content==========================
<synopsis>
<replaceable>row_constructor</replaceable> IS DISTINCT FROM <replaceable>row_constructor</replaceable>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>row_constructor</replaceable> IS DISTINCT FROM <replaceable>row_constructor</replaceable>
</synopsis>

<!--==========================orignal english content==========================
  <para>
   This construct is similar to a <literal>&lt;&gt;</literal> row comparison,
   but it does not yield null for null inputs.  Instead, any null value is
   considered unequal to (distinct from) any non-null value, and any two
   nulls are considered equal (not distinct).  Thus the result will
   either be true or false, never null.
  </para>
____________________________________________________________________________-->
  <para>
   这个结构与<literal>&lt;&gt;</literal>行比较相似，但是它对于空值输入不会得到空值。任何空值被认为和任何非空值不相等（有区别），并且任意两个空值被认为相等（无区别）。因此结果将总是为真或为假，永远不会是空值。
  </para>

<!--==========================orignal english content==========================
<synopsis>
<replaceable>row_constructor</replaceable> IS NOT DISTINCT FROM <replaceable>row_constructor</replaceable>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>row_constructor</replaceable> IS NOT DISTINCT FROM <replaceable>row_constructor</replaceable>
</synopsis>

<!--==========================orignal english content==========================
  <para>
   This construct is similar to a <literal>=</literal> row comparison,
   but it does not yield null for null inputs.  Instead, any null value is
   considered unequal to (distinct from) any non-null value, and any two
   nulls are considered equal (not distinct).  Thus the result will always
   be either true or false, never null.
  </para>
____________________________________________________________________________-->
  <para>
   这个结构与<literal>=</literal>行比较相似，但是它对于空值输入不会得到空值。任何空值被认为和任何非空值不相等（有区别），并且任意两个空值被认为相等（无区别）。因此结果将总是为真或为假，永远不会是空值。
  </para>

  </sect2>

  <sect2 id="composite-type-comparison">
<!--==========================orignal english content==========================
   <title>Composite Type Comparison</title>
____________________________________________________________________________-->
   <title>组合类型比较</title>

<!--==========================orignal english content==========================
<synopsis>
<replaceable>record</replaceable> <replaceable>operator</replaceable> <replaceable>record</replaceable>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<replaceable>record</replaceable> <replaceable>operator</replaceable> <replaceable>record</replaceable>
</synopsis>

<!--==========================orignal english content==========================
  <para>
   The SQL specification requires row-wise comparison to return NULL if the
   result depends on comparing two NULL values or a NULL and a non-NULL.
   <productname>PostgreSQL</productname> does this only when comparing the
   results of two row constructors (as in
   <xref linkend="row-wise-comparison"/>) or comparing a row constructor
   to the output of a subquery (as in <xref linkend="functions-subquery"/>).
   In other contexts where two composite-type values are compared, two
   NULL field values are considered equal, and a NULL is considered larger
   than a non-NULL.  This is necessary in order to have consistent sorting
   and indexing behavior for composite types.
  </para>
____________________________________________________________________________-->
  <para>
    SQL 规范要求在结果依赖于比较两个 NULL 值或者一个 NULL 与一个非 NULL 时逐行比较返回 NULL。<productname>PostgreSQL</productname>只有在比较两个行构造器（如<xref linkend="row-wise-comparison"/>）的结果或者比较一个行构造器与一个子查询的输出时才这样做（如<xref linkend="functions-subquery"/>中所述）。在其他比较两个组合类型值的环境中，两个 NULL 域值被认为相等，并且一个 NULL 被认为大于一个非 NULL。为了得到组合类型的一致的排序和索引行为，这样做是必要的。
  </para>
   
<!--==========================orignal english content==========================
  <para>
   Each side is evaluated and they are compared row-wise.  Composite type
   comparisons are allowed when the <replaceable>operator</replaceable> is
   <literal>=</literal>,
   <literal>&lt;&gt;</literal>,
   <literal>&lt;</literal>,
   <literal>&lt;=</literal>,
   <literal>&gt;</literal> or
   <literal>&gt;=</literal>,
   or has semantics similar to one of these.  (To be specific, an operator
   can be a row comparison operator if it is a member of a B-tree operator
   class, or is the negator of the <literal>=</literal> member of a B-tree operator
   class.)  The default behavior of the above operators is the same as for
   <literal>IS [ NOT ] DISTINCT FROM</literal> for row constructors (see
   <xref linkend="row-wise-comparison"/>).
  </para>
____________________________________________________________________________-->
  <para>
   每一边都会被计算并且它们会被逐行比较。当<replaceable>操作符</replaceable>是
   <literal>=</literal>、
   <literal>&lt;&gt;</literal>、
   <literal>&lt;</literal>、
   <literal>&lt;=</literal>、
   <literal>&gt;</literal>或者
   <literal>&gt;=</literal>时或者具有与这些类似的语义时，允许组合类型的比较（更准确地说，如果一个操作符是一个 B 树操作符类的成员，或者是一个 B 树操作符类的<literal>=</literal>成员的否定词，它就可以是一个行比较操作符）。
   上述操作符的行为与用于行构造器（见<xref linkend="row-wise-comparison"/>）的<literal>IS [ NOT ] DISTINCT FROM</literal>相同。
  </para>

<!--==========================orignal english content==========================
  <para>
   To support matching of rows which include elements without a default
   B-tree operator class, the following operators are defined for composite
   type comparison:
   <literal>*=</literal>,
   <literal>*&lt;&gt;</literal>,
   <literal>*&lt;</literal>,
   <literal>*&lt;=</literal>,
   <literal>*&gt;</literal>, and
   <literal>*&gt;=</literal>.
   These operators compare the internal binary representation of the two
   rows.  Two rows might have a different binary representation even
   though comparisons of the two rows with the equality operator is true.
   The ordering of rows under these comparison operators is deterministic
   but not otherwise meaningful.  These operators are used internally
   for materialized views and might be useful for other specialized
   purposes such as replication and B-Tree deduplication (see <xref
   linkend="btree-deduplication"/>).  They are not intended to be
   generally useful for writing queries, though.
  </para>
____________________________________________________________________________-->
  <para>
   为了支持包含无默认 B 树操作符类的元素的行匹配，为组合类型比较定义了下列操作符：
   <literal>*=</literal>、
   <literal>*&lt;&gt;</literal>、
   <literal>*&lt;</literal>、
   <literal>*&lt;=</literal>、
   <literal>*&gt;</literal>以及
   <literal>*&gt;=</literal>。
   这些操作符比较两行的内部二进制表达。即使两行用相等操作符的比较为真，两行也可能具有不同的二进制表达。
   行在这些比较操作符之下的排序是决定性的，其他倒没什么意义。
   这些操作符在内部被用于物化视图并且可能对其他如复制和B-树复制(参见 <xref linkend="btree-deduplication"/>)之类的特殊功能有用，但是它们并不打算用在书写查询这类普通用途中。
  </para>

  </sect2>
 </sect1>

 <sect1 id="functions-srf">
<!--==========================orignal english content==========================
  <title>Set Returning Functions</title>
____________________________________________________________________________-->
  <title>集合返回函数</title>

<!--==========================orignal english content==========================
  <indexterm zone="functions-srf">
   <primary>set returning functions</primary>
   <secondary>functions</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="functions-srf">
   <primary>集合返回函数</primary>
   <secondary>函数</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   This section describes functions that possibly return more than one row.
   The most widely used functions in this class are series generating
   functions, as detailed in <xref linkend="functions-srf-series"/> and
   <xref linkend="functions-srf-subscripts"/>.  Other, more specialized
   set-returning functions are described elsewhere in this manual.
   See <xref linkend="queries-tablefunctions"/> for ways to combine multiple
   set-returning functions.
  </para>
____________________________________________________________________________-->
  <para>
   本节描述那些可能返回多于一行的函数。目前这个类中被使用最广泛的是级数生成函数， 如<xref linkend="functions-srf-series"/>和<xref linkend="functions-srf-subscripts"/>所述。其他更特殊的集合返回函数在本手册的其他地方描述。
   组合多集合返回函数的方法可见<xref linkend="queries-tablefunctions"/>。
  </para>

   <table id="functions-srf-series">
<!--==========================orignal english content==========================
    <title>Series Generating Functions</title>
____________________________________________________________________________-->
    <title>系列生成函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>generate_series</primary>
        </indexterm>
        <function>generate_series</function> ( <parameter>start</parameter> <type>integer</type>, <parameter>stop</parameter> <type>integer</type> <optional>, <parameter>step</parameter> <type>integer</type> </optional> )
        <returnvalue>setof integer</returnvalue>
       </para>
       <para role="func_signature">
        <function>generate_series</function> ( <parameter>start</parameter> <type>bigint</type>, <parameter>stop</parameter> <type>bigint</type> <optional>, <parameter>step</parameter> <type>bigint</type> </optional> )
        <returnvalue>setof bigint</returnvalue>
       </para>
       <para role="func_signature">
        <function>generate_series</function> ( <parameter>start</parameter> <type>numeric</type>, <parameter>stop</parameter> <type>numeric</type> <optional>, <parameter>step</parameter> <type>numeric</type> </optional> )
        <returnvalue>setof numeric</returnvalue>
       </para>
       <para>
        Generates a series of values from <parameter>start</parameter>
        to <parameter>stop</parameter>, with a step size
        of <parameter>step</parameter>.  <parameter>step</parameter>
        defaults to 1.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>generate_series</primary>
        </indexterm>
        <function>generate_series</function> ( <parameter>start</parameter> <type>integer</type>, <parameter>stop</parameter> <type>integer</type> <optional>, <parameter>step</parameter> <type>integer</type> </optional> )
        <returnvalue>setof integer</returnvalue>
       </para>
       <para role="func_signature">
        <function>generate_series</function> ( <parameter>start</parameter> <type>bigint</type>, <parameter>stop</parameter> <type>bigint</type> <optional>, <parameter>step</parameter> <type>bigint</type> </optional> )
        <returnvalue>setof bigint</returnvalue>
       </para>
       <para role="func_signature">
        <function>generate_series</function> ( <parameter>start</parameter> <type>numeric</type>, <parameter>stop</parameter> <type>numeric</type> <optional>, <parameter>step</parameter> <type>numeric</type> </optional> )
        <returnvalue>setof numeric</returnvalue>
       </para>
       <para>
        从<parameter>start</parameter>到<parameter>stop</parameter>生成一系列的值，步长为<parameter>step</parameter>。 <parameter>step</parameter>默认为1。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>generate_series</function> ( <parameter>start</parameter> <type>timestamp</type>, <parameter>stop</parameter> <type>timestamp</type>, <parameter>step</parameter> <type>interval</type> )
        <returnvalue>setof timestamp</returnvalue>
       </para>
       <para role="func_signature">
        <function>generate_series</function> ( <parameter>start</parameter> <type>timestamp with time zone</type>, <parameter>stop</parameter> <type>timestamp with time zone</type>, <parameter>step</parameter> <type>interval</type> )
        <returnvalue>setof timestamp with time zone</returnvalue>
       </para>
       <para>
        Generates a series of values from <parameter>start</parameter>
        to <parameter>stop</parameter>, with a step size
        of <parameter>step</parameter>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>generate_series</function> ( <parameter>start</parameter> <type>timestamp</type>, <parameter>stop</parameter> <type>timestamp</type>, <parameter>step</parameter> <type>interval</type> )
        <returnvalue>setof timestamp</returnvalue>
       </para>
       <para role="func_signature">
        <function>generate_series</function> ( <parameter>start</parameter> <type>timestamp with time zone</type>, <parameter>stop</parameter> <type>timestamp with time zone</type>, <parameter>step</parameter> <type>interval</type> )
        <returnvalue>setof timestamp with time zone</returnvalue>
       </para>
       <para>
        从<parameter>start</parameter>到<parameter>stop</parameter>生成一系列的值，步长为<parameter>step</parameter>。
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
  <para>
   When <parameter>step</parameter> is positive, zero rows are returned if
   <parameter>start</parameter> is greater than <parameter>stop</parameter>.
   Conversely, when <parameter>step</parameter> is negative, zero rows are
   returned if <parameter>start</parameter> is less than <parameter>stop</parameter>.
   Zero rows are also returned if any input is <literal>NULL</literal>.
   It is an error
   for <parameter>step</parameter> to be zero. Some examples follow:
<programlisting>
SELECT * FROM generate_series(2,4);
 generate_series
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
               2
               3
               4
(3 rows)

SELECT * FROM generate_series(5,1,-2);
 generate_series
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
               5
               3
               1
(3 rows)

SELECT * FROM generate_series(4,3);
 generate_series
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
(0 rows)

SELECT generate_series(1.1, 4, 1.3);
 generate_series
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
             1.1
             2.4
             3.7
(3 rows)

-&minus; this example relies on the date-plus-integer operator:
SELECT current_date + s.a AS dates FROM generate_series(0,14,7) AS s(a);
   dates
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 2004-02-05
 2004-02-12
 2004-02-19
(3 rows)

SELECT * FROM generate_series('2008-03-01 00:00'::timestamp,
                              '2008-03-04 12:00', '10 hours');
   generate_series
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 2008-03-01 00:00:00
 2008-03-01 10:00:00
 2008-03-01 20:00:00
 2008-03-02 06:00:00
 2008-03-02 16:00:00
 2008-03-03 02:00:00
 2008-03-03 12:00:00
 2008-03-03 22:00:00
 2008-03-04 08:00:00
(9 rows)
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   当<parameter>step</parameter>为正时，如果<parameter>start</parameter>大于<parameter>stop</parameter>则返回零行。
   相反，当<parameter>step</parameter>为负时，如果<parameter>start</parameter>小于<parameter>stop</parameter>则返回零行。
   如果任何输入为<literal>NULL</literal>也会返回零行。<parameter>step</parameter>为零是一个错误。下面是一些例子：
<programlisting>
SELECT * FROM generate_series(2,4);
 generate_series
-----------------
               2
               3
               4
(3 rows)

SELECT * FROM generate_series(5,1,-2);
 generate_series
-----------------
               5
               3
               1
(3 rows)

SELECT * FROM generate_series(4,3);
 generate_series
-----------------
(0 rows)

SELECT generate_series(1.1, 4, 1.3);
 generate_series
-----------------
             1.1
             2.4
             3.7
(3 rows)

-- this example relies on the date-plus-integer operator:
SELECT current_date + s.a AS dates FROM generate_series(0,14,7) AS s(a);
   dates
------------
 2004-02-05
 2004-02-12
 2004-02-19
(3 rows)

SELECT * FROM generate_series('2008-03-01 00:00'::timestamp,
                              '2008-03-04 12:00', '10 hours');
   generate_series
---------------------
 2008-03-01 00:00:00
 2008-03-01 10:00:00
 2008-03-01 20:00:00
 2008-03-02 06:00:00
 2008-03-02 16:00:00
 2008-03-03 02:00:00
 2008-03-03 12:00:00
 2008-03-03 22:00:00
 2008-03-04 08:00:00
(9 rows)
</programlisting>
  </para>

   <table id="functions-srf-subscripts">
<!--==========================orignal english content==========================
    <title>Subscript Generating Functions</title>
____________________________________________________________________________-->
    <title>下标生成函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>generate_subscripts</primary>
        </indexterm>
        <function>generate_subscripts</function> ( <parameter>array</parameter> <type>anyarray</type>, <parameter>dim</parameter> <type>integer</type> )
        <returnvalue>setof integer</returnvalue>
       </para>
       <para>
        Generates a series comprising the valid subscripts of
        the <parameter>dim</parameter>'th dimension of the given array.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>generate_subscripts</primary>
        </indexterm>
        <function>generate_subscripts</function> ( <parameter>array</parameter> <type>anyarray</type>, <parameter>dim</parameter> <type>integer</type> )
        <returnvalue>setof integer</returnvalue>
       </para>
       <para>
        生成一个包含给定数组第<parameter>dim</parameter>维度的有效下标的序列。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>generate_subscripts</function> ( <parameter>array</parameter> <type>anyarray</type>, <parameter>dim</parameter> <type>integer</type>,  <parameter>reverse</parameter> <type>boolean</type> )
        <returnvalue>setof integer</returnvalue>
       </para>
       <para>
        Generates a series comprising the valid subscripts of
        the <parameter>dim</parameter>'th dimension of the given array.
        When <parameter>reverse</parameter> is true, returns the series in
        reverse order.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>generate_subscripts</function> ( <parameter>array</parameter> <type>anyarray</type>, <parameter>dim</parameter> <type>integer</type>,  <parameter>reverse</parameter> <type>boolean</type> )
        <returnvalue>setof integer</returnvalue>
       </para>
       <para>
        生成一个包含给定数组第<parameter>dim</parameter>维度的有效下标的序列。当<parameter>reverse</parameter>为真时，以相反的顺序返回序列。
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
  <para>
   <function>generate_subscripts</function> is a convenience function that generates
   the set of valid subscripts for the specified dimension of the given
   array.
   Zero rows are returned for arrays that do not have the requested dimension,
   or if any input is <literal>NULL</literal>.
   Some examples follow:
<programlisting>
-&minus; basic usage:
SELECT generate_subscripts('{NULL,1,NULL,2}'::int[], 1) AS s;
 s
-&minus;-
 1
 2
 3
 4
(4 rows)

-&minus; presenting an array, the subscript and the subscripted
-&minus; value requires a subquery:
SELECT * FROM arrays;
         a
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 {-1,-2}
 {100,200,300}
(2 rows)

SELECT a AS array, s AS subscript, a[s] AS value
FROM (SELECT generate_subscripts(a, 1) AS s, a FROM arrays) foo;
     array     | subscript | value
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-
 {-1,-2}       |         1 |    -1
 {-1,-2}       |         2 |    -2
 {100,200,300} |         1 |   100
 {100,200,300} |         2 |   200
 {100,200,300} |         3 |   300
(5 rows)

-&minus; unnest a 2D array:
CREATE OR REPLACE FUNCTION unnest2(anyarray)
RETURNS SETOF anyelement AS $$
select $1[i][j]
   from generate_subscripts($1,1) g1(i),
        generate_subscripts($1,2) g2(j);
$$ LANGUAGE sql IMMUTABLE;
CREATE FUNCTION
SELECT * FROM unnest2(ARRAY[[1,2],[3,4]]);
 unnest2
-&minus;-&minus;-&minus;-&minus;-
       1
       2
       3
       4
(4 rows)
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   <function>generate_subscripts</function>是一个快捷函数，它为给定数组的指定维度生成一组合法的下标。
   对于不具有请求维度的数组返回零行，对于任何输入为<literal>NULL</literal>数组也返回零行。下面是一些例子：
<programlisting>
-- basic usage:
SELECT generate_subscripts('{NULL,1,NULL,2}'::int[], 1) AS s;
 s
---
 1
 2
 3
 4
(4 rows)

-- presenting an array, the subscript and the subscripted
-- value requires a subquery:
SELECT * FROM arrays;
         a
--------------------
 {-1,-2}
 {100,200,300}
(2 rows)

SELECT a AS array, s AS subscript, a[s] AS value
FROM (SELECT generate_subscripts(a, 1) AS s, a FROM arrays) foo;
     array     | subscript | value
---------------+-----------+-------
 {-1,-2}       |         1 |    -1
 {-1,-2}       |         2 |    -2
 {100,200,300} |         1 |   100
 {100,200,300} |         2 |   200
 {100,200,300} |         3 |   300
(5 rows)

-- unnest a 2D array:
CREATE OR REPLACE FUNCTION unnest2(anyarray)
RETURNS SETOF anyelement AS $$
select $1[i][j]
   from generate_subscripts($1,1) g1(i),
        generate_subscripts($1,2) g2(j);
$$ LANGUAGE sql IMMUTABLE;
CREATE FUNCTION
SELECT * FROM unnest2(ARRAY[[1,2],[3,4]]);
 unnest2
---------
       1
       2
       3
       4
(4 rows)
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>ordinality</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>ordinality</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   When a function in the <literal>FROM</literal> clause is suffixed
   by <literal>WITH ORDINALITY</literal>, a <type>bigint</type> column is
   appended to the function's output column(s), which starts from 1 and
   increments by 1 for each row of the function's output.
   This is most useful in the case of set returning
   functions such as <function>unnest()</function>.

<programlisting>
-&minus; set returning function WITH ORDINALITY:
SELECT * FROM pg_ls_dir('.') WITH ORDINALITY AS t(ls,n);
       ls        | n
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;
 pg_serial       |  1
 pg_twophase     |  2
 postmaster.opts |  3
 pg_notify       |  4
 postgresql.conf |  5
 pg_tblspc       |  6
 logfile         |  7
 base            |  8
 postmaster.pid  |  9
 pg_ident.conf   | 10
 global          | 11
 pg_xact         | 12
 pg_snapshots    | 13
 pg_multixact    | 14
 PG_VERSION      | 15
 pg_wal          | 16
 pg_hba.conf     | 17
 pg_stat_tmp     | 18
 pg_subtrans     | 19
(19 rows)
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   当<literal>FROM</literal>子句中的函数以<literal>WITH ORDINALITY</literal>作为后缀时，将在函数的输出列上附加一个<type>bigint</type>列，该列从1开始，函数输出的每一行加1。
   这在 <function>unnest()</function>等集合返回函数的情况下最有用。

<programlisting>
-- set returning function WITH ORDINALITY:
SELECT * FROM pg_ls_dir('.') WITH ORDINALITY AS t(ls,n);
       ls        | n
-----------------+----
 pg_serial       |  1
 pg_twophase     |  2
 postmaster.opts |  3
 pg_notify       |  4
 postgresql.conf |  5
 pg_tblspc       |  6
 logfile         |  7
 base            |  8
 postmaster.pid  |  9
 pg_ident.conf   | 10
 global          | 11
 pg_xact         | 12
 pg_snapshots    | 13
 pg_multixact    | 14
 PG_VERSION      | 15
 pg_wal          | 16
 pg_hba.conf     | 17
 pg_stat_tmp     | 18
 pg_subtrans     | 19
(19 rows)
</programlisting>
  </para>

 </sect1>

 <sect1 id="functions-info">
<!--==========================orignal english content==========================
  <title>System Information Functions and Operators</title>
____________________________________________________________________________-->
  <title>系统信息函数和运算符</title>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="functions-info-session-table"/> shows several
   functions that extract session and system information.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="functions-info-session-table"/>展示了多个可以抽取会话和系统信息的函数。
  </para>

<!--==========================orignal english content==========================
  <para>
   In addition to the functions listed in this section, there are a number of
   functions related to the statistics system that also provide system
   information. See <xref linkend="monitoring-stats-views"/> for more
   information.
  </para>
____________________________________________________________________________-->
  <para>
   除了本节列出的函数，还有一些与统计系统相关的函数也提供系统信息。详见<xref linkend="monitoring-stats-views"/>。
  </para>

   <table id="functions-info-session-table">
<!--==========================orignal english content==========================
    <title>Session Information Functions</title>
____________________________________________________________________________-->
    <title>会话信息函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>current_catalog</primary>
        </indexterm>
        <function>current_catalog</function>
        <returnvalue>name</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>current_database</primary>
        </indexterm>
        <function>current_database</function> ()
        <returnvalue>name</returnvalue>
       </para>
       <para>
        Returns the name of the current database.  (Databases are
        called <quote>catalogs</quote> in the SQL standard,
        so <function>current_catalog</function> is the standard's
        spelling.)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>current_catalog</primary>
        </indexterm>
        <function>current_catalog</function>
        <returnvalue>name</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>current_database</primary>
        </indexterm>
        <function>current_database</function> ()
        <returnvalue>name</returnvalue>
       </para>
       <para>
        返回当前数据库的名称。(在SQL标准中数据库被称为<quote>catalogs</quote>，因此<function>current_catalog</function>是该标准的拼写方式。)
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>current_query</primary>
        </indexterm>
        <function>current_query</function> ()
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the text of the currently executing query, as submitted
        by the client (which might contain more than one statement).
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>current_query</primary>
        </indexterm>
        <function>current_query</function> ()
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回当前所执行查询的文本，由客户端提交的(可能包含一个以上的语句)。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>current_role</primary>
        </indexterm>
        <function>current_role</function>
        <returnvalue>name</returnvalue>
       </para>
       <para>
        This is equivalent to <function>current_user</function>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>current_role</primary>
        </indexterm>
        <function>current_role</function>
        <returnvalue>name</returnvalue>
       </para>
       <para>
        这个等同于 <function>current_user</function>。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>current_schema</primary>
        </indexterm>
        <indexterm>
         <primary>schema</primary>
         <secondary>current</secondary>
        </indexterm>
        <function>current_schema</function>
        <returnvalue>name</returnvalue>
       </para>
       <para role="func_signature">
        <function>current_schema</function> ()
        <returnvalue>name</returnvalue>
       </para>
       <para>
        Returns the name of the schema that is first in the search path (or a
        null value if the search path is empty).  This is the schema that will
        be used for any tables or other named objects that are created without
        specifying a target schema.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>current_schema</primary>
        </indexterm>
        <indexterm>
         <primary>schema</primary>
         <secondary>current</secondary>
        </indexterm>
        <function>current_schema</function>
        <returnvalue>name</returnvalue>
       </para>
       <para role="func_signature">
        <function>current_schema</function> ()
        <returnvalue>name</returnvalue>
       </para>
       <para>
        返回在搜索路径中的第一个模式的名称(如果搜索路径为空则返回空值)。
        这个模式将用于没有指定目标模式就创建的任何表或其他已命名对象。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>current_schemas</primary>
        </indexterm>
        <indexterm>
         <primary>search path</primary>
         <secondary>current</secondary>
        </indexterm>
        <function>current_schemas</function> ( <parameter>include_implicit</parameter> <type>boolean</type> )
        <returnvalue>name[]</returnvalue>
       </para>
       <para>
        Returns an array of the names of all schemas presently in the
        effective search path, in their priority order.  (Items in the current
        <xref linkend="guc-search-path"/> setting that do not correspond to
        existing, searchable schemas are omitted.)  If the Boolean argument
        is <literal>true</literal>, then implicitly-searched system schemas
        such as <literal>pg_catalog</literal> are included in the result.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>current_schemas</primary>
        </indexterm>
        <indexterm>
         <primary>search path</primary>
         <secondary>current</secondary>
        </indexterm>
        <function>current_schemas</function> ( <parameter>include_implicit</parameter> <type>boolean</type> )
        <returnvalue>name[]</returnvalue>
       </para>
       <para>
        返回当前在有效搜索路径中的所有模式的名称的数组，以优先级顺序。
        (当前 <xref linkend="guc-search-path"/>设置中与已存在的、可搜索模式不相符的项将被省略。)
        如果布尔参数为<literal>true</literal>，则类似<literal>pg_catalog</literal>的隐式搜索的系统模式将包含在结果中。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>current_user</primary>
        </indexterm>
        <indexterm>
         <primary>user</primary>
         <secondary>current</secondary>
        </indexterm>
        <function>current_user</function>
        <returnvalue>name</returnvalue>
       </para>
       <para>
        Returns the user name of the current execution context.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>current_user</primary>
        </indexterm>
        <indexterm>
         <primary>user</primary>
         <secondary>current</secondary>
        </indexterm>
        <function>current_user</function>
        <returnvalue>name</returnvalue>
       </para>
       <para>
        返回当前执行上下文的用户名。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>inet_client_addr</primary>
        </indexterm>
        <function>inet_client_addr</function> ()
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        Returns the IP address of the current client,
        or <literal>NULL</literal> if the current connection is via a
        Unix-domain socket.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>inet_client_addr</primary>
        </indexterm>
        <function>inet_client_addr</function> ()
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        返回当前客户端的IP地址，如果当前连接是通过Unix-域套接字则返回<literal>NULL</literal>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>inet_client_port</primary>
        </indexterm>
        <function>inet_client_port</function> ()
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the IP port number of the current client,
        or <literal>NULL</literal> if the current connection is via a
        Unix-domain socket.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>inet_client_port</primary>
        </indexterm>
        <function>inet_client_port</function> ()
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回当前客户端的IP端口号，如果当前连接是通过Unix-域套接字则返回<literal>NULL</literal>。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>inet_server_addr</primary>
        </indexterm>
        <function>inet_server_addr</function> ()
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        Returns the IP address on which the server accepted the current
        connection,
        or <literal>NULL</literal> if the current connection is via a
        Unix-domain socket.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>inet_server_addr</primary>
        </indexterm>
        <function>inet_server_addr</function> ()
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        返回服务器接受当前连接的IP地址，如果当前连接是通过Unix-域套接字则返回<literal>NULL</literal>。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>inet_server_port</primary>
        </indexterm>
        <function>inet_server_port</function> ()
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the IP port number on which the server accepted the current
        connection,
        or <literal>NULL</literal> if the current connection is via a
        Unix-domain socket.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>inet_server_port</primary>
        </indexterm>
        <function>inet_server_port</function> ()
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回服务器接受当前连接的IP端口号，如果当前连接是通过Unix-域套接字则返回<literal>NULL</literal>。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_backend_pid</primary>
        </indexterm>
        <function>pg_backend_pid</function> ()
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the process ID of the server process attached to the current
        session.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_backend_pid</primary>
        </indexterm>
        <function>pg_backend_pid</function> ()
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回附加到当前会话的服务器进程的进程ID。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_blocking_pids</primary>
        </indexterm>
        <function>pg_blocking_pids</function> ( <type>integer</type> )
        <returnvalue>integer[]</returnvalue>
       </para>
       <para>
        Returns an array of the process ID(s) of the sessions that are
        blocking the server process with the specified process ID from
        acquiring a lock, or an empty array if there is no such server process
        or it is not blocked.
       </para>
       <para>
        One server process blocks another if it either holds a lock that
        conflicts with the blocked process's lock request (hard block), or is
        waiting for a lock that would conflict with the blocked process's lock
        request and is ahead of it in the wait queue (soft block).  When using
        parallel queries the result always lists client-visible process IDs
        (that is, <function>pg_backend_pid</function> results) even if the
        actual lock is held or awaited by a child worker process.  As a result
        of that, there may be duplicated PIDs in the result.  Also note that
        when a prepared transaction holds a conflicting lock, it will be
        represented by a zero process ID.
       </para>
       <para>
        Frequent calls to this function could have some impact on database
        performance, because it needs exclusive access to the lock manager's
        shared state for a short time.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_blocking_pids</primary>
        </indexterm>
        <function>pg_blocking_pids</function> ( <type>integer</type> )
        <returnvalue>integer[]</returnvalue>
       </para>
       <para>
        返回阻止服务器进程的会话的进程ID数组，该进程ID与指定的进程ID一起获取锁定，如果没有这样的服务器进程或者没有被阻塞，则返回一个空数组。
       </para>
       <para>
        如果一个服务器进程持有一个与被阻塞进程的锁请求冲突的锁(硬阻塞)，或者正在等待一个与被阻塞进程的锁请求冲突并且在等待队列中位于其前面的锁(软阻塞)，那么这个服务器进程就会阻塞另一个服务器进程。
        当使用并行查询时结果总是列出客户端可见的进程ID(即<function>pg_backend_pid</function>的结果)，即使实际的锁是由子工作进程持有或等待的。
        因此，结果中可能存在重复的pid。还要注意当准备好的事务持有冲突锁时，它将用零进程ID表示。
       </para>
       <para>
        频繁调用这个函数可能会对数据库性能产生一些影响，因为它需要在短时间内独占访问锁管理器的共享状态。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_conf_load_time</primary>
        </indexterm>
        <function>pg_conf_load_time</function> ()
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
        Returns the time when the server configuration files were last loaded.
        If the current session was alive at the time, this will be the time
        when the session itself re-read the configuration files (so the
        reading will vary a little in different sessions).  Otherwise it is
        the time when the postmaster process re-read the configuration files.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_conf_load_time</primary>
        </indexterm>
        <function>pg_conf_load_time</function> ()
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
        返回服务器配置文件最后加载的时间。如果当前会话当时是活跃的，那么这将是会话本身重新读取配置文件的时间(因此在不同的会话中读取会稍有不同)。
        否则，就是postmaster进程重新读取配置文件的时间。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_current_logfile</primary>
        </indexterm>
        <indexterm>
         <primary>Logging</primary>
         <secondary>pg_current_logfile function</secondary>
        </indexterm>
        <indexterm>
          <primary>current_logfiles</primary>
          <secondary>and the pg_current_logfile function</secondary>
        </indexterm>
        <indexterm>
         <primary>Logging</primary>
         <secondary>current_logfiles file and the pg_current_logfile
         function</secondary>
        </indexterm>
        <function>pg_current_logfile</function> ( <optional> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the path name of the log file currently in use by the logging
        collector.  The path includes the <xref linkend="guc-log-directory"/>
        directory and the individual log file name.  The result
        is <literal>NULL</literal> if the logging collector is disabled.
        When multiple log files exist, each in a different
        format, <function>pg_current_logfile</function> without an argument
        returns the path of the file having the first format found in the
        ordered list: <literal>stderr</literal>,
        <literal>csvlog</literal>.  <literal>NULL</literal> is returned
        if no log file has any of these formats.
        To request information about a specific log file format, supply
        either <literal>csvlog</literal> or <literal>stderr</literal> as the
        value of the optional parameter. The result is <literal>NULL</literal>
        if the log format requested is not configured in
        <xref linkend="guc-log-destination"/>.
        The result reflects the contents of
        the <filename>current_logfiles</filename> file.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_current_logfile</primary>
        </indexterm>
        <indexterm>
         <primary>Logging</primary>
         <secondary>pg_current_logfile function</secondary>
        </indexterm>
        <indexterm>
          <primary>current_logfiles</primary>
          <secondary>and the pg_current_logfile function</secondary>
        </indexterm>
        <indexterm>
         <primary>Logging</primary>
         <secondary>current_logfiles file and the pg_current_logfile
         function</secondary>
        </indexterm>
        <function>pg_current_logfile</function> ( <optional> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回日志采集器当前使用的日志文件的路径名。该路径包括<xref linkend="guc-log-directory"/>目录和单个日志文件名。
        如果日志采集器被禁用，结果为<literal>NULL</literal>。当存在多个日志文件时，每个文件的格式都不同，不带参数的<function>pg_current_logfile</function>将返回在有序列表中找到的第一种格式的文件路径:<literal>stderr</literal>，<literal>csvlog</literal>。
        如果没有日志文件具有任何这些格式，则返回<literal>NULL</literal>。
        要请求关于特定日志文件格式的信息，可以提供 <literal>csvlog</literal> 或 <literal>stderr</literal>作为可选参数的值。
        如果在<xref linkend="guc-log-destination"/>中没有配置需要的日志格式，则结果为<literal>NULL</literal>。
        结果反映了<filename>current_logfiles</filename>文件的内容。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_my_temp_schema</primary>
        </indexterm>
        <function>pg_my_temp_schema</function> ()
        <returnvalue>oid</returnvalue>
       </para>
       <para>
        Returns the OID of the current session's temporary schema, or zero if
        it has none (because it has not created any temporary tables).
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_my_temp_schema</primary>
        </indexterm>
        <function>pg_my_temp_schema</function> ()
        <returnvalue>oid</returnvalue>
       </para>
       <para>
        返回当前会话的临时模式的OID，如果没有则返回0(因为它没有创建任何临时表)。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_is_other_temp_schema</primary>
        </indexterm>
        <function>pg_is_other_temp_schema</function> ( <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Returns true if the given OID is the OID of another session's
        temporary schema.  (This can be useful, for example, to exclude other
        sessions' temporary tables from a catalog display.)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_is_other_temp_schema</primary>
        </indexterm>
        <function>pg_is_other_temp_schema</function> ( <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        如果给定的OID是另一个会话的临时模式的OID则返回真。(这可能是有用的，例如，在目录显示中排除其他会话的临时表。)
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_jit_available</primary>
        </indexterm>
        <function>pg_jit_available</function> ()
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Returns true if a <acronym>JIT</acronym> compiler extension is
        available (see <xref linkend="jit"/>) and the
        <xref linkend="guc-jit"/> configuration parameter is set to
        <literal>on</literal>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_jit_available</primary>
        </indexterm>
        <function>pg_jit_available</function> ()
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        如果<acronym>JIT</acronym>编译器扩展可用(参见<xref linkend="jit"/>)，并且<xref linkend="guc-jit"/>配置参数设置为<literal>on</literal>，则返回真。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_listening_channels</primary>
        </indexterm>
        <function>pg_listening_channels</function> ()
        <returnvalue>setof text</returnvalue>
       </para>
       <para>
        Returns the set of names of asynchronous notification channels that
        the current session is listening to.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_listening_channels</primary>
        </indexterm>
        <function>pg_listening_channels</function> ()
        <returnvalue>setof text</returnvalue>
       </para>
       <para>
        返回当前会话正在侦听的异步通知通道的名称集。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_notification_queue_usage</primary>
        </indexterm>
        <function>pg_notification_queue_usage</function> ()
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Returns the fraction (0&ndash;1) of the asynchronous notification
        queue's maximum size that is currently occupied by notifications that
        are waiting to be processed.
        See <xref linkend="sql-listen"/> and <xref linkend="sql-notify"/>
        for more information.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_notification_queue_usage</primary>
        </indexterm>
        <function>pg_notification_queue_usage</function> ()
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        返回当前被等待处理的通知所占用的异步通知队列最大尺寸的分数(0&ndash;1)。更多信息请参见<xref linkend="sql-listen"/> 和 <xref linkend="sql-notify"/>。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_postmaster_start_time</primary>
        </indexterm>
        <function>pg_postmaster_start_time</function> ()
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
        Returns the time when the server started.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_postmaster_start_time</primary>
        </indexterm>
        <function>pg_postmaster_start_time</function> ()
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
        返回服务器启动时的时间。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_safe_snapshot_blocking_pids</primary>
        </indexterm>
        <function>pg_safe_snapshot_blocking_pids</function> ( <type>integer</type> )
        <returnvalue>integer[]</returnvalue>
       </para>
       <para>
        Returns an array of the process ID(s) of the sessions that are blocking
        the server process with the specified process ID from acquiring a safe
        snapshot, or an empty array if there is no such server process or it
        is not blocked.
       </para>
       <para>
        A session running a <literal>SERIALIZABLE</literal> transaction blocks
        a <literal>SERIALIZABLE READ ONLY DEFERRABLE</literal> transaction
        from acquiring a snapshot until the latter determines that it is safe
        to avoid taking any predicate locks.  See
        <xref linkend="xact-serializable"/> for more information about
        serializable and deferrable transactions.
       </para>
       <para>
        Frequent calls to this function could have some impact on database
        performance, because it needs access to the predicate lock manager's
        shared state for a short time.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_safe_snapshot_blocking_pids</primary>
        </indexterm>
        <function>pg_safe_snapshot_blocking_pids</function> ( <type>integer</type> )
        <returnvalue>integer[]</returnvalue>
       </para>
       <para>
        返回一个进程ID数组，该进程ID是阻塞服务器进程获取安全快照的会话的进程ID数组，如果没有这样的服务器进程或者没有阻塞，则返回一个空数组。
       </para>
       <para>
        运行<literal>SERIALIZABLE</literal>事务的会话会阻止<literal>SERIALIZABLE READ ONLY DEFERRABLE</literal>事务获取快照，直到后者确定可以安全地避免获取谓词锁。
        关于可序列化和可延迟事务的更多信息，请参见<xref linkend="xact-serializable"/>。
       </para>
       <para>
        频繁调用这个函数可能会对数据库性能产生一些影响，因为它需要在短时间内访问谓词锁管理器的共享状态。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_trigger_depth</primary>
        </indexterm>
        <function>pg_trigger_depth</function> ()
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the current nesting level
        of <productname>PostgreSQL</productname> triggers (0 if not called,
        directly or indirectly, from inside a trigger).
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_trigger_depth</primary>
        </indexterm>
        <function>pg_trigger_depth</function> ()
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回当前嵌套层次的<productname>PostgreSQL</productname>触发器(如果没有调用则为 0，直接或间接，从一个触发器内部开始)。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>session_user</primary>
        </indexterm>
        <function>session_user</function>
        <returnvalue>name</returnvalue>
       </para>
       <para>
        Returns the session user's name.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>session_user</primary>
        </indexterm>
        <function>session_user</function>
        <returnvalue>name</returnvalue>
       </para>
       <para>
        返回会话用户名.
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>user</primary>
        </indexterm>
        <function>user</function>
        <returnvalue>name</returnvalue>
       </para>
       <para>
        This is equivalent to <function>current_user</function>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>user</primary>
        </indexterm>
        <function>user</function>
        <returnvalue>name</returnvalue>
       </para>
       <para>
        这个相当于 <function>current_user</function>。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>version</primary>
        </indexterm>
        <function>version</function> ()
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns a string describing the <productname>PostgreSQL</productname>
        server's version.  You can also get this information from
        <xref linkend="guc-server-version"/>, or for a machine-readable
        version use <xref linkend="guc-server-version-num"/>.  Software
        developers should use <varname>server_version_num</varname> (available
        since 8.2) or <xref linkend="libpq-PQserverVersion"/> instead of
        parsing the text version.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>version</primary>
        </indexterm>
        <function>version</function> ()
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回描述<productname>PostgreSQL</productname>服务器的版本的字符串。
        你还可以从 <xref linkend="guc-server-version"/>中获得此信息，或者对于机器可读的版本，使用<xref linkend="guc-server-version-num"/>。
        软件开发人员可以使用<varname>server_version_num</varname>(从8.2起可用)或<xref linkend="libpq-PQserverVersion"/>，而不是解析文本版本。
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <note>
<!--==========================orignal english content==========================
    <para>
     <function>current_catalog</function>,
     <function>current_role</function>,
     <function>current_schema</function>,
     <function>current_user</function>,
     <function>session_user</function>,
     and <function>user</function> have special syntactic status
     in <acronym>SQL</acronym>: they must be called without trailing
     parentheses.  In PostgreSQL, parentheses can optionally be used with
     <function>current_schema</function>, but not with the others.
    </para>
____________________________________________________________________________-->
    <para>
     <function>current_catalog</function>、<function>current_role</function>、<function>current_schema</function>、<function>current_user</function>、<function>session_user</function>和<function>user</function>在<acronym>SQL</acronym>里有特殊的语意状态： 它们被调用时结尾不要跟着园括号。
     在 PostgreSQL 中，圆括号可以有选择性地被用于<function>current_schema</function>，但是不能和其他的一起用。
    </para>
   </note>

<!--==========================orignal english content==========================
   <para>
    The <function>session_user</function> is normally the user who initiated
    the current database connection; but superusers can change this setting
    with <xref linkend="sql-set-session-authorization"/>.
    The <function>current_user</function> is the user identifier
    that is applicable for permission checking. Normally it is equal
    to the session user, but it can be changed with
    <xref linkend="sql-set-role"/>.
    It also changes during the execution of
    functions with the attribute <literal>SECURITY DEFINER</literal>.
    In Unix parlance, the session user is the <quote>real user</quote> and
    the current user is the <quote>effective user</quote>.
    <function>current_role</function> and <function>user</function> are
    synonyms for <function>current_user</function>.  (The SQL standard draws
    a distinction between <function>current_role</function>
    and <function>current_user</function>, but <productname>PostgreSQL</productname>
    does not, since it unifies users and roles into a single kind of entity.)
   </para>
____________________________________________________________________________-->
   <para>
    <function>session_user</function>通常是发起当前数据库连接的用户，不过超级用户可以用<xref linkend="sql-set-session-authorization"/>修改这个设置。
    <function>current_user</function>是用于权限检查的用户标识。通常， 它总是等于会话用户，但是可以被<xref linkend="sql-set-role"/>改变。
    它也会在函数执行的过程中随着属性<literal>SECURITY DEFINER</literal>的改变而改变。
    在 Unix 的说法里，那么会话用户是<quote>真实用户</quote>，而当前用户是<quote>有效用户</quote>。
    <function>current_role</function>以及<function>user</function>是<function>current_user</function>的同义词（SQL标准在<function>current_role</function>和<function>current_user</function>之间做了区分，但<productname>PostgreSQL</productname>不区分，因为它把用户和角色统一成了一种实体）。
   </para>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>privilege</primary>
   <secondary>querying</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>privilege</primary>
   <secondary>querying</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="functions-info-access-table"/> lists functions that
   allow querying object access privileges programmatically.
   (See <xref linkend="ddl-priv"/> for more information about
   privileges.)
   In these functions, the user whose privileges are being inquired about
   can be specified by name or by OID
   (<structname>pg_authid</structname>.<structfield>oid</structfield>), or if
   the name is given as <literal>public</literal> then the privileges of the
   PUBLIC pseudo-role are checked.  Also, the <parameter>user</parameter>
   argument can be omitted entirely, in which case
   the <function>current_user</function> is assumed.
   The object that is being inquired about can be specified either by name or
   by OID, too.  When specifying by name, a schema name can be included if
   relevant.
   The access privilege of interest is specified by a text string, which must
   evaluate to one of the appropriate privilege keywords for the object's type
   (e.g., <literal>SELECT</literal>).  Optionally, <literal>WITH GRANT
   OPTION</literal> can be added to a privilege type to test whether the
   privilege is held with grant option. Also, multiple privilege types can be
   listed separated by commas, in which case the result will be true if any of
   the listed privileges is held. (Case of the privilege string is not
   significant, and extra whitespace is allowed between but not within
   privilege names.)
   Some examples:
<programlisting>
SELECT has_table_privilege('myschema.mytable', 'select');
SELECT has_table_privilege('joe', 'mytable', 'INSERT, SELECT WITH GRANT OPTION');
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="functions-info-access-table"/>列出那些允许编程查询对象访问权限的函数。参阅<xref linkend="ddl-priv"/>获取更多有关权限的信息。
   在这些函数中，可以通过名称或OID (<structname>pg_authid</structname>.<structfield>oid</structfield>)指定被查询权限的用户，或者如果名称被指定为<literal>public</literal>，则检查PUBLIC伪角色的权限。
   同样，<parameter>user</parameter>参数可以完全省略，在这种情况下，假设为<function>current_user</function>。被查询的对象也可以通过名称或OID来指定。
   通过名称指定时，可以包含相关的模式名称。感兴趣的访问权限由一个文本字符串指定，它必须计算为对象类型的一个适当的权限关键字(例如，<literal>SELECT</literal>)。
   还可以将 <literal>WITH GRANT OPTION</literal>添加到特权类型中，以测试该特权是否由授予选项持有。
   同样，可以用逗号分隔列出多个特权类型，在这种情况下，如果所列出的特权中有任何一个被持有，结果将为真。
   (特权字符串的大小写不重要，特权名之间允许有额外的空格，但在特权名中不允许。)一些例子:
<programlisting>
SELECT has_table_privilege('myschema.mytable', 'select');
SELECT has_table_privilege('joe', 'mytable', 'INSERT, SELECT WITH GRANT OPTION');
</programlisting>
  </para>

   <table id="functions-info-access-table">
<!--==========================orignal english content==========================
    <title>Access Privilege Inquiry Functions</title>
____________________________________________________________________________-->
    <title>访问权限查询函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_any_column_privilege</primary>
        </indexterm>
        <function>has_any_column_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>table</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does user have privilege for any column of table?
        This succeeds either if the privilege is held for the whole table, or
        if there is a column-level grant of the privilege for at least one
        column.
        Allowable privilege types are
        <literal>SELECT</literal>, <literal>INSERT</literal>,
        <literal>UPDATE</literal>, and <literal>REFERENCES</literal>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_any_column_privilege</primary>
        </indexterm>
        <function>has_any_column_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>table</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        用户是否对表的任何列有权限?
        如果对整个表持有特权，或者对至少一个列有列级的特权授予，则会成功。
        允许的权限类型为<literal>SELECT</literal>, <literal>INSERT</literal>,<literal>UPDATE</literal>, 和 <literal>REFERENCES</literal>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_column_privilege</primary>
        </indexterm>
        <function>has_column_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>table</parameter> <type>text</type> or <type>oid</type>,
          <parameter>column</parameter> <type>text</type> or <type>smallint</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does user have privilege for the specified table column?
        This succeeds either if the privilege is held for the whole table, or
        if there is a column-level grant of the privilege for the column.
        The column can be specified by name or by attribute number
        (<structname>pg_attribute</structname>.<structfield>attnum</structfield>).
        Allowable privilege types are
        <literal>SELECT</literal>, <literal>INSERT</literal>,
        <literal>UPDATE</literal>, and <literal>REFERENCES</literal>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_column_privilege</primary>
        </indexterm>
        <function>has_column_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>table</parameter> <type>text</type> or <type>oid</type>,
          <parameter>column</parameter> <type>text</type> or <type>smallint</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        用户对指定的表列有特权么?如果对整个表持有特权，或者对列授予了列级别的特权，则会成功。
        可以通过名称或属性编号(<structname>pg_attribute</structname>.<structfield>attnum</structfield>)指定列。
        允许的特权类型为<literal>SELECT</literal>, <literal>INSERT</literal>,<literal>UPDATE</literal>, 和 <literal>REFERENCES</literal>。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_database_privilege</primary>
        </indexterm>
        <function>has_database_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>database</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does user have privilege for database?
        Allowable privilege types are
        <literal>CREATE</literal>,
        <literal>CONNECT</literal>,
        <literal>TEMPORARY</literal>, and
        <literal>TEMP</literal> (which is equivalent to
        <literal>TEMPORARY</literal>).
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_database_privilege</primary>
        </indexterm>
        <function>has_database_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>database</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        用户对数据库有特权吗?允许的特权类型为<literal>CREATE</literal>,<literal>CONNECT</literal>,<literal>TEMPORARY</literal>, 和<literal>TEMP</literal> (相当于 <literal>TEMPORARY</literal>)。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_foreign_data_wrapper_privilege</primary>
        </indexterm>
        <function>has_foreign_data_wrapper_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>fdw</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does user have privilege for foreign-data wrapper?
        The only allowable privilege type is <literal>USAGE</literal>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_foreign_data_wrapper_privilege</primary>
        </indexterm>
        <function>has_foreign_data_wrapper_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>fdw</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        用户是否拥有外部数据包装的特权?唯一允许的特权类型是<literal>USAGE</literal>。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_function_privilege</primary>
        </indexterm>
        <function>has_function_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>function</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does user have privilege for function?
        The only allowable privilege type is <literal>EXECUTE</literal>.
       </para>
       <para>
        When specifying a function by name rather than by OID, the allowed
        input is the same as for the <type>regprocedure</type> data type (see
        <xref linkend="datatype-oid"/>).
        An example is:
<programlisting>
SELECT has_function_privilege('joeuser', 'myfunc(int, text)', 'execute');
</programlisting>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_function_privilege</primary>
        </indexterm>
        <function>has_function_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>function</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        用户对函数有特权吗?唯一允许的特权类型是<literal>EXECUTE</literal>。
       </para>
       <para>
        当通过名称而不是OID指定函数时，允许的输入与<type>regprocedure</type>数据类型相同(参见<xref linkend="datatype-oid"/>)。一个例子为：
<programlisting>
SELECT has_function_privilege('joeuser', 'myfunc(int, text)', 'execute');
</programlisting>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_language_privilege</primary>
        </indexterm>
        <function>has_language_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>language</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does user have privilege for language?
        The only allowable privilege type is <literal>USAGE</literal>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_language_privilege</primary>
        </indexterm>
        <function>has_language_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>language</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        用户对语言有特权吗?唯一允许的特权类型是<literal>USAGE</literal>。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_schema_privilege</primary>
        </indexterm>
        <function>has_schema_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>schema</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does user have privilege for schema?
        Allowable privilege types are
        <literal>CREATE</literal> and
        <literal>USAGE</literal>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_schema_privilege</primary>
        </indexterm>
        <function>has_schema_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>schema</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        用户对模式有特权吗?允许的特权类型是<literal>CREATE</literal> 和<literal>USAGE</literal>。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_sequence_privilege</primary>
        </indexterm>
        <function>has_sequence_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>sequence</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does user have privilege for sequence?
        Allowable privilege types are
        <literal>USAGE</literal>,
        <literal>SELECT</literal>, and
        <literal>UPDATE</literal>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_sequence_privilege</primary>
        </indexterm>
        <function>has_sequence_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>sequence</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        用户是否有顺序特权?允许的特权类型有<literal>USAGE</literal>, <literal>SELECT</literal>, 和<literal>UPDATE</literal>。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_server_privilege</primary>
        </indexterm>
        <function>has_server_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>server</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does user have privilege for foreign server?
        The only allowable privilege type is <literal>USAGE</literal>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_server_privilege</primary>
        </indexterm>
        <function>has_server_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>server</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        用户是否对外部服务器有特权?唯一允许的特权类型是<literal>USAGE</literal>。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_table_privilege</primary>
        </indexterm>
        <function>has_table_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>table</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does user have privilege for table?
        Allowable privilege types
        are <literal>SELECT</literal>, <literal>INSERT</literal>,
        <literal>UPDATE</literal>, <literal>DELETE</literal>,
        <literal>TRUNCATE</literal>, <literal>REFERENCES</literal>,
        and <literal>TRIGGER</literal>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_table_privilege</primary>
        </indexterm>
        <function>has_table_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>table</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        用户对表有特权吗?允许的特权类型有<literal>SELECT</literal>, <literal>INSERT</literal>,<literal>UPDATE</literal>, <literal>DELETE</literal>,<literal>TRUNCATE</literal>, <literal>REFERENCES</literal>,和 <literal>TRIGGER</literal>。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_tablespace_privilege</primary>
        </indexterm>
        <function>has_tablespace_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>tablespace</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does user have privilege for tablespace?
        The only allowable privilege type is <literal>CREATE</literal>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_tablespace_privilege</primary>
        </indexterm>
        <function>has_tablespace_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>tablespace</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        用户对表空间有特权吗?唯一允许的特权类型是<literal>CREATE</literal>。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_type_privilege</primary>
        </indexterm>
        <function>has_type_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>type</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does user have privilege for data type?
        The only allowable privilege type is <literal>USAGE</literal>.
        When specifying a type by name rather than by OID, the allowed input
        is the same as for the <type>regtype</type> data type (see
        <xref linkend="datatype-oid"/>).
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>has_type_privilege</primary>
        </indexterm>
        <function>has_type_privilege</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>type</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        用户对数据类型有特权吗?唯一允许的特权类型是 <literal>USAGE</literal>。
        当通过名称而不是OID指定类型时，允许的输入与<type>regtype</type>数据类型相同(参见<xref linkend="datatype-oid"/>)。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_has_role</primary>
        </indexterm>
        <function>pg_has_role</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>role</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does user have privilege for role?
        Allowable privilege types are
        <literal>MEMBER</literal> and <literal>USAGE</literal>.
        <literal>MEMBER</literal> denotes direct or indirect membership in
        the role (that is, the right to do <command>SET ROLE</command>), while
        <literal>USAGE</literal> denotes whether the privileges of the role
        are immediately available without doing <command>SET ROLE</command>.
        This function does not allow the special case of
        setting <parameter>user</parameter> to <literal>public</literal>,
        because the PUBLIC pseudo-role can never be a member of real roles.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_has_role</primary>
        </indexterm>
        <function>pg_has_role</function> (
          <optional> <parameter>user</parameter> <type>name</type> or <type>oid</type>, </optional>
          <parameter>role</parameter> <type>text</type> or <type>oid</type>,
          <parameter>privilege</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        用户对角色有特权么?允许的特权类型是<literal>MEMBER</literal> 和 <literal>USAGE</literal>。
        <literal>MEMBER</literal>表示角色中的直接或间接成员关系(即执行<command>SET ROLE</command>的权利)，而<literal>USAGE</literal>表示不执行<command>SET ROLE</command>情况下是否立即可用角色的特权。
        此函数不允许特殊情况下将<parameter>user</parameter>设置为<literal>public</literal>，因为PUBLIC伪角色永远不能成为真实角色的成员。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>row_security_active</primary>
        </indexterm>
        <function>row_security_active</function> (
          <parameter>table</parameter> <type>text</type> or <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is row-level security active for the specified table in the context of
        the current user and current environment?
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>row_security_active</primary>
        </indexterm>
        <function>row_security_active</function> (
          <parameter>table</parameter> <type>text</type> or <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        在当前用户和当前环境的上下文之中，指定表的行级安全是活动的吗?
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="functions-aclitem-op-table"/> shows the operators
   available for the <type>aclitem</type> type, which is the catalog
   representation of access privileges.  See <xref linkend="ddl-priv"/>
   for information about how to read access privilege values.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="functions-aclitem-op-table"/> 显示了<type>aclitem</type>类型的可用操作符，它是访问权限的目录表示。 
   有关如何读取访问权限值的信息，请参阅 <xref linkend="ddl-priv"/>。
  </para>

    <table id="functions-aclitem-op-table">
<!--==========================orignal english content==========================
     <title><type>aclitem</type> Operators</title>
____________________________________________________________________________-->
     <title><type>aclitem</type> 操作符</title>
     <tgroup cols="1">
      <thead>
<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         Operator
        </para>
        <para>
         Description
        </para>
        <para>
         Example(s)
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         操作符
        </para>
        <para>
         描述
        </para>
        <para>
         例子
        </para></entry>
       </row>
      </thead>

      <tbody>
<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>aclitemeq</primary>
         </indexterm>
         <type>aclitem</type> <literal>=</literal> <type>aclitem</type>
         <returnvalue>boolean</returnvalue>
        </para>
        <para>
         Are <type>aclitem</type>s equal?  (Notice that
         type <type>aclitem</type> lacks the usual set of comparison
         operators; it has only equality.  In turn, <type>aclitem</type>
         arrays can only be compared for equality.)
        </para>
        <para>
         <literal>'calvin=r*w/hobbes'::aclitem = 'calvin=r*w*/hobbes'::aclitem</literal>
         <returnvalue>f</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>aclitemeq</primary>
         </indexterm>
         <type>aclitem</type> <literal>=</literal> <type>aclitem</type>
         <returnvalue>boolean</returnvalue>
        </para>
        <para>
         <type>aclitem</type>相等吗?(注意，<type>aclitem</type>类型缺少比较操作符的通常集合;它只有相等。
         反而言之，<type>aclitem</type>数组只能进行相等比较。)
        </para>
        <para>
         <literal>'calvin=r*w/hobbes'::aclitem = 'calvin=r*w*/hobbes'::aclitem</literal>
         <returnvalue>f</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>aclcontains</primary>
         </indexterm>
         <type>aclitem[]</type> <literal>@&gt;</literal> <type>aclitem</type>
         <returnvalue>boolean</returnvalue>
        </para>
        <para>
         Does array contain the specified privileges?  (This is true if there
         is an array entry that matches the <type>aclitem</type>'s grantee and
         grantor, and has at least the specified set of privileges.)
        </para>
        <para>
         <literal>'{calvin=r*w/hobbes,hobbes=r*w*/postgres}'::aclitem[] @&gt; 'calvin=r*/hobbes'::aclitem</literal>
         <returnvalue>t</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>aclcontains</primary>
         </indexterm>
         <type>aclitem[]</type> <literal>@&gt;</literal> <type>aclitem</type>
         <returnvalue>boolean</returnvalue>
        </para>
        <para>
         数组是否包含指定的特权?(如果有一个数组条目与<type>aclitem</type>的被授权人和授予人相匹配，并且至少具有特权的指定集，则此选项为真。)
        </para>
        <para>
         <literal>'{calvin=r*w/hobbes,hobbes=r*w*/postgres}'::aclitem[] @&gt; 'calvin=r*/hobbes'::aclitem</literal>
         <returnvalue>t</returnvalue>
        </para></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>aclitem[]</type> <literal>~</literal> <type>aclitem</type>
         <returnvalue>boolean</returnvalue>
        </para>
        <para>
         This is a deprecated alias for <literal>@&gt;</literal>.
        </para>
        <para>
         <literal>'{calvin=r*w/hobbes,hobbes=r*w*/postgres}'::aclitem[] ~ 'calvin=r*/hobbes'::aclitem</literal>
         <returnvalue>t</returnvalue>
        </para></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <type>aclitem[]</type> <literal>~</literal> <type>aclitem</type>
         <returnvalue>boolean</returnvalue>
        </para>
        <para>
         这是<literal>@&gt;</literal>的已弃用别名。
        </para>
        <para>
         <literal>'{calvin=r*w/hobbes,hobbes=r*w*/postgres}'::aclitem[] ~ 'calvin=r*/hobbes'::aclitem</literal>
         <returnvalue>t</returnvalue>
        </para></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

<!--==========================orignal english content==========================
   <para>
    <xref linkend="functions-aclitem-fn-table"/> shows some additional
    functions to manage the <type>aclitem</type> type.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-aclitem-fn-table"/> 显示了一些额外的函数来管理<type>aclitem</type>类型。
   </para>

   <table id="functions-aclitem-fn-table">
<!--==========================orignal english content==========================
    <title><type>aclitem</type> Functions</title>
____________________________________________________________________________-->
    <title><type>aclitem</type> 函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>acldefault</primary>
        </indexterm>
        <function>acldefault</function> (
          <parameter>type</parameter> <type>"char"</type>,
          <parameter>ownerId</parameter> <type>oid</type> )
        <returnvalue>aclitem[]</returnvalue>
       </para>
       <para>
        Constructs an <type>aclitem</type> array holding the default access
        privileges for an object of type <parameter>type</parameter> belonging
        to the role with OID <parameter>ownerId</parameter>.  This represents
        the access privileges that will be assumed when an object's ACL entry
        is null.  (The default access privileges are described in
        <xref linkend="ddl-priv"/>.)
        The <parameter>type</parameter> parameter must be one of
        'c' for <literal>COLUMN</literal>,
        'r' for <literal>TABLE</literal> and table-like objects,
        's' for <literal>SEQUENCE</literal>,
        'd' for <literal>DATABASE</literal>,
        'f' for <literal>FUNCTION</literal> or <literal>PROCEDURE</literal>,
        'l' for <literal>LANGUAGE</literal>,
        'L' for <literal>LARGE OBJECT</literal>,
        'n' for <literal>SCHEMA</literal>,
        't' for <literal>TABLESPACE</literal>,
        'F' for <literal>FOREIGN DATA WRAPPER</literal>,
        'S' for <literal>FOREIGN SERVER</literal>,
        or
        'T' for <literal>TYPE</literal> or <literal>DOMAIN</literal>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>acldefault</primary>
        </indexterm>
        <function>acldefault</function> (
          <parameter>type</parameter> <type>"char"</type>,
          <parameter>ownerId</parameter> <type>oid</type> )
        <returnvalue>aclitem[]</returnvalue>
       </para>
       <para>
        构造一个<type>aclitem</type>数组，该数组持有<parameter>type</parameter>类型对象的默认访问特权，该对象属于OID为<parameter>ownerId</parameter>的角色。
        这表示当对象的ACL条目为空时所假定的访问特权。(默认的访问特权在<xref linkend="ddl-priv"/>中描述。)
        <parameter>type</parameter> 参数必须是下列中的一个
        'c' 对应 <literal>COLUMN</literal>,
        'r' 对应 <literal>TABLE</literal> 和类表对象,
        's' 对应 <literal>SEQUENCE</literal>,
        'd' 对应 <literal>DATABASE</literal>,
        'f' 对应 <literal>FUNCTION</literal> 或 <literal>PROCEDURE</literal>,
        'l' 对应 <literal>LANGUAGE</literal>,
        'L' 对应 <literal>LARGE OBJECT</literal>,
        'n' 对应 <literal>SCHEMA</literal>,
        't' 对应 <literal>TABLESPACE</literal>,
        'F' 对应 <literal>FOREIGN DATA WRAPPER</literal>,
        'S' 对应 <literal>FOREIGN SERVER</literal>,或
        'T' 对应 <literal>TYPE</literal> 或 <literal>DOMAIN</literal>.
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>aclexplode</primary>
        </indexterm>
        <function>aclexplode</function> ( <type>aclitem[]</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>grantor</parameter> <type>oid</type>,
        <parameter>grantee</parameter> <type>oid</type>,
        <parameter>privilege_type</parameter> <type>text</type>,
        <parameter>is_grantable</parameter> <type>boolean</type> )
       </para>
       <para>
        Returns the <type>aclitem</type> array as a set of rows.
        If the grantee is the pseudo-role PUBLIC, it is represented by zero in
        the <parameter>grantee</parameter> column.  Each granted privilege is
        represented as <literal>SELECT</literal>, <literal>INSERT</literal>,
        etc.  Note that each privilege is broken out as a separate row, so
        only one keyword appears in the <parameter>privilege_type</parameter>
        column.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>aclexplode</primary>
        </indexterm>
        <function>aclexplode</function> ( <type>aclitem[]</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>grantor</parameter> <type>oid</type>,
        <parameter>grantee</parameter> <type>oid</type>,
        <parameter>privilege_type</parameter> <type>text</type>,
        <parameter>is_grantable</parameter> <type>boolean</type> )
       </para>
       <para>
        以行集的形式返回<type>aclitem</type>数组。如果受让人是伪角色PUBLIC，则在<parameter>grantee</parameter>列中用0表示。
        每个被授予的特权都表示为<literal>SELECT</literal>, <literal>INSERT</literal>等。
        注意，每个特权被分割成单独的一行，因此在<parameter>privilege_type</parameter>列中只出现一个关键字。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>makeaclitem</primary>
        </indexterm>
        <function>makeaclitem</function> (
          <parameter>grantee</parameter> <type>oid</type>,
          <parameter>grantor</parameter> <type>oid</type>,
          <parameter>privileges</parameter> <type>text</type>,
          <parameter>is_grantable</parameter> <type>boolean</type> )
        <returnvalue>aclitem</returnvalue>
       </para>
       <para>
        Constructs an <type>aclitem</type> with the given properties.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>makeaclitem</primary>
        </indexterm>
        <function>makeaclitem</function> (
          <parameter>grantee</parameter> <type>oid</type>,
          <parameter>grantor</parameter> <type>oid</type>,
          <parameter>privileges</parameter> <type>text</type>,
          <parameter>is_grantable</parameter> <type>boolean</type> )
        <returnvalue>aclitem</returnvalue>
       </para>
       <para>
        使用给定的属性构造 <type>aclitem</type> 。
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="functions-info-schema-table"/> shows functions that
   determine whether a certain object is <firstterm>visible</firstterm> in the
   current schema search path.
   For example, a table is said to be visible if its
   containing schema is in the search path and no table of the same
   name appears earlier in the search path.  This is equivalent to the
   statement that the table can be referenced by name without explicit
   schema qualification.  Thus, to list the names of all visible tables:
<programlisting>
SELECT relname FROM pg_class WHERE pg_table_is_visible(oid);
</programlisting>
   For functions and operators, an object in the search path is said to be
   visible if there is no object of the same name <emphasis>and argument data
   type(s)</emphasis> earlier in the path.  For operator classes and families,
   both the name and the associated index access method are considered.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="functions-info-schema-table"/>展示了决定是否一个特定对象在当前模式搜索路径中<firstterm>可见</firstterm>的函数。
   例如，如果一个表所在的模式在当前搜索路径中并且在它之前没有出现过相同的名字，这个表就被说是可见的。
   这等价于在语句中表可以被用名称引用但不加显式的模式限定。因此，要列出所有可见表的名字：
<programlisting>
SELECT relname FROM pg_class WHERE pg_table_is_visible(oid);
</programlisting>
   对于函数和操作符，如果路径前面没有相同名称<emphasis>and argument data type(s)</emphasis>的对象，那么搜索路径中的对象就是可见的。
   对于操作符类和操作符族，要考虑名称和关联的索引访问方法。
  </para>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>search path</primary>
    <secondary>object visibility</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>搜索路径</primary>
    <secondary>对象可见性</secondary>
   </indexterm>

   <table id="functions-info-schema-table">
<!--==========================orignal english content==========================
    <title>Schema Visibility Inquiry Functions</title>
____________________________________________________________________________-->
    <title>模式可见性查询函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_collation_is_visible</primary>
        </indexterm>
        <function>pg_collation_is_visible</function> ( <parameter>collation</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is collation visible in search path?
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_collation_is_visible</primary>
        </indexterm>
        <function>pg_collation_is_visible</function> ( <parameter>collation</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        排序规则在搜索路径中可见吗？
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_conversion_is_visible</primary>
        </indexterm>
        <function>pg_conversion_is_visible</function> ( <parameter>conversion</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is conversion visible in search path?
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_conversion_is_visible</primary>
        </indexterm>
        <function>pg_conversion_is_visible</function> ( <parameter>conversion</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        转换在搜索路径中可见吗？
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_function_is_visible</primary>
        </indexterm>
        <function>pg_function_is_visible</function> ( <parameter>function</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is function visible in search path?
        (This also works for procedures and aggregates.)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_function_is_visible</primary>
        </indexterm>
        <function>pg_function_is_visible</function> ( <parameter>function</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        函数在搜索路径中可见吗？(这也适用于过程和聚合。)
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_opclass_is_visible</primary>
        </indexterm>
        <function>pg_opclass_is_visible</function> ( <parameter>opclass</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is operator class visible in search path?
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_opclass_is_visible</primary>
        </indexterm>
        <function>pg_opclass_is_visible</function> ( <parameter>opclass</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        操作符类在搜索路径中可见吗？
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_operator_is_visible</primary>
        </indexterm>
        <function>pg_operator_is_visible</function> ( <parameter>operator</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is operator visible in search path?
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_operator_is_visible</primary>
        </indexterm>
        <function>pg_operator_is_visible</function> ( <parameter>operator</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        操作符在搜索路径中可见吗？
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_opfamily_is_visible</primary>
        </indexterm>
        <function>pg_opfamily_is_visible</function> ( <parameter>opclass</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is operator family visible in search path?
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_opfamily_is_visible</primary>
        </indexterm>
        <function>pg_opfamily_is_visible</function> ( <parameter>opclass</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        操作符族在搜索路径中可见吗？
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_statistics_obj_is_visible</primary>
        </indexterm>
        <function>pg_statistics_obj_is_visible</function> ( <parameter>stat</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is statistics object visible in search path?
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_statistics_obj_is_visible</primary>
        </indexterm>
        <function>pg_statistics_obj_is_visible</function> ( <parameter>stat</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        统计对象在搜索路径中可见吗?
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_table_is_visible</primary>
        </indexterm>
        <function>pg_table_is_visible</function> ( <parameter>table</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is table visible in search path?
        (This works for all types of relations, including views, materialized
        views, indexes, sequences and foreign tables.)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_table_is_visible</primary>
        </indexterm>
        <function>pg_table_is_visible</function> ( <parameter>table</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        表在搜索路径中可见吗？(这适用于所有类型的关系，包括视图、物化视图、索引、序列和外部表。)
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_ts_config_is_visible</primary>
        </indexterm>
        <function>pg_ts_config_is_visible</function> ( <parameter>config</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is text search configuration visible in search path?
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_ts_config_is_visible</primary>
        </indexterm>
        <function>pg_ts_config_is_visible</function> ( <parameter>config</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        文本搜索配置在搜索路径可见吗?
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_ts_dict_is_visible</primary>
        </indexterm>
        <function>pg_ts_dict_is_visible</function> ( <parameter>dict</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is text search dictionary visible in search path?
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_ts_dict_is_visible</primary>
        </indexterm>
        <function>pg_ts_dict_is_visible</function> ( <parameter>dict</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        文本搜索字典在搜索路径可见吗?
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_ts_parser_is_visible</primary>
        </indexterm>
        <function>pg_ts_parser_is_visible</function> ( <parameter>parser</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is text search parser visible in search path?
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_ts_parser_is_visible</primary>
        </indexterm>
        <function>pg_ts_parser_is_visible</function> ( <parameter>parser</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        文本搜索解析器在搜索路径中可见吗?
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_ts_template_is_visible</primary>
        </indexterm>
        <function>pg_ts_template_is_visible</function> ( <parameter>template</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is text search template visible in search path?
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_ts_template_is_visible</primary>
        </indexterm>
        <function>pg_ts_template_is_visible</function> ( <parameter>template</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        文本搜索模板在搜索路径可见吗?
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_type_is_visible</primary>
        </indexterm>
        <function>pg_type_is_visible</function> ( <parameter>type</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is type (or domain) visible in search path?
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_type_is_visible</primary>
        </indexterm>
        <function>pg_type_is_visible</function> ( <parameter>type</parameter> <type>oid</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        类型(或域)在搜索路径中可见吗?
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    All these functions require object OIDs to identify the object to be
    checked.  If you want to test an object by name, it is convenient to use
    the OID alias types (<type>regclass</type>, <type>regtype</type>,
    <type>regprocedure</type>, <type>regoperator</type>, <type>regconfig</type>,
    or <type>regdictionary</type>),
    for example:
<programlisting>
SELECT pg_type_is_visible('myschema.widget'::regtype);
</programlisting>
    Note that it would not make much sense to test a non-schema-qualified
    type name in this way &mdash; if the name can be recognized at all, it must be visible.
   </para>
____________________________________________________________________________-->
   <para>
    所有这些函数都要求用对象 OID 来标识将被检查的对象。如果你想用名称来测试一个对象，使用 OID 别名类型（<type>regclass</type>、<type>regtype</type>、<type>regprocedure</type>、<type>regoperator</type>、<type>regconfig</type>或<type>regdictionary</type>）将会很方便。例如：
<programlisting>
SELECT pg_type_is_visible('myschema.widget'::regtype);
</programlisting>
    注意以这种方式测试一个非模式限定的类型名没什么意义 &mdash; 如果该名称完全能被识别，它必须是可见的。
   </para>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="functions-info-catalog-table"/> lists functions that
   extract information from the system catalogs.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="functions-info-catalog-table"/> 列出从系统目录中提取信息的函数。
  </para>

   <table id="functions-info-catalog-table">
<!--==========================orignal english content==========================
    <title>System Catalog Information Functions</title>
____________________________________________________________________________-->
    <title>系统目录信息函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>format_type</primary>
        </indexterm>
        <function>format_type</function> ( <parameter>type</parameter> <type>oid</type>, <parameter>typemod</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the SQL name for a data type that is identified by its type
        OID and possibly a type modifier.  Pass NULL for the type modifier if
        no specific modifier is known.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>format_type</primary>
        </indexterm>
        <function>format_type</function> ( <parameter>type</parameter> <type>oid</type>, <parameter>typemod</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回由其类型OID和可能的类型修饰符标识的数据类型的SQL名称。如果没有已知的类型修饰符，则传递NULL值给类型修饰符。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_constraintdef</primary>
        </indexterm>
        <function>pg_get_constraintdef</function> ( <parameter>constraint</parameter> <type>oid</type> <optional>, <parameter>pretty</parameter> <type>boolean</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Reconstructs the creating command for a constraint.
        (This is a decompiled reconstruction, not the original text
        of the command.)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_constraintdef</primary>
        </indexterm>
        <function>pg_get_constraintdef</function> ( <parameter>constraint</parameter> <type>oid</type> <optional>, <parameter>pretty</parameter> <type>boolean</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        重构为了约束的创建命令。(这是一个反编译的重构，而不是命令的原始文本。)
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_expr</primary>
        </indexterm>
        <function>pg_get_expr</function> ( <parameter>expr</parameter> <type>pg_node_tree</type>, <parameter>relation</parameter> <type>oid</type> <optional>, <parameter>pretty</parameter> <type>boolean</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Decompiles the internal form of an expression stored in the system
        catalogs, such as the default value for a column.  If the expression
        might contain Vars, specify the OID of the relation they refer to as
        the second parameter; if no Vars are expected, passing zero is
        sufficient.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_expr</primary>
        </indexterm>
        <function>pg_get_expr</function> ( <parameter>expr</parameter> <type>pg_node_tree</type>, <parameter>relation</parameter> <type>oid</type> <optional>, <parameter>pretty</parameter> <type>boolean</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        反编译存储在系统目录中的表达式的内部形式，例如列的默认值。
        如果表达式可能包含变量，则指定它们所指向的关系的OID作为第二个参数;如果没有预期的变量，传递0就可以了。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_functiondef</primary>
        </indexterm>
        <function>pg_get_functiondef</function> ( <parameter>func</parameter> <type>oid</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Reconstructs the creating command for a function or procedure.
        (This is a decompiled reconstruction, not the original text
        of the command.)
        The result is a complete <command>CREATE OR REPLACE FUNCTION</command>
        or <command>CREATE OR REPLACE PROCEDURE</command> statement.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_functiondef</primary>
        </indexterm>
        <function>pg_get_functiondef</function> ( <parameter>func</parameter> <type>oid</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        重构为了函数或过程的创建命令。(这是一个反编译的重构，而不是命令的原始文本。)
        结果是一个完整的<command>CREATE OR REPLACE FUNCTION</command> 或 <command>CREATE OR REPLACE PROCEDURE</command>语句。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_function_arguments</primary>
        </indexterm>
        <function>pg_get_function_arguments</function> ( <parameter>func</parameter> <type>oid</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Reconstructs the argument list of a function or procedure, in the form
        it would need to appear in within <command>CREATE FUNCTION</command>
        (including default values).
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_function_arguments</primary>
        </indexterm>
        <function>pg_get_function_arguments</function> ( <parameter>func</parameter> <type>oid</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        重新构造函数或过程的参数列表，以其在 <command>CREATE FUNCTION</command>里面需要出现的形式(包括默认值)。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_function_identity_arguments</primary>
        </indexterm>
        <function>pg_get_function_identity_arguments</function> ( <parameter>func</parameter> <type>oid</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Reconstructs the argument list necessary to identify a function or
        procedure, in the form it would need to appear in within commands such
        as <command>ALTER FUNCTION</command>.  This form omits default values.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_function_identity_arguments</primary>
        </indexterm>
        <function>pg_get_function_identity_arguments</function> ( <parameter>func</parameter> <type>oid</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        重新构造标识函数或过程所需的参数列表，以其应出现在<command>ALTER FUNCTION</command>等命令中的形式。这个表单省略默认值。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_function_result</primary>
        </indexterm>
        <function>pg_get_function_result</function> ( <parameter>func</parameter> <type>oid</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Reconstructs the <literal>RETURNS</literal> clause of a function, in
        the form it would need to appear in within <command>CREATE
        FUNCTION</command>.  Returns <literal>NULL</literal> for a procedure.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_function_result</primary>
        </indexterm>
        <function>pg_get_function_result</function> ( <parameter>func</parameter> <type>oid</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        重构函数的<literal>RETURNS</literal>子句，以其需要出现在<command>CREATE FUNCTION</command>中的形式。对于过程，返回<literal>NULL</literal>。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_indexdef</primary>
        </indexterm>
        <function>pg_get_indexdef</function> ( <parameter>index</parameter> <type>oid</type> <optional>, <parameter>column</parameter> <type>integer</type>, <parameter>pretty</parameter> <type>boolean</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Reconstructs the creating command for an index.
        (This is a decompiled reconstruction, not the original text
        of the command.)  If <parameter>column</parameter> is supplied and is
        not zero, only the definition of that column is reconstructed.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_indexdef</primary>
        </indexterm>
        <function>pg_get_indexdef</function> ( <parameter>index</parameter> <type>oid</type> <optional>, <parameter>column</parameter> <type>integer</type>, <parameter>pretty</parameter> <type>boolean</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        重构针对索引的创建命令。(这是一个反编译的重构，而不是命令的原始文本。)如果提供了<parameter>column</parameter>而且不为零，则只重构该列的定义。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_keywords</primary>
        </indexterm>
        <function>pg_get_keywords</function> ()
        <returnvalue>setof record</returnvalue>
        ( <parameter>word</parameter> <type>text</type>,
        <parameter>catcode</parameter> <type>"char"</type>,
        <parameter>catdesc</parameter> <type>text</type> )
       </para>
       <para>
        Returns a set of records describing the SQL keywords recognized by the
        server.  The <parameter>word</parameter> column contains the
        keyword.  The <parameter>catcode</parameter> column contains a
        category code: <literal>U</literal> for an unreserved
        keyword, <literal>C</literal> for a keyword that can be a column
        name, <literal>T</literal> for a keyword that can be a type or
        function name, or <literal>R</literal> for a fully reserved keyword.
        The <parameter>catdesc</parameter> column contains a
        possibly-localized string describing the category.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_keywords</primary>
        </indexterm>
        <function>pg_get_keywords</function> ()
        <returnvalue>setof record</returnvalue>
        ( <parameter>word</parameter> <type>text</type>,
        <parameter>catcode</parameter> <type>"char"</type>,
        <parameter>catdesc</parameter> <type>text</type> )
       </para>
       <para>
        返回一组描述服务器识别的SQL关键字的记录。<parameter>word</parameter>列包含关键字。
        <parameter>catcode</parameter>列包含一个类别代码:<literal>U</literal>表示无保留关键字，<literal>C</literal>表示可以是列名的关键字，<literal>T</literal>表示可以是类型或函数名的关键字，或者<literal>R</literal>表示完全保留关键字。
        <parameter>catdesc</parameter>列包含描述类别的可能本地化字符串。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_ruledef</primary>
        </indexterm>
        <function>pg_get_ruledef</function> ( <parameter>rule</parameter> <type>oid</type> <optional>, <parameter>pretty</parameter> <type>boolean</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Reconstructs the creating command for a rule.
        (This is a decompiled reconstruction, not the original text
        of the command.)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_ruledef</primary>
        </indexterm>
        <function>pg_get_ruledef</function> ( <parameter>rule</parameter> <type>oid</type> <optional>, <parameter>pretty</parameter> <type>boolean</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        重构针对规则的创建命令。(这是一个反编译的重构，而不是命令的原始文本。)
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_serial_sequence</primary>
        </indexterm>
        <function>pg_get_serial_sequence</function> ( <parameter>table</parameter> <type>text</type>, <parameter>column</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the name of the sequence associated with a column,
        or NULL if no sequence is associated with the column.
        If the column is an identity column, the associated sequence is the
        sequence internally created for that column.
        For columns created using one of the serial types
        (<type>serial</type>, <type>smallserial</type>, <type>bigserial</type>),
        it is the sequence created for that serial column definition.
        In the latter case, the association can be modified or removed
        with <command>ALTER SEQUENCE OWNED BY</command>.
        (This function probably should have been
        called <function>pg_get_owned_sequence</function>; its current name
        reflects the fact that it has historically been used with serial-type
        columns.)  The first parameter is a table name with optional
        schema, and the second parameter is a column name.  Because the first
        parameter potentially contains both schema and table names, it is
        parsed per usual SQL rules, meaning it is lower-cased by default.
        The second parameter, being just a column name, is treated literally
        and so has its case preserved.  The result is suitably formatted
        for passing to the sequence functions (see
        <xref linkend="functions-sequence"/>).
       </para>
       <para>
        A typical use is in reading the current value of the sequence for an
        identity or serial column, for example:
<programlisting>
SELECT currval(pg_get_serial_sequence('sometable', 'id'));
</programlisting>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_serial_sequence</primary>
        </indexterm>
        <function>pg_get_serial_sequence</function> ( <parameter>table</parameter> <type>text</type>, <parameter>column</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回与列相关联的序列名称，如果没有序列与该列相关联则返回NULL。
        如果列是标识列，则关联序列是在内部为该列创建的序列。
        对于使用一种串行类型(<type>serial</type>, <type>smallserial</type>, <type>bigserial</type>)创建的列，它是为该串行列定义创建的序列。
        在后一种情况下，可以使用<command>ALTER SEQUENCE OWNED BY</command>修改或删除关联。
        (这个函数可能应该被称为<function>pg_get_owned_sequence</function>;它的当前名称反映了它在历史上曾与串行类型的列一起使用。)
        第一个参数是具有可选模式的表名，第二个参数是列名。
        由于第一个参数可能包含模式名和表名，因此按照通常的SQL规则解析它，这意味着默认情况下它是小写的。
        第二个参数只是一个列名，按照字面来处理，因此保留了它的大小写。结果经过了适当的格式化，可以传递给序列函数(参见<xref linkend="functions-sequence"/>)。
       </para>
       <para>
        典型的用法是读取序列的当前值以获取标识或串行列，示例如下:
<programlisting>
SELECT currval(pg_get_serial_sequence('sometable', 'id'));
</programlisting>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_statisticsobjdef</primary>
        </indexterm>
        <function>pg_get_statisticsobjdef</function> ( <parameter>statobj</parameter> <type>oid</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Reconstructs the creating command for an extended statistics object.
        (This is a decompiled reconstruction, not the original text
        of the command.)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_statisticsobjdef</primary>
        </indexterm>
        <function>pg_get_statisticsobjdef</function> ( <parameter>statobj</parameter> <type>oid</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        重构针对扩展统计对象的创建命令。(这是一个反编译的重构，而不是命令的原始文本。)
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_triggerdef</primary>
        </indexterm>
<function>pg_get_triggerdef</function> ( <parameter>trigger</parameter> <type>oid</type> <optional>, <parameter>pretty</parameter> <type>boolean</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Reconstructs the creating command for a trigger.
        (This is a decompiled reconstruction, not the original text
        of the command.)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_triggerdef</primary>
        </indexterm>
<function>pg_get_triggerdef</function> ( <parameter>trigger</parameter> <type>oid</type> <optional>, <parameter>pretty</parameter> <type>boolean</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        重构针对触发器的创建命令。(这是一个反编译的重构，而不是命令的原始文本。)
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_userbyid</primary>
        </indexterm>
        <function>pg_get_userbyid</function> ( <parameter>role</parameter> <type>oid</type> )
        <returnvalue>name</returnvalue>
       </para>
       <para>
        Returns a role's name given its OID.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_userbyid</primary>
        </indexterm>
        <function>pg_get_userbyid</function> ( <parameter>role</parameter> <type>oid</type> )
        <returnvalue>name</returnvalue>
       </para>
       <para>
        根据OID返回角色名。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_viewdef</primary>
        </indexterm>
        <function>pg_get_viewdef</function> ( <parameter>view</parameter> <type>oid</type> <optional>, <parameter>pretty</parameter> <type>boolean</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Reconstructs the underlying <command>SELECT</command> command for a
        view or materialized view.  (This is a decompiled reconstruction, not
        the original text of the command.)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_viewdef</primary>
        </indexterm>
        <function>pg_get_viewdef</function> ( <parameter>view</parameter> <type>oid</type> <optional>, <parameter>pretty</parameter> <type>boolean</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        重构针对视图或物化视图的<command>SELECT</command>命令。(这是一个反编译的重构，而不是命令的原始文本。)
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>pg_get_viewdef</function> ( <parameter>view</parameter> <type>oid</type>, <parameter>wrap_column</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Reconstructs the underlying <command>SELECT</command> command for a
        view or materialized view.  (This is a decompiled reconstruction, not
        the original text of the command.)  In this form of the function,
        pretty-printing is always enabled, and long lines are wrapped to try
        to keep them shorter than the specified number of columns.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>pg_get_viewdef</function> ( <parameter>view</parameter> <type>oid</type>, <parameter>wrap_column</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        重构针对视图或物化视图的底层<command>SELECT</command>命令。(这是一个反编译的重构，而不是命令的原始文本。)
        在这种形式的函数中，总是启用美观打印，并对长行进行换行，以尽量使它们小于指定的列数。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>pg_get_viewdef</function> ( <parameter>view</parameter> <type>text</type> <optional>, <parameter>pretty</parameter> <type>boolean</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Reconstructs the underlying <command>SELECT</command> command for a
        view or materialized view, working from a textual name for the view
        rather than its OID.  (This is deprecated; use the OID variant
        instead.)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>pg_get_viewdef</function> ( <parameter>view</parameter> <type>text</type> <optional>, <parameter>pretty</parameter> <type>boolean</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        根据视图的文本名称而不是它的OID，重构针对视图或物化视图的底层<command>SELECT</command>命令。(这是弃用;请使用OID变体。)
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_index_column_has_property</primary>
        </indexterm>
        <function>pg_index_column_has_property</function> ( <parameter>index</parameter> <type>regclass</type>, <parameter>column</parameter> <type>integer</type>, <parameter>property</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Tests whether an index column has the named property.
        Common index column properties are listed in
        <xref linkend="functions-info-index-column-props"/>.
        (Note that extension access methods can define additional property
        names for their indexes.)
        <literal>NULL</literal> is returned if the property name is not known
        or does not apply to the particular object, or if the OID or column
        number does not identify a valid object.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_index_column_has_property</primary>
        </indexterm>
        <function>pg_index_column_has_property</function> ( <parameter>index</parameter> <type>regclass</type>, <parameter>column</parameter> <type>integer</type>, <parameter>property</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试一个索引列是否具有命名属性。<xref linkend="functions-info-index-column-props"/>列出了常用索引列属性。
        (注意，扩展访问方法可以为其索引定义额外的属性名。)
        如果属性名未知或不适用于特定对象，或者OID或列号不能识别有效的对象，则返回<literal>NULL</literal>。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_index_has_property</primary>
        </indexterm>
        <function>pg_index_has_property</function> ( <parameter>index</parameter> <type>regclass</type>, <parameter>property</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Tests whether an index has the named property.
        Common index properties are listed in
        <xref linkend="functions-info-index-props"/>.
        (Note that extension access methods can define additional property
        names for their indexes.)
        <literal>NULL</literal> is returned if the property name is not known
        or does not apply to the particular object, or if the OID does not
        identify a valid object.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_index_has_property</primary>
        </indexterm>
        <function>pg_index_has_property</function> ( <parameter>index</parameter> <type>regclass</type>, <parameter>property</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试一个索引是否具有命名属性。<xref linkend="functions-info-index-props"/>列出了常用的索引属性。
        (注意，扩展访问方法可以为其索引定义额外的属性名。)
        如果属性名未知或不适用于特定对象，或者OID不能识别有效的对象，则返回<literal>NULL</literal>。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_indexam_has_property</primary>
        </indexterm>
        <function>pg_indexam_has_property</function> ( <parameter>am</parameter> <type>oid</type>, <parameter>property</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Tests whether an index access method has the named property.
        Access method properties are listed in
        <xref linkend="functions-info-indexam-props"/>.
        <literal>NULL</literal> is returned if the property name is not known
        or does not apply to the particular object, or if the OID does not
        identify a valid object.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_indexam_has_property</primary>
        </indexterm>
        <function>pg_indexam_has_property</function> ( <parameter>am</parameter> <type>oid</type>, <parameter>property</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        测试索引访问方法是否具有命名属性。访问方法属性如<xref linkend="functions-info-indexam-props"/>所示。
        如果属性名未知或不适用于特定对象，或者OID不能识别有效的对象，则返回<literal>NULL</literal>。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_options_to_table</primary>
        </indexterm>
        <function>pg_options_to_table</function> ( <parameter>options_array</parameter> <type>text[]</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>option_name</parameter> <type>text</type>,
        <parameter>option_value</parameter> <type>text</type> )
       </para>
       <para>
        Returns the set of storage options represented by a value from
        <structname>pg_class</structname>.<structfield>reloptions</structfield> or
        <structname>pg_attribute</structname>.<structfield>attoptions</structfield>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_options_to_table</primary>
        </indexterm>
        <function>pg_options_to_table</function> ( <parameter>options_array</parameter> <type>text[]</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>option_name</parameter> <type>text</type>,
        <parameter>option_value</parameter> <type>text</type> )
       </para>
       <para>
        返回源自<structname>pg_class</structname>.<structfield>reloptions</structfield> 或 <structname>pg_attribute</structname>.<structfield>attoptions</structfield>的值表示的存储选项集。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_tablespace_databases</primary>
        </indexterm>
        <function>pg_tablespace_databases</function> ( <parameter>tablespace</parameter> <type>oid</type> )
        <returnvalue>setof oid</returnvalue>
       </para>
       <para>
        Returns the set of OIDs of databases that have objects stored in the
        specified tablespace.  If this function returns any rows, the
        tablespace is not empty and cannot be dropped.  To identify the specific
        objects populating the tablespace, you will need to connect to the
        database(s) identified by <function>pg_tablespace_databases</function>
        and query their <structname>pg_class</structname> catalogs.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_tablespace_databases</primary>
        </indexterm>
        <function>pg_tablespace_databases</function> ( <parameter>tablespace</parameter> <type>oid</type> )
        <returnvalue>setof oid</returnvalue>
       </para>
       <para>
        返回具有存储在指定表空间中的对象的数据库的OIDs集。
        如果这个函数返回了任何行，那么表空间就不是空的，且不能被删除。
        要识别填充表空间的特定对象，需要连接到由<function>pg_tablespace_databases</function>标识的数据库，并查询它们的<structname>pg_class</structname>目录。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_tablespace_location</primary>
        </indexterm>
        <function>pg_tablespace_location</function> ( <parameter>tablespace</parameter> <type>oid</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the file system path that this tablespace is located in.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_tablespace_location</primary>
        </indexterm>
        <function>pg_tablespace_location</function> ( <parameter>tablespace</parameter> <type>oid</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回表空间所在的文件系统路径。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_typeof</primary>
        </indexterm>
        <function>pg_typeof</function> ( <type>"any"</type> )
        <returnvalue>regtype</returnvalue>
       </para>
       <para>
        Returns the OID of the data type of the value that is passed to it.
        This can be helpful for troubleshooting or dynamically constructing
        SQL queries.  The function is declared as
        returning <type>regtype</type>, which is an OID alias type (see
        <xref linkend="datatype-oid"/>); this means that it is the same as an
        OID for comparison purposes but displays as a type name.
       </para>
       <para>
        For example:
<programlisting>
SELECT pg_typeof(33);
 pg_typeof
-&minus;-&minus;-&minus;-&minus;-&minus;-
 integer

SELECT typlen FROM pg_type WHERE oid = pg_typeof(33);
 typlen
-&minus;-&minus;-&minus;-&minus;
      4
</programlisting>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_typeof</primary>
        </indexterm>
        <function>pg_typeof</function> ( <type>"any"</type> )
        <returnvalue>regtype</returnvalue>
       </para>
       <para>
        返回传递值给它的数据类型的OID。这对于故障排除或动态构造SQL查询很有帮助。
        函数声明为返回<type>regtype</type>，它是一个OID别名类型(see <xref linkend="datatype-oid"/>);
        这意味着，为了比较，它与OID相同，但显示为类型名。
       </para>
       <para>
        例如:
<programlisting>
SELECT pg_typeof(33);
 pg_typeof
-----------
 integer

SELECT typlen FROM pg_type WHERE oid = pg_typeof(33);
 typlen
--------
      4
</programlisting>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>COLLATION FOR</primary>
        </indexterm>
        <function>COLLATION FOR</function> ( <type>"any"</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the name of the collation of the value that is passed to it.
        The value is quoted and schema-qualified if necessary.  If no
        collation was derived for the argument expression,
        then <literal>NULL</literal> is returned.  If the argument is not of a
        collatable data type, then an error is raised.
       </para>
       <para>
        For example:
<programlisting>
SELECT collation for (description) FROM pg_description LIMIT 1;
 pg_collation_for
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 "default"

SELECT collation for ('foo' COLLATE "de_DE");
 pg_collation_for
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 "de_DE"
</programlisting>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>COLLATION FOR</primary>
        </indexterm>
        <function>COLLATION FOR</function> ( <type>"any"</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回传递值给它的排序规则的名称。如果需要，该值会被引号括起来，并使用模式限定。
        如果没有为参数表达式派生排序规则，则返回<literal>NULL</literal>。如果参数不是可排序数据类型，则会引发错误。
       </para>
       <para>
        例如:
<programlisting>
SELECT collation for (description) FROM pg_description LIMIT 1;
 pg_collation_for
------------------
 "default"

SELECT collation for ('foo' COLLATE "de_DE");
 pg_collation_for
------------------
 "de_DE"
</programlisting>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_regclass</primary>
        </indexterm>
        <function>to_regclass</function> ( <type>text</type> )
        <returnvalue>regclass</returnvalue>
       </para>
       <para>
        Translates a textual relation name to its OID.  A similar result is
        obtained by casting the string to type <type>regclass</type> (see
        <xref linkend="datatype-oid"/>); however, this function will return
        <literal>NULL</literal> rather than throwing an error if the name is
        not found.  Also unlike the cast, this does not accept
        a numeric OID as input.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_regclass</primary>
        </indexterm>
        <function>to_regclass</function> ( <type>text</type> )
        <returnvalue>regclass</returnvalue>
       </para>
       <para>
        将文本关系名转换为它的OID。通过将字符串类型转换为<type>regclass</type>可以得到类似的结果(参见<xref linkend="datatype-oid"/>);
        但是，如果没有找到名称，这个函数将返回<literal>NULL</literal>而不会抛出错误。与强制转换不同的是，它不接受数字OID作为输入。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_regcollation</primary>
        </indexterm>
        <function>to_regcollation</function> ( <type>text</type> )
        <returnvalue>regcollation</returnvalue>
       </para>
       <para>
        Translates a textual collation name to its OID.  A similar result is
        obtained by casting the string to type <type>regcollation</type> (see
        <xref linkend="datatype-oid"/>); however, this function will return
        <literal>NULL</literal> rather than throwing an error if the name is
        not found.  Also unlike the cast, this does not accept
        a numeric OID as input.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_regcollation</primary>
        </indexterm>
        <function>to_regcollation</function> ( <type>text</type> )
        <returnvalue>regcollation</returnvalue>
       </para>
       <para>
        将文本排序规则名称转换为它的OID。通过将字符串类型转换为<type>regcollation</type>(参见<xref linkend="datatype-oid"/>)可以得到类似的结果;
        但是，如果没有找到名称，这个函数将返回<literal>NULL</literal>而不会抛出错误。与强制转换不同的是，它不接受数字OID作为输入。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_regnamespace</primary>
        </indexterm>
        <function>to_regnamespace</function> ( <type>text</type> )
        <returnvalue>regnamespace</returnvalue>
       </para>
       <para>
        Translates a textual schema name to its OID.  A similar result is
        obtained by casting the string to type <type>regnamespace</type> (see
        <xref linkend="datatype-oid"/>); however, this function will return
        <literal>NULL</literal> rather than throwing an error if the name is
        not found.  Also unlike the cast, this does not accept
        a numeric OID as input.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_regnamespace</primary>
        </indexterm>
        <function>to_regnamespace</function> ( <type>text</type> )
        <returnvalue>regnamespace</returnvalue>
       </para>
       <para>
        将文本模式名转换为它的OID。通过将字符串转换为<type>regnamespace</type>类型(参见<xref linkend="datatype-oid"/>)可以得到类似的结果;
        但是，如果没有找到名称，这个函数将返回<literal>NULL</literal>而不会抛出错误。与强制转换不同的是，它不接受数字OID作为输入。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_regoper</primary>
        </indexterm>
        <function>to_regoper</function> ( <type>text</type> )
        <returnvalue>regoper</returnvalue>
       </para>
       <para>
        Translates a textual operator name to its OID.  A similar result is
        obtained by casting the string to type <type>regoper</type> (see
        <xref linkend="datatype-oid"/>); however, this function will return
        <literal>NULL</literal> rather than throwing an error if the name is
        not found or is ambiguous.  Also unlike the cast, this does not accept
        a numeric OID as input.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_regoper</primary>
        </indexterm>
        <function>to_regoper</function> ( <type>text</type> )
        <returnvalue>regoper</returnvalue>
       </para>
       <para>
        将文本操作符名称转换为它的OID。通过将字符串类型转换为<type>regoper</type>(参见<xref linkend="datatype-oid"/>)可以得到类似的结果;
        但是，如果找不到名称或名称有多义性，该函数将返回<literal>NULL</literal>而不会抛出错误。与强制转换不同的是，它不接受数字OID作为输入。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_regoperator</primary>
        </indexterm>
        <function>to_regoperator</function> ( <type>text</type> )
        <returnvalue>regoperator</returnvalue>
       </para>
       <para>
        Translates a textual operator name (with parameter types) to its OID.  A similar result is
        obtained by casting the string to type <type>regoperator</type> (see
        <xref linkend="datatype-oid"/>); however, this function will return
        <literal>NULL</literal> rather than throwing an error if the name is
        not found.  Also unlike the cast, this does not accept
        a numeric OID as input.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_regoperator</primary>
        </indexterm>
        <function>to_regoperator</function> ( <type>text</type> )
        <returnvalue>regoperator</returnvalue>
       </para>
       <para>
        将文本操作符名称(带有参数类型)转换为其OID。通过将字符串转换为<type>regoperator</type>类型(参见<xref linkend="datatype-oid"/>节)可以得到类似的结果;
        但是，如果没有找到名称，这个函数将返回<literal>NULL</literal>而不会抛出错误。与强制转换不同的是，它不接受数字OID作为输入。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_regproc</primary>
        </indexterm>
        <function>to_regproc</function> ( <type>text</type> )
        <returnvalue>regproc</returnvalue>
       </para>
       <para>
        Translates a textual function or procedure name to its OID.  A similar result is
        obtained by casting the string to type <type>regproc</type> (see
        <xref linkend="datatype-oid"/>); however, this function will return
        <literal>NULL</literal> rather than throwing an error if the name is
        not found or is ambiguous.  Also unlike the cast, this does not accept
        a numeric OID as input.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_regproc</primary>
        </indexterm>
        <function>to_regproc</function> ( <type>text</type> )
        <returnvalue>regproc</returnvalue>
       </para>
       <para>
        将文本函数或过程名转换为其OID。通过将字符串转换为<type>regproc</type>类型(参见<xref linkend="datatype-oid"/>)可以得到类似的结果;
        但是，如果找不到名称或名称有多义性，该函数将返回<literal>NULL</literal>而不会抛出错误。与强制转换不同的是，它不接受数字OID作为输入。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_regprocedure</primary>
        </indexterm>
        <function>to_regprocedure</function> ( <type>text</type> )
        <returnvalue>regprocedure</returnvalue>
       </para>
       <para>
        Translates a textual function or procedure name (with argument types) to its OID.  A similar result is
        obtained by casting the string to type <type>regprocedure</type> (see
        <xref linkend="datatype-oid"/>); however, this function will return
        <literal>NULL</literal> rather than throwing an error if the name is
        not found.  Also unlike the cast, this does not accept
        a numeric OID as input.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_regprocedure</primary>
        </indexterm>
        <function>to_regprocedure</function> ( <type>text</type> )
        <returnvalue>regprocedure</returnvalue>
       </para>
       <para>
        将文本函数或过程名(带有参数类型)转换为其OID。通过将字符串类型转换为<type>regprocedure</type>可以得到类似的结果(参见<xref linkend="datatype-oid"/>);
        但是，如果没有找到名称，这个函数将返回<literal>NULL</literal>而不会抛出错误。与强制转换不同的是，它不接受数字OID作为输入。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_regrole</primary>
        </indexterm>
        <function>to_regrole</function> ( <type>text</type> )
        <returnvalue>regrole</returnvalue>
       </para>
       <para>
        Translates a textual role name to its OID.  A similar result is
        obtained by casting the string to type <type>regrole</type> (see
        <xref linkend="datatype-oid"/>); however, this function will return
        <literal>NULL</literal> rather than throwing an error if the name is
        not found.  Also unlike the cast, this does not accept
        a numeric OID as input.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_regrole</primary>
        </indexterm>
        <function>to_regrole</function> ( <type>text</type> )
        <returnvalue>regrole</returnvalue>
       </para>
       <para>
        将文本角色名转换为它的OID。通过将字符串类型转换为<type>regrole</type>可以得到类似的结果(参见<xref linkend="datatype-oid"/>);
        但是，如果没有找到名称，这个函数将返回<literal>NULL</literal>而不会抛出错误。与强制转换不同的是，它不接受数字OID作为输入。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_regtype</primary>
        </indexterm>
        <function>to_regtype</function> ( <type>text</type> )
        <returnvalue>regtype</returnvalue>
       </para>
       <para>
        Translates a textual type name to its OID.  A similar result is
        obtained by casting the string to type <type>regtype</type> (see
        <xref linkend="datatype-oid"/>); however, this function will return
        <literal>NULL</literal> rather than throwing an error if the name is
        not found.  Also unlike the cast, this does not accept
        a numeric OID as input.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_regtype</primary>
        </indexterm>
        <function>to_regtype</function> ( <type>text</type> )
        <returnvalue>regtype</returnvalue>
       </para>
       <para>
        将文本类型名转换为它的OID。通过将字符串类型转换为<type>regtype</type>可以得到类似的结果(参见<xref linkend="datatype-oid"/>);
        但是，如果没有找到名称，这个函数将返回<literal>NULL</literal>而不会抛出错误。与强制转换不同的是，它不接受数字OID作为输入。
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
  <para>
   Most of the functions that reconstruct (decompile) database objects
   have an optional <parameter>pretty</parameter> flag, which
   if <literal>true</literal> causes the result to
   be <quote>pretty-printed</quote>.  Pretty-printing suppresses unnecessary
   parentheses and adds whitespace for legibility.
   The pretty-printed format is more readable, but the default format
   is more likely to be interpreted the same way by future versions of
   <productname>PostgreSQL</productname>; so avoid using pretty-printed output
   for dump purposes.  Passing <literal>false</literal> for
   the <parameter>pretty</parameter> parameter yields the same result as
   omitting the parameter.
  </para>
____________________________________________________________________________-->
  <para>
   大多数重构(反编译)数据库对象的函数都有一个可选的 <parameter>pretty</parameter>标志，如果为<literal>true</literal>，结果将被<quote>pretty-printed</quote>。
   美观打印会抑制不必要的圆括号，并为易读性增加空格。
   美观打印的格式可读性更好，但是默认格式更有可能被<productname>PostgreSQL</productname>的未来版本以同样的方式解释;
   因此，避免为转储目的使用美观打印的输出。为<parameter>pretty</parameter>参数传递<literal>false</literal>会产生与省略参数相同的结果。
  </para>

  <table id="functions-info-index-column-props">
<!--==========================orignal english content==========================
   <title>Index Column Properties</title>
____________________________________________________________________________-->
   <title>索引列属性</title>
   <tgroup cols="2">
    <thead>
<!--==========================orignal english content==========================
     <row><entry>Name</entry><entry>Description</entry></row>
____________________________________________________________________________-->
     <row><entry>名称</entry><entry>描述</entry></row>
    </thead>
    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>asc</literal></entry>
      <entry>Does the column sort in ascending order on a forward scan?
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>asc</literal></entry>
      <entry>在向前扫描时列是按照升序排列吗？
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>desc</literal></entry>
      <entry>Does the column sort in descending order on a forward scan?
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>desc</literal></entry>
      <entry>在向前扫描时列是按照降序排列吗？
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>nulls_first</literal></entry>
      <entry>Does the column sort with nulls first on a forward scan?
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>nulls_first</literal></entry>
      <entry>在向前扫描时列排序会把空值排在前面吗？
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>nulls_last</literal></entry>
      <entry>Does the column sort with nulls last on a forward scan?
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>nulls_last</literal></entry>
      <entry>在向前扫描时列排序会把空值排在最后吗？
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>orderable</literal></entry>
      <entry>Does the column possess any defined sort ordering?
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>orderable</literal></entry>
      <entry>列具有已定义的排序顺序吗？
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>distance_orderable</literal></entry>
      <entry>Can the column be scanned in order by a <quote>distance</quote>
      operator, for example <literal>ORDER BY col &lt;-&gt; constant</literal> ?
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>distance_orderable</literal></entry>
      <entry>列能否通过一个<quote>distance</quote>操作符（例如<literal>ORDER BY col &lt;-&gt; constant</literal>）有序地扫描？
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>returnable</literal></entry>
      <entry>Can the column value be returned by an index-only scan?
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>returnable</literal></entry>
      <entry>列值是否可以通过一次只用索引扫描返回？
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>search_array</literal></entry>
      <entry>Does the column natively support <literal>col = ANY(array)</literal>
      searches?
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>search_array</literal></entry>
      <entry>列是否天然支持<literal>col = ANY(array)</literal>搜索？
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>search_nulls</literal></entry>
      <entry>Does the column support <literal>IS NULL</literal> and
      <literal>IS NOT NULL</literal> searches?
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>search_nulls</literal></entry>
      <entry>列是否支持<literal>IS NULL</literal>和<literal>IS NOT NULL</literal>搜索？
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table id="functions-info-index-props">
<!--==========================orignal english content==========================
   <title>Index Properties</title>
____________________________________________________________________________-->
   <title>索引性质</title>
   <tgroup cols="2">
    <thead>
<!--==========================orignal english content==========================
     <row><entry>Name</entry><entry>Description</entry></row>
____________________________________________________________________________-->
     <row><entry>名称</entry><entry>描述</entry></row>
    </thead>
    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>clusterable</literal></entry>
      <entry>Can the index be used in a <literal>CLUSTER</literal> command?
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>clusterable</literal></entry>
      <entry>索引是否可以用于<literal>CLUSTER</literal>命令？
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>index_scan</literal></entry>
      <entry>Does the index support plain (non-bitmap) scans?
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>index_scan</literal></entry>
      <entry>索引是否支持普通扫描（非位图）？
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>bitmap_scan</literal></entry>
      <entry>Does the index support bitmap scans?
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>bitmap_scan</literal></entry>
      <entry>索引是否支持位图扫描？
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>backward_scan</literal></entry>
      <entry>Can the scan direction be changed in mid-scan (to
             support <literal>FETCH BACKWARD</literal> on a cursor without
             needing materialization)?
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>backward_scan</literal></entry>
      <entry>在扫描中扫描方向能否被更改（为了支持游标上无需物化的<literal>FETCH BACKWARD</literal>）？
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table id="functions-info-indexam-props">
<!--==========================orignal english content==========================
   <title>Index Access Method Properties</title>
____________________________________________________________________________-->
   <title>索引访问方法性质</title>
   <tgroup cols="2">
    <thead>
<!--==========================orignal english content==========================
     <row><entry>Name</entry><entry>Description</entry></row>
____________________________________________________________________________-->
     <row><entry>名称</entry><entry>描述</entry></row>
    </thead>
    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>can_order</literal></entry>
      <entry>Does the access method support <literal>ASC</literal>,
      <literal>DESC</literal> and related keywords in
      <literal>CREATE INDEX</literal>?
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>can_order</literal></entry>
      <entry>访问方法是否支持<literal>ASC</literal>、<literal>DESC</literal>以及<literal>CREATE INDEX</literal>中的有关关键词？
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>can_unique</literal></entry>
      <entry>Does the access method support unique indexes?
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>can_unique</literal></entry>
      <entry>访问方法是否支持唯一索引？
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>can_multi_col</literal></entry>
      <entry>Does the access method support indexes with multiple columns?
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>can_multi_col</literal></entry>
      <entry>访问方法是否支持多列索引？
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>can_exclude</literal></entry>
      <entry>Does the access method support exclusion constraints?
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>can_exclude</literal></entry>
      <entry>访问方法是否支持排除约束？
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>can_include</literal></entry>
      <entry>Does the access method support the <literal>INCLUDE</literal>
        clause of <literal>CREATE INDEX</literal>?
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>can_include</literal></entry>
      <entry>访问方法是否支持<literal>CREATE INDEX</literal>的<literal>INCLUDE</literal>子句？
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="functions-info-object-table"/> lists functions related to
   database object identification and addressing.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="functions-info-object-table"/>列出了与数据库对象
   标识和定位有关的函数。
  </para>

   <table id="functions-info-object-table">
<!--==========================orignal english content==========================
    <title>Object Information and Addressing Functions</title>
____________________________________________________________________________-->
    <title>对象信息和定位函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_describe_object</primary>
        </indexterm>
        <function>pg_describe_object</function> ( <parameter>classid</parameter> <type>oid</type>, <parameter>objid</parameter> <type>oid</type>, <parameter>objsubid</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns a textual description of a database object identified by
        catalog OID, object OID, and sub-object ID (such as a column number
        within a table; the sub-object ID is zero when referring to a whole
        object).  This description is intended to be human-readable, and might
        be translated, depending on server configuration.  This is especially
        useful to determine the identity of an object referenced in the
        <structname>pg_depend</structname> catalog.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_describe_object</primary>
        </indexterm>
        <function>pg_describe_object</function> ( <parameter>classid</parameter> <type>oid</type>, <parameter>objid</parameter> <type>oid</type>, <parameter>objsubid</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回由目录OID、对象OID和子对象ID(例如表中的列号)标识的数据库对象的文本描述;当引用整个对象时，子对象ID为0)。
        这个描述是人类可读的，并且可以根据服务器配置进行翻译。这对于决定<structname>pg_depend</structname>目录中引用的对象的标识特别有用。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_identify_object</primary>
        </indexterm>
        <function>pg_identify_object</function> ( <parameter>classid</parameter> <type>oid</type>, <parameter>objid</parameter> <type>oid</type>, <parameter>objsubid</parameter> <type>integer</type> )
        <returnvalue>record</returnvalue>
        ( <parameter>type</parameter> <type>text</type>,
        <parameter>schema</parameter> <type>text</type>,
        <parameter>name</parameter> <type>text</type>,
        <parameter>identity</parameter> <type>text</type> )
       </para>
       <para>
        Returns a row containing enough information to uniquely identify the
        database object specified by catalog OID, object OID and sub-object
        ID.
        This information is intended to be machine-readable, and is never
        translated.
        <parameter>type</parameter> identifies the type of database object;
        <parameter>schema</parameter> is the schema name that the object
        belongs in, or <literal>NULL</literal> for object types that do not
        belong to schemas;
        <parameter>name</parameter> is the name of the object, quoted if
        necessary, if the name (along with schema name, if pertinent) is
        sufficient to uniquely identify the object,
        otherwise <literal>NULL</literal>;
        <parameter>identity</parameter> is the complete object identity, with
        the precise format depending on object type, and each name within the
        format being schema-qualified and quoted as necessary.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_identify_object</primary>
        </indexterm>
        <function>pg_identify_object</function> ( <parameter>classid</parameter> <type>oid</type>, <parameter>objid</parameter> <type>oid</type>, <parameter>objsubid</parameter> <type>integer</type> )
        <returnvalue>record</returnvalue>
        ( <parameter>type</parameter> <type>text</type>,
        <parameter>schema</parameter> <type>text</type>,
        <parameter>name</parameter> <type>text</type>,
        <parameter>identity</parameter> <type>text</type> )
       </para>
       <para>
        返回包含足够信息的行以唯一标识由目录OID、对象OID和子对象ID指定的数据库对象。
        这些信息是为了机器可读的，永远不会被翻译。
        <parameter>type</parameter>标识数据库对象的类型;
        <parameter>schema</parameter>是对象所属的模式名，<literal>NULL</literal>表示不属于模式的对象类型;
        <parameter>name</parameter>是对象的名称，如果有必要，用引号括起来，如果名称(随着模式名称，如果相关)足以唯一地标识对象，否则为<literal>NULL</literal>;
        <parameter>identity</parameter>是完整的对象标识，其精确格式依赖于对象类型，格式中的每个名称都是模式限定的，并在必要时用引号括起来。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_identify_object_as_address</primary>
        </indexterm>
        <function>pg_identify_object_as_address</function> ( <parameter>classid</parameter> <type>oid</type>, <parameter>objid</parameter> <type>oid</type>, <parameter>objsubid</parameter> <type>integer</type> )
        <returnvalue>record</returnvalue>
        ( <parameter>type</parameter> <type>text</type>,
        <parameter>object_names</parameter> <type>text[]</type>,
        <parameter>object_args</parameter> <type>text[]</type> )
       </para>
       <para>
        Returns a row containing enough information to uniquely identify the
        database object specified by catalog OID, object OID and sub-object
        ID.
        The returned information is independent of the current server, that
        is, it could be used to identify an identically named object in
        another server.
        <parameter>type</parameter> identifies the type of database object;
        <parameter>object_names</parameter> and
        <parameter>object_args</parameter>
        are text arrays that together form a reference to the object.
        These three values can be passed
        to <function>pg_get_object_address</function> to obtain the internal
        address of the object.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_identify_object_as_address</primary>
        </indexterm>
        <function>pg_identify_object_as_address</function> ( <parameter>classid</parameter> <type>oid</type>, <parameter>objid</parameter> <type>oid</type>, <parameter>objsubid</parameter> <type>integer</type> )
        <returnvalue>record</returnvalue>
        ( <parameter>type</parameter> <type>text</type>,
        <parameter>object_names</parameter> <type>text[]</type>,
        <parameter>object_args</parameter> <type>text[]</type> )
       </para>
       <para>
        返回包含足够信息的行以唯一标识由目录OID、对象OID和子对象ID指定的数据库对象。
        返回的信息独立于当前服务器，也就是说，它可以用于标识另一个服务器中具有相同名称的对象。
        <parameter>type</parameter>标识数据库对象的类型;<parameter>object_names</parameter>和<parameter>object_args</parameter>是文本数组，它们一起构成对对象的引用。
        这三个值可以传递给<function>pg_get_object_address</function>以获得对象的内部地址。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_object_address</primary>
        </indexterm>
        <function>pg_get_object_address</function> ( <parameter>type</parameter> <type>text</type>, <parameter>object_names</parameter> <type>text[]</type>, <parameter>object_args</parameter> <type>text[]</type> )
        <returnvalue>record</returnvalue>
        ( <parameter>classid</parameter> <type>oid</type>,
        <parameter>objid</parameter> <type>oid</type>,
        <parameter>objsubid</parameter> <type>integer</type> )
       </para>
       <para>
        Returns a row containing enough information to uniquely identify the
        database object specified by a type code and object name and argument
        arrays.
        The returned values are the ones that would be used in system catalogs
        such as <structname>pg_depend</structname>; they can be passed to
        other system functions such as <function>pg_describe_object</function>
        or <function>pg_identify_object</function>.
        <parameter>classid</parameter> is the OID of the system catalog
        containing the object;
        <parameter>objid</parameter> is the OID of the object itself, and
        <parameter>objsubid</parameter> is the sub-object ID, or zero if none.
        This function is the inverse
        of <function>pg_identify_object_as_address</function>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_get_object_address</primary>
        </indexterm>
        <function>pg_get_object_address</function> ( <parameter>type</parameter> <type>text</type>, <parameter>object_names</parameter> <type>text[]</type>, <parameter>object_args</parameter> <type>text[]</type> )
        <returnvalue>record</returnvalue>
        ( <parameter>classid</parameter> <type>oid</type>,
        <parameter>objid</parameter> <type>oid</type>,
        <parameter>objsubid</parameter> <type>integer</type> )
       </para>
       <para>
        返回包含足够信息的行以唯一标识由类型代码、对象名称和参数数组指定的数据库对象。
        返回的值将在系统目录中使用，例如<structname>pg_depend</structname>;
        它们可以传递给其他系统函数，比如 <function>pg_describe_object</function>或<function>pg_identify_object</function>。
        <parameter>classid</parameter>是包含该对象的系统目录的OID;<parameter>objid</parameter>是对象本身的OID, <parameter>objsubid</parameter>是子对象的ID，如果没有则为零。
        这个函数是<function>pg_identify_object_as_address</function>的反向函数。
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>comment</primary>
    <secondary sortas="database objects">about database objects</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>注释</primary>
    <secondary sortas="database objects">关于数据库对象</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    The functions shown in <xref linkend="functions-info-comment-table"/>
    extract comments previously stored with the <xref linkend="sql-comment"/>
    command.  A null value is returned if no
    comment could be found for the specified parameters.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-info-comment-table"/>中展示的函数抽取注释，注释是由<xref linkend="sql-comment"/>命令在以前存储的。如果对指定参数找不到注释，则返回空值。
   </para>

   <table id="functions-info-comment-table">
<!--==========================orignal english content==========================
    <title>Comment Information Functions</title>
____________________________________________________________________________-->
    <title>注释信息函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>col_description</primary>
        </indexterm>
        <function>col_description</function> ( <parameter>table</parameter> <type>oid</type>, <parameter>column</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the comment for a table column, which is specified by the OID
        of its table and its column number.
        (<function>obj_description</function> cannot be used for table
        columns, since columns do not have OIDs of their own.)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>col_description</primary>
        </indexterm>
        <function>col_description</function> ( <parameter>table</parameter> <type>oid</type>, <parameter>column</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回表列的注释，该注释由该表的OID和列号指定。(<function>obj_description</function>不能用于表的列，因为列没有自己的oid。)
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>obj_description</primary>
        </indexterm>
        <function>obj_description</function> ( <parameter>object</parameter> <type>oid</type>, <parameter>catalog</parameter> <type>name</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the comment for a database object specified by its OID and the
        name of the containing system catalog.  For
        example, <literal>obj_description(123456, 'pg_class')</literal> would
        retrieve the comment for the table with OID 123456.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>obj_description</primary>
        </indexterm>
        <function>obj_description</function> ( <parameter>object</parameter> <type>oid</type>, <parameter>catalog</parameter> <type>name</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回OID指定的数据库对象的注释和包含该对象的系统目录的名称。
        例如，<literal>obj_description(123456, 'pg_class')</literal>将检索OID为123456的表的注释。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>obj_description</function> ( <parameter>object</parameter> <type>oid</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the comment for a database object specified by its OID alone.
        This is <emphasis>deprecated</emphasis> since there is no guarantee
        that OIDs are unique across different system catalogs; therefore, the
        wrong comment might be returned.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>obj_description</function> ( <parameter>object</parameter> <type>oid</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回仅由其OID指定的数据库对象的注释。
        这个已被<emphasis>弃用(deprecated)</emphasis>因为无法保证oid在不同的系统目录中是唯一的;因此，可能会返回错误的注释。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>shobj_description</primary>
        </indexterm>
        <function>shobj_description</function> ( <parameter>object</parameter> <type>oid</type>, <parameter>catalog</parameter> <type>name</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the comment for a shared database object specified by its OID
        and the name of the containing system catalog.  This is just
        like <function>obj_description</function> except that it is used for
        retrieving comments on shared objects (that is, databases, roles, and
        tablespaces).  Some system catalogs are global to all databases within
        each cluster, and the descriptions for objects in them are stored
        globally as well.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>shobj_description</primary>
        </indexterm>
        <function>shobj_description</function> ( <parameter>object</parameter> <type>oid</type>, <parameter>catalog</parameter> <type>name</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回共享数据库对象的注释，该对象由其OID和包含的系统编目的名称指定。
        这与<function>obj_description</function>类似，只是它用于检索共享对象(也就是数据库、角色和表空间)上的注释。
        有些系统编目对每个集群中的所有数据库都是全局的，其中对象的描述也全局存储。
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    The functions shown in <xref linkend="functions-pg-snapshot"/>
    provide server transaction information in an exportable form.  The main
    use of these functions is to determine which transactions were committed
    between two snapshots.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-pg-snapshot"/>中展示的函数以一种可导出的形式提供了服务器事务信息。
    这些函数的主要用途是判断在两个快照之间哪些事务被提交。
   </para>

   <table id="functions-pg-snapshot">
<!--==========================orignal english content==========================
    <title>Transaction ID and Snapshot Information Functions</title>
____________________________________________________________________________-->
    <title>事务ID和快照信息功能</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_current_xact_id</primary>
        </indexterm>
        <function>pg_current_xact_id</function> ()
        <returnvalue>xid8</returnvalue>
       </para>
       <para>
        Returns the current transaction's ID.  It will assign a new one if the
        current transaction does not have one already (because it has not
        performed any database updates).
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_current_xact_id</primary>
        </indexterm>
        <function>pg_current_xact_id</function> ()
        <returnvalue>xid8</returnvalue>
       </para>
       <para>
        返回当前事务的ID。如果当前事务还没有一个ID(因为它还没有执行任何数据库更新)，它将分配一个新的事务。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_current_xact_id_if_assigned</primary>
        </indexterm>
        <function>pg_current_xact_id_if_assigned</function> ()
        <returnvalue>xid8</returnvalue>
       </para>
       <para>
        Returns the current transaction's ID, or <literal>NULL</literal> if no
        ID is assigned yet.  (It's best to use this variant if the transaction
        might otherwise be read-only, to avoid unnecessary consumption of an
        XID.)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_current_xact_id_if_assigned</primary>
        </indexterm>
        <function>pg_current_xact_id_if_assigned</function> ()
        <returnvalue>xid8</returnvalue>
       </para>
       <para>
        返回当前事务的ID，如果还没有分配ID则返回<literal>NULL</literal>。
        (如果事务可能是只读的，最好使用这种变体，以避免不必要地消耗XID。)
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_xact_status</primary>
        </indexterm>
        <function>pg_xact_status</function> ( <type>xid8</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Reports the commit status of a recent transaction.
        The result is one of <literal>in progress</literal>,
        <literal>committed</literal>, or <literal>aborted</literal>,
        provided that the transaction is recent enough that the system retains
        the commit status of that transaction.
        If it is old enough that no references to the transaction survive in
        the system and the commit status information has been discarded, the
        result is <literal>NULL</literal>.
        Applications might use this function, for example, to determine
        whether their transaction committed or aborted after the application
        and database server become disconnected while
        a <literal>COMMIT</literal> is in progress.
        Note that prepared transactions are reported as <literal>in
        progress</literal>; applications must check <link
        linkend="view-pg-prepared-xacts"><structname>pg_prepared_xacts</structname></link>
        if they need to determine whether a transaction ID belongs to a
        prepared transaction.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_xact_status</primary>
        </indexterm>
        <function>pg_xact_status</function> ( <type>xid8</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        报告最近的事务的提交状态。如果事务为最近的，系统会保留事务的提交状态，则结果是 <literal>in progress</literal>、<literal>committed</literal>或<literal>aborted</literal>。
        如果该事务的时间足够久，并且系统中没有对该事务的引用，而且提交状态信息已经被丢弃，则结果为<literal>NULL</literal>。
        应用可以使用此函数，例如，确定在进行<literal>COMMIT</literal>时，应用程序和数据库服务器断开连接后，它们的事务是已提交还是中止。
        注意，准备好的事务报告为<literal>in progress</literal>的事务;如果应用需要确定一个事务ID是否属于一个准备好的事务，则必须检查<link linkend="view-pg-prepared-xacts"><structname>pg_prepared_xacts</structname></link>。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_current_snapshot</primary>
        </indexterm>
        <function>pg_current_snapshot</function> ()
        <returnvalue>pg_snapshot</returnvalue>
       </para>
       <para>
        Returns a current <firstterm>snapshot</firstterm>, a data structure
        showing which transaction IDs are now in-progress.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_current_snapshot</primary>
        </indexterm>
        <function>pg_current_snapshot</function> ()
        <returnvalue>pg_snapshot</returnvalue>
       </para>
       <para>
        返回当前<firstterm>snapshot</firstterm>，显示哪些事务IDs正在进行中的数据结构。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_snapshot_xip</primary>
        </indexterm>
        <function>pg_snapshot_xip</function> ( <type>pg_snapshot</type> )
        <returnvalue>setof xid8</returnvalue>
       </para>
       <para>
        Returns the set of in-progress transaction IDs contained in a snapshot.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_snapshot_xip</primary>
        </indexterm>
        <function>pg_snapshot_xip</function> ( <type>pg_snapshot</type> )
        <returnvalue>setof xid8</returnvalue>
       </para>
       <para>
        返回快照中包含的正在进行的事务IDs集。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_snapshot_xmax</primary>
        </indexterm>
        <function>pg_snapshot_xmax</function> ( <type>pg_snapshot</type> )
        <returnvalue>xid8</returnvalue>
       </para>
       <para>
        Returns the <structfield>xmax</structfield> of a snapshot.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_snapshot_xmax</primary>
        </indexterm>
        <function>pg_snapshot_xmax</function> ( <type>pg_snapshot</type> )
        <returnvalue>xid8</returnvalue>
       </para>
       <para>
        返回快照的<structfield>xmax</structfield>。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_snapshot_xmin</primary>
        </indexterm>
        <function>pg_snapshot_xmin</function> ( <type>pg_snapshot</type> )
        <returnvalue>xid8</returnvalue>
       </para>
       <para>
        Returns the <structfield>xmin</structfield> of a snapshot.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_snapshot_xmin</primary>
        </indexterm>
        <function>pg_snapshot_xmin</function> ( <type>pg_snapshot</type> )
        <returnvalue>xid8</returnvalue>
       </para>
       <para>
        返回快照的<structfield>xmin</structfield>。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_visible_in_snapshot</primary>
        </indexterm>
        <function>pg_visible_in_snapshot</function> ( <type>xid8</type>, <type>pg_snapshot</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the given transaction ID <firstterm>visible</firstterm> according
        to this snapshot (that is, was it completed before the snapshot was
        taken)?  Note that this function will not give the correct answer for
        a subtransaction ID.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_visible_in_snapshot</primary>
        </indexterm>
        <function>pg_visible_in_snapshot</function> ( <type>xid8</type>, <type>pg_snapshot</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        根据此快照，给定的事务ID是否<firstterm>可见(visible)</firstterm>(也就是说，它是否在快照拍摄之前完成)?
        注意，这个函数不会给出子事务ID的正确答案。
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    The internal transaction ID type <type>xid</type> is 32 bits wide and
    wraps around every 4 billion transactions.  However,
    the functions shown in <xref linkend="functions-pg-snapshot"/> use a
    64-bit type <type>xid8</type> that does not wrap around during the life
    of an installation, and can be converted to <type>xid</type> by casting if
    required.  The data type <type>pg_snapshot</type> stores information about
    transaction ID visibility at a particular moment in time.  Its components
    are described in <xref linkend="functions-pg-snapshot-parts"/>.
    <type>pg_snapshot</type>'s textual representation is
    <literal><replaceable>xmin</replaceable>:<replaceable>xmax</replaceable>:<replaceable>xip_list</replaceable></literal>.
    For example <literal>10:20:10,14,15</literal> means
    <literal>xmin=10, xmax=20, xip_list=10, 14, 15</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    内部事务ID类型<type>xid</type>是32位宽的，可捆卷(wraps around)每40亿个事务。
    但是，<xref linkend="functions-pg-snapshot"/>中所示的函数使用的是64位类型的<type>xid8</type>，它在安装过程中不捆卷(wraps around)，如果需要，可以通过强制转换将其转换为<type>xid</type>。
    数据类型<type>pg_snapshot</type>存储特定时刻事务ID可见性的信息。
    其组成如<xref linkend="functions-pg-snapshot-parts"/>所描述。<type>pg_snapshot</type>的文本表示形式是<literal><replaceable>xmin</replaceable>:<replaceable>xmax</replaceable>:<replaceable>xip_list</replaceable></literal>。
    例如<literal>10:20:10,14,15</literal>表示<literal>xmin=10, xmax=20, xip_list=10, 14, 15</literal>。
   </para>

   <table id="functions-pg-snapshot-parts">
<!--==========================orignal english content==========================
    <title>Snapshot Components</title>
____________________________________________________________________________-->
    <title>快照组件</title>
    <tgroup cols="2">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Name</entry>
       <entry>Description</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>名称</entry>
       <entry>描述</entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry><structfield>xmin</structfield></entry>
       <entry>
         Lowest transaction ID that was still active.  All transaction IDs
         less than <structfield>xmin</structfield> are either committed and visible,
         or rolled back and dead.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><structfield>xmin</structfield></entry>
       <entry>
         仍然处于活动状态的最低事务ID。所有小于<structfield>xmin</structfield>的事务IDs要么提交且可见，要么回滚并死亡。
       </entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><structfield>xmax</structfield></entry>
       <entry>
         One past the highest completed transaction ID.  All transaction IDs
         greater than or equal to <structfield>xmax</structfield> had not yet
         completed as of the time of the snapshot, and thus are invisible.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><structfield>xmax</structfield></entry>
       <entry>
         比最高完成的事务ID还高出一个值。所有大于或等于<structfield>xmax</structfield>的事务IDs到快照时还没有完成，因此不可见。
       </entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><structfield>xip_list</structfield></entry>
       <entry>
        Transactions in progress at the time of the snapshot.  A transaction
        ID that is <literal>xmin &lt;= <replaceable>X</replaceable> &lt;
        xmax</literal> and not in this list was already completed at the time
        of the snapshot, and thus is either visible or dead according to its
        commit status.  This list does not include the transaction IDs of
        subtransactions.
       </entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><structfield>xip_list</structfield></entry>
       <entry>
        快照时正在进行的事务。一个事务ID为<literal>xmin &lt;= <replaceable>X</replaceable> &lt; xmax</literal>且不在快照时已经完成的列表中，因此根据其提交状态，该事务ID要么是可见的，要么是死的。此列表不包括子事务的事务IDs。
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    In releases of <productname>PostgreSQL</productname> before 13 there was
    no <type>xid8</type> type, so variants of these functions were provided
    that used <type>bigint</type> to represent a 64-bit XID, with a
    correspondingly distinct snapshot data type <type>txid_snapshot</type>.
    These older functions have <literal>txid</literal> in their names.  They
    are still supported for backward compatibility, but may be removed from a
    future release. See <xref linkend="functions-txid-snapshot"/>.
   </para>
____________________________________________________________________________-->
   <para>
    在<productname>PostgreSQL</productname>13以前的版本中，没有<type>xid8</type>类型，因此提供了这些函数的变体，使用<type>bigint</type>表示64位XID，并相应地提供不同的快照数据类型<type>txid_snapshot</type>。
    这些旧的函数在它们的名字中有<literal>txid</literal>。
    它们仍然支持向后兼容性，但可能会从未来的版本中删除。参见<xref linkend="functions-txid-snapshot"/>。
   </para>

   <table id="functions-txid-snapshot">
<!--==========================orignal english content==========================
    <title>Deprecated Transaction ID and Snapshot Information Functions</title>
____________________________________________________________________________-->
    <title>已弃用的事务ID和快照信息功能</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>txid_current</primary>
        </indexterm>
        <function>txid_current</function> ()
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        See <function>pg_current_xact_id()</function>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>txid_current</primary>
        </indexterm>
        <function>txid_current</function> ()
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        参见 <function>pg_current_xact_id()</function>.
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>txid_current_if_assigned</primary>
        </indexterm>
        <function>txid_current_if_assigned</function> ()
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        See <function>pg_current_xact_id_if_assigned()</function>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>txid_current_if_assigned</primary>
        </indexterm>
        <function>txid_current_if_assigned</function> ()
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        参见 <function>pg_current_xact_id_if_assigned()</function>.
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>txid_current_snapshot</primary>
        </indexterm>
        <function>txid_current_snapshot</function> ()
        <returnvalue>txid_snapshot</returnvalue>
       </para>
       <para>
        See <function>pg_current_snapshot()</function>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>txid_current_snapshot</primary>
        </indexterm>
        <function>txid_current_snapshot</function> ()
        <returnvalue>txid_snapshot</returnvalue>
       </para>
       <para>
        参见 <function>pg_current_snapshot()</function>.
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>txid_snapshot_xip</primary>
        </indexterm>
        <function>txid_snapshot_xip</function> ( <type>txid_snapshot</type> )
        <returnvalue>setof bigint</returnvalue>
       </para>
       <para>
        See <function>pg_snapshot_xip()</function>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>txid_snapshot_xip</primary>
        </indexterm>
        <function>txid_snapshot_xip</function> ( <type>txid_snapshot</type> )
        <returnvalue>setof bigint</returnvalue>
       </para>
       <para>
        参见 <function>pg_snapshot_xip()</function>.
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>txid_snapshot_xmax</primary>
        </indexterm>
        <function>txid_snapshot_xmax</function> ( <type>txid_snapshot</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        See <function>pg_snapshot_xmax()</function>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>txid_snapshot_xmax</primary>
        </indexterm>
        <function>txid_snapshot_xmax</function> ( <type>txid_snapshot</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        参见 <function>pg_snapshot_xmax()</function>.
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>txid_snapshot_xmin</primary>
        </indexterm>
        <function>txid_snapshot_xmin</function> ( <type>txid_snapshot</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        See <function>pg_snapshot_xmin()</function>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>txid_snapshot_xmin</primary>
        </indexterm>
        <function>txid_snapshot_xmin</function> ( <type>txid_snapshot</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        参见 <function>pg_snapshot_xmin()</function>.
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>txid_visible_in_snapshot</primary>
        </indexterm>
        <function>txid_visible_in_snapshot</function> ( <type>bigint</type>, <type>txid_snapshot</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        See <function>pg_visible_in_snapshot()</function>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>txid_visible_in_snapshot</primary>
        </indexterm>
        <function>txid_visible_in_snapshot</function> ( <type>bigint</type>, <type>txid_snapshot</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        参见 <function>pg_visible_in_snapshot()</function>.
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>txid_status</primary>
        </indexterm>
        <function>txid_status</function> ( <type>bigint</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        See <function>pg_xact_status()</function>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>txid_status</primary>
        </indexterm>
        <function>txid_status</function> ( <type>bigint</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        参见 <function>pg_xact_status()</function>.
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    The functions shown in <xref linkend="functions-commit-timestamp"/>
    provide information about when past transactions were committed.
    They only provide useful data when the
    <xref linkend="guc-track-commit-timestamp"/> configuration option is
    enabled, and only for transactions that were committed after it was
    enabled.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-commit-timestamp"/>中的函数提供了关于过去的事务何时被提交的信息。
    它们只在启用<xref linkend="guc-track-commit-timestamp"/>配置选项时提供有用的数据，并且只针对在启用该选项后提交的事务。
   </para>

   <table id="functions-commit-timestamp">
<!--==========================orignal english content==========================
    <title>Committed Transaction Information Functions</title>
____________________________________________________________________________-->
    <title>已提交事务信息函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_xact_commit_timestamp</primary>
        </indexterm>
        <function>pg_xact_commit_timestamp</function> ( <type>xid</type> )
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
        Returns the commit timestamp of a transaction.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_xact_commit_timestamp</primary>
        </indexterm>
        <function>pg_xact_commit_timestamp</function> ( <type>xid</type> )
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
        返回事务的提交时间戳。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_last_committed_xact</primary>
        </indexterm>
        <function>pg_last_committed_xact</function> ()
        <returnvalue>record</returnvalue>
        ( <parameter>xid</parameter> <type>xid</type>,
        <parameter>timestamp</parameter> <type>timestamp with time zone</type> )
       </para>
       <para>
        Returns the transaction ID and commit timestamp of the latest
        committed transaction.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_last_committed_xact</primary>
        </indexterm>
        <function>pg_last_committed_xact</function> ()
        <returnvalue>record</returnvalue>
        ( <parameter>xid</parameter> <type>xid</type>,
        <parameter>timestamp</parameter> <type>timestamp with time zone</type> )
       </para>
       <para>
        返回最近提交的事务的事务ID和提交时间戳。
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    The functions shown in <xref linkend="functions-controldata"/>
    print information initialized during <command>initdb</command>, such
    as the catalog version. They also show information about write-ahead
    logging and checkpoint processing. This information is cluster-wide,
    not specific to any one database. These functions provide most of the same
    information, from the same source, as the
    <xref linkend="app-pgcontroldata"/> application.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-controldata"/>中所展示的函数能打印<command>initdb</command>期间初始化的信息，例如目录版本。
    它们也能显示有关预写式日志和检查点处理的信息。这些信息是集簇范围内的，不与任何特定的一个数据库相关。
    这些函数提供大致相同的信息，对于同一种来源，就像<xref linkend="app-pgcontroldata"/>应用。
   </para>

   <table id="functions-controldata">
<!--==========================orignal english content==========================
    <title>Control Data Functions</title>
____________________________________________________________________________-->
    <title>控制数据函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_control_checkpoint</primary>
        </indexterm>
        <function>pg_control_checkpoint</function> ()
        <returnvalue>record</returnvalue>
       </para>
       <para>
        Returns information about current checkpoint state, as shown in
        <xref linkend="functions-pg-control-checkpoint"/>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_control_checkpoint</primary>
        </indexterm>
        <function>pg_control_checkpoint</function> ()
        <returnvalue>record</returnvalue>
       </para>
       <para>
        返回有关当前检查点状态的信息, 如 <xref linkend="functions-pg-control-checkpoint"/>所展示。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_control_system</primary>
        </indexterm>
        <function>pg_control_system</function> ()
        <returnvalue>record</returnvalue>
       </para>
       <para>
        Returns information about current control file state, as shown in
        <xref linkend="functions-pg-control-system"/>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_control_system</primary>
        </indexterm>
        <function>pg_control_system</function> ()
        <returnvalue>record</returnvalue>
       </para>
       <para>
        返回有关当前控制文件状态的信息，如 <xref linkend="functions-pg-control-system"/> 所展示。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_control_init</primary>
        </indexterm>
        <function>pg_control_init</function> ()
        <returnvalue>record</returnvalue>
       </para>
       <para>
        Returns information about cluster initialization state, as shown in
        <xref linkend="functions-pg-control-init"/>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_control_init</primary>
        </indexterm>
        <function>pg_control_init</function> ()
        <returnvalue>record</returnvalue>
       </para>
       <para>
        返回有关集群初始化状态的信息，如 <xref linkend="functions-pg-control-init"/>所展示。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_control_recovery</primary>
        </indexterm>
        <function>pg_control_recovery</function> ()
        <returnvalue>record</returnvalue>
       </para>
       <para>
        Returns information about recovery state, as shown in
        <xref linkend="functions-pg-control-recovery"/>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_control_recovery</primary>
        </indexterm>
        <function>pg_control_recovery</function> ()
        <returnvalue>record</returnvalue>
       </para>
       <para>
        返回有关恢复状态的信息,如 <xref linkend="functions-pg-control-recovery"/>所展示。
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <table id="functions-pg-control-checkpoint">
<!--==========================orignal english content==========================
    <title><function>pg_control_checkpoint</function> Output Columns</title>
____________________________________________________________________________-->
    <title><function>pg_control_checkpoint</function> 输出列</title>
    <tgroup cols="2">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Column Name</entry>
       <entry>Data Type</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>列名称</entry>
       <entry>数据类型</entry>
      </row>
     </thead>

     <tbody>

<!--==========================orignal english content==========================
      <row>
       <entry><structfield>checkpoint_lsn</structfield></entry>
       <entry><type>pg_lsn</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><structfield>checkpoint_lsn</structfield></entry>
       <entry><type>pg_lsn</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><structfield>redo_lsn</structfield></entry>
       <entry><type>pg_lsn</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><structfield>redo_lsn</structfield></entry>
       <entry><type>pg_lsn</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><structfield>redo_wal_file</structfield></entry>
       <entry><type>text</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><structfield>redo_wal_file</structfield></entry>
       <entry><type>text</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><structfield>timeline_id</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><structfield>timeline_id</structfield></entry>
       <entry><type>integer</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><structfield>prev_timeline_id</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><structfield>prev_timeline_id</structfield></entry>
       <entry><type>integer</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><structfield>full_page_writes</structfield></entry>
       <entry><type>boolean</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><structfield>full_page_writes</structfield></entry>
       <entry><type>boolean</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><structfield>next_xid</structfield></entry>
       <entry><type>text</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><structfield>next_xid</structfield></entry>
       <entry><type>text</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><structfield>next_oid</structfield></entry>
       <entry><type>oid</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><structfield>next_oid</structfield></entry>
       <entry><type>oid</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><structfield>next_multixact_id</structfield></entry>
       <entry><type>xid</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><structfield>next_multixact_id</structfield></entry>
       <entry><type>xid</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><structfield>next_multi_offset</structfield></entry>
       <entry><type>xid</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><structfield>next_multi_offset</structfield></entry>
       <entry><type>xid</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><structfield>oldest_xid</structfield></entry>
       <entry><type>xid</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><structfield>oldest_xid</structfield></entry>
       <entry><type>xid</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><structfield>oldest_xid_dbid</structfield></entry>
       <entry><type>oid</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><structfield>oldest_xid_dbid</structfield></entry>
       <entry><type>oid</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><structfield>oldest_active_xid</structfield></entry>
       <entry><type>xid</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><structfield>oldest_active_xid</structfield></entry>
       <entry><type>xid</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><structfield>oldest_multi_xid</structfield></entry>
       <entry><type>xid</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><structfield>oldest_multi_xid</structfield></entry>
       <entry><type>xid</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><structfield>oldest_multi_dbid</structfield></entry>
       <entry><type>oid</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><structfield>oldest_multi_dbid</structfield></entry>
       <entry><type>oid</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><structfield>oldest_commit_ts_xid</structfield></entry>
       <entry><type>xid</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><structfield>oldest_commit_ts_xid</structfield></entry>
       <entry><type>xid</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><structfield>newest_commit_ts_xid</structfield></entry>
       <entry><type>xid</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><structfield>newest_commit_ts_xid</structfield></entry>
       <entry><type>xid</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><structfield>checkpoint_time</structfield></entry>
       <entry><type>timestamp with time zone</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><structfield>checkpoint_time</structfield></entry>
       <entry><type>带时区的时间戳</type></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <table id="functions-pg-control-system">
<!--==========================orignal english content==========================
    <title><function>pg_control_system</function> Output Columns</title>
____________________________________________________________________________-->
    <title><function>pg_control_system</function> 输出列</title>
    <tgroup cols="2">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Column Name</entry>
       <entry>Data Type</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>列名称</entry>
       <entry>数据类型</entry>
      </row>
     </thead>

     <tbody>

<!--==========================orignal english content==========================
      <row>
       <entry><structfield>pg_control_version</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><structfield>pg_control_version</structfield></entry>
       <entry><type>integer</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><structfield>catalog_version_no</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><structfield>catalog_version_no</structfield></entry>
       <entry><type>integer</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><structfield>system_identifier</structfield></entry>
       <entry><type>bigint</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><structfield>system_identifier</structfield></entry>
       <entry><type>bigint</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><structfield>pg_control_last_modified</structfield></entry>
       <entry><type>timestamp with time zone</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><structfield>pg_control_last_modified</structfield></entry>
       <entry><type>timestamp with time zone</type></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <table id="functions-pg-control-init">
<!--==========================orignal english content==========================
    <title><function>pg_control_init</function> Output Columns</title>
____________________________________________________________________________-->
    <title><function>pg_control_init</function> 输出列</title>
    <tgroup cols="2">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Column Name</entry>
       <entry>Data Type</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>列名称</entry>
       <entry>数据类型</entry>
      </row>
     </thead>

     <tbody>

<!--==========================orignal english content==========================
      <row>
       <entry><structfield>max_data_alignment</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><structfield>max_data_alignment</structfield></entry>
       <entry><type>integer</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><structfield>database_block_size</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><structfield>database_block_size</structfield></entry>
       <entry><type>integer</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><structfield>blocks_per_segment</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><structfield>blocks_per_segment</structfield></entry>
       <entry><type>integer</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><structfield>wal_block_size</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><structfield>wal_block_size</structfield></entry>
       <entry><type>integer</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><structfield>bytes_per_wal_segment</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><structfield>bytes_per_wal_segment</structfield></entry>
       <entry><type>integer</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><structfield>max_identifier_length</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><structfield>max_identifier_length</structfield></entry>
       <entry><type>integer</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><structfield>max_index_columns</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><structfield>max_index_columns</structfield></entry>
       <entry><type>integer</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><structfield>max_toast_chunk_size</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><structfield>max_toast_chunk_size</structfield></entry>
       <entry><type>integer</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><structfield>large_object_chunk_size</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><structfield>large_object_chunk_size</structfield></entry>
       <entry><type>integer</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><structfield>float8_pass_by_value</structfield></entry>
       <entry><type>boolean</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><structfield>float8_pass_by_value</structfield></entry>
       <entry><type>boolean</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><structfield>data_page_checksum_version</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><structfield>data_page_checksum_version</structfield></entry>
       <entry><type>integer</type></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <table id="functions-pg-control-recovery">
<!--==========================orignal english content==========================
    <title><function>pg_control_recovery</function> Output Columns</title>
____________________________________________________________________________-->
    <title><function>pg_control_recovery</function> 输出列</title>
    <tgroup cols="2">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Column Name</entry>
       <entry>Data Type</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>列名称</entry>
       <entry>数据类型</entry>
      </row>
     </thead>

     <tbody>

<!--==========================orignal english content==========================
      <row>
       <entry><structfield>min_recovery_end_lsn</structfield></entry>
       <entry><type>pg_lsn</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><structfield>min_recovery_end_lsn</structfield></entry>
       <entry><type>pg_lsn</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><structfield>min_recovery_end_timeline</structfield></entry>
       <entry><type>integer</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><structfield>min_recovery_end_timeline</structfield></entry>
       <entry><type>integer</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><structfield>backup_start_lsn</structfield></entry>
       <entry><type>pg_lsn</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><structfield>backup_start_lsn</structfield></entry>
       <entry><type>pg_lsn</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><structfield>backup_end_lsn</structfield></entry>
       <entry><type>pg_lsn</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><structfield>backup_end_lsn</structfield></entry>
       <entry><type>pg_lsn</type></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><structfield>end_of_backup_record_required</structfield></entry>
       <entry><type>boolean</type></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><structfield>end_of_backup_record_required</structfield></entry>
       <entry><type>boolean</type></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

  </sect1>

  <sect1 id="functions-admin">
<!--==========================orignal english content==========================
   <title>System Administration Functions</title>
____________________________________________________________________________-->
   <title>系统管理函数</title>

<!--==========================orignal english content==========================
   <para>
    The functions described in this section are used to control and
    monitor a <productname>PostgreSQL</productname> installation.
   </para>
____________________________________________________________________________-->
   <para>
    这一节描述的函数被用来控制和监视一个<productname>PostgreSQL</productname>安装。
   </para>

  <sect2 id="functions-admin-set">
<!--==========================orignal english content==========================
   <title>Configuration Settings Functions</title>
____________________________________________________________________________-->
   <title>配置设定函数</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>SET</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>SET</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>SHOW</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>SHOW</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>configuration</primary>
    <secondary sortas="server">of the server</secondary>
    <tertiary>functions</tertiary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>configuration</primary>
    <secondary sortas="server">of the server</secondary>
    <tertiary>functions</tertiary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    <xref linkend="functions-admin-set-table"/> shows the functions
    available to query and alter run-time configuration parameters.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-admin-set-table"/>展示了那些可以用于查询以及修改运行时配置参数的函数。
   </para>

   <table id="functions-admin-set-table">
<!--==========================orignal english content==========================
    <title>Configuration Settings Functions</title>
____________________________________________________________________________-->
    <title>配置设置函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>current_setting</primary>
        </indexterm>
        <function>current_setting</function> ( <parameter>setting_name</parameter> <type>text</type> <optional>, <parameter>missing_ok</parameter> <type>boolean</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the current value of the
        setting <parameter>setting_name</parameter>.  If there is no such
        setting, <function>current_setting</function> throws an error
        unless <parameter>missing_ok</parameter> is supplied and
        is <literal>true</literal>.  This function corresponds to
        the <acronym>SQL</acronym> command <command>SHOW</command>.
       </para>
       <para>
        <literal>current_setting('datestyle')</literal>
        <returnvalue>ISO, MDY</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>current_setting</primary>
        </indexterm>
        <function>current_setting</function> ( <parameter>setting_name</parameter> <type>text</type> <optional>, <parameter>missing_ok</parameter> <type>boolean</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回设置的<parameter>setting_name</parameter>的当前值。
        如果没有这样的设置，<function>current_setting</function>将抛出一个错误，除非<parameter>missing_ok</parameter>被提供并且为<literal>true</literal>。
        这个函数对应于<acronym>SQL</acronym>命令<command>SHOW</command>。
       </para>
       <para>
        <literal>current_setting('datestyle')</literal>
        <returnvalue>ISO, MDY</returnvalue>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>set_config</primary>
        </indexterm>
        <function>set_config</function> (
          <parameter>setting_name</parameter> <type>text</type>,
          <parameter>new_value</parameter> <type>text</type>,
          <parameter>is_local</parameter> <type>boolean</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Sets the parameter <parameter>setting_name</parameter>
        to <parameter>new_value</parameter>, and returns that value.
        If <parameter>is_local</parameter> is <literal>true</literal>, the new
        value will only apply for the current transaction. If you want the new
        value to apply for the current session, use <literal>false</literal>
        instead. This function corresponds to the SQL
        command <command>SET</command>.
       </para>
       <para>
        <literal>set_config('log_statement_stats', 'off', false)</literal>
        <returnvalue>off</returnvalue>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>set_config</primary>
        </indexterm>
        <function>set_config</function> (
          <parameter>setting_name</parameter> <type>text</type>,
          <parameter>new_value</parameter> <type>text</type>,
          <parameter>is_local</parameter> <type>boolean</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将参数<parameter>setting_name</parameter>设置为<parameter>new_value</parameter>，并返回该值。
        如果<parameter>is_local</parameter>为<literal>true</literal>，新值将仅在当前事务中应用。
        如果您希望新值应用于当前会话的其余部分，请使用<literal>false</literal>代替。这个函数对应于SQL命令<command>SET</command>。
       </para>
       <para>
        <literal>set_config('log_statement_stats', 'off', false)</literal>
        <returnvalue>off</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  </sect2>

  <sect2 id="functions-admin-signal">
<!--==========================orignal english content==========================
   <title>Server Signaling Functions</title>
____________________________________________________________________________-->
   <title>服务器信号函数</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>signal</primary>
    <secondary sortas="backend">backend processes</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>信号</primary>
    <secondary sortas="backend">后端进程</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    The functions shown in <xref
    linkend="functions-admin-signal-table"/> send control signals to
    other server processes.  Use of these functions is restricted to
    superusers by default but access may be granted to others using
    <command>GRANT</command>, with noted exceptions.
   </para>
____________________________________________________________________________-->
   <para>
    在<xref linkend="functions-admin-signal-table"/>中展示的函数向其它服务器进程发送控制信号。默认情况下这些函数只能被超级用户使用，但是如果需要，可以利用<command>GRANT</command>把访问特权授予给其他用户。
   </para>

<!--==========================orignal english content==========================
   <para>
    Each of these functions returns <literal>true</literal> if
    successful and <literal>false</literal> otherwise.
   </para>
____________________________________________________________________________-->
   <para>
    每个这样的函数如果成功则返回<literal>true</literal>，否则返回<literal>false</literal>。
   </para>

   <table id="functions-admin-signal-table">
<!--==========================orignal english content==========================
    <title>Server Signaling Functions</title>
____________________________________________________________________________-->
    <title>服务器信号函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_cancel_backend</primary>
        </indexterm>
        <function>pg_cancel_backend</function> ( <parameter>pid</parameter> <type>integer</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Cancels the current query of the session whose backend process has the
        specified process ID.  This is also allowed if the
        calling role is a member of the role whose backend is being canceled or
        the calling role has been granted <literal>pg_signal_backend</literal>,
        however only superusers can cancel superuser backends.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_cancel_backend</primary>
        </indexterm>
        <function>pg_cancel_backend</function> ( <parameter>pid</parameter> <type>integer</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        取消对后端进程具有指定进程ID的会话的当前查询。
        如果调用角色是后端被取消的角色的成员，或者调用角色被授予<literal>pg_signal_backend</literal>，也允许这样做，但是只有超级用户才能取消超级用户后端。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_reload_conf</primary>
        </indexterm>
        <function>pg_reload_conf</function> ()
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Causes all processes of the <productname>PostgreSQL</productname>
        server to reload their configuration files.  (This is initiated by
        sending a <systemitem>SIGHUP</systemitem> signal to the postmaster
        process, which in turn sends <systemitem>SIGHUP</systemitem> to each
        of its children.)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_reload_conf</primary>
        </indexterm>
        <function>pg_reload_conf</function> ()
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        导致<productname>PostgreSQL</productname>服务器的所有进程重新加载其配置文件。
        (这是通过向postmaster进程发送<systemitem>SIGHUP</systemitem>信号来初始化的，然后这个进程又把<systemitem>SIGHUP</systemitem>发送给它的每个子进程。)
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_rotate_logfile</primary>
        </indexterm>
        <function>pg_rotate_logfile</function> ()
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Signals the log-file manager to switch to a new output file
        immediately.  This works only when the built-in log collector is
        running, since otherwise there is no log-file manager subprocess.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_rotate_logfile</primary>
        </indexterm>
        <function>pg_rotate_logfile</function> ()
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        通知日志文件管理器立即切换到一个新的输出文件。
        这仅在内置日志采集器运行时有效，因为否则没有日志文件管理器子进程。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_terminate_backend</primary>
        </indexterm>
        <function>pg_terminate_backend</function> ( <parameter>pid</parameter> <type>integer</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Terminates the session whose backend process has the
        specified process ID.  This is also allowed if the calling role
        is a member of the role whose backend is being terminated or the
        calling role has been granted <literal>pg_signal_backend</literal>,
        however only superusers can terminate superuser backends.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_terminate_backend</primary>
        </indexterm>
        <function>pg_terminate_backend</function> ( <parameter>pid</parameter> <type>integer</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        终止后端进程具有指定进程ID的会话。
        如果调用角色是后端被终止的角色的成员，或者调用角色被赋予<literal>pg_signal_backend</literal>，那么也允许这样做，但是只有超级用户才能终止超级用户后端。
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    <function>pg_cancel_backend</function> and <function>pg_terminate_backend</function>
    send signals (<systemitem>SIGINT</systemitem> or <systemitem>SIGTERM</systemitem>
    respectively) to backend processes identified by process ID.
    The process ID of an active backend can be found from
    the <structfield>pid</structfield> column of the
    <structname>pg_stat_activity</structname> view, or by listing the
    <command>postgres</command> processes on the server (using
    <application>ps</application> on Unix or the <application>Task
    Manager</application> on <productname>Windows</productname>).
    The role of an active backend can be found from the
    <structfield>usename</structfield> column of the
    <structname>pg_stat_activity</structname> view.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_cancel_backend</function>和<function>pg_terminate_backend</function>向由进程 ID 标识的后端进程发送信号（分别是<systemitem>SIGINT</systemitem>或<systemitem>SIGTERM</systemitem>）。
    一个活动后端的进程 ID可以从<structname>pg_stat_activity</structname>视图的<structfield>pid</structfield>列中找到，或者通过在服务器上列出<command>postgres</command>进程（在 Unix 上使用<application>ps</application>或者在<productname>Windows</productname>上使用<application>任务管理器</application>）得到。
    一个活动后端的角色可以在<structname>pg_stat_activity</structname>视图的<structfield>usename</structfield>列中找到。
   </para>

  </sect2>

  <sect2 id="functions-admin-backup">
<!--==========================orignal english content==========================
   <title>Backup Control Functions</title>
____________________________________________________________________________-->
   <title>备份控制函数</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>backup</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>backup</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    The functions shown in <xref
    linkend="functions-admin-backup-table"/> assist in making on-line backups.
    These functions cannot be executed during recovery (except
    non-exclusive <function>pg_start_backup</function>,
    non-exclusive <function>pg_stop_backup</function>,
    <function>pg_is_in_backup</function>, <function>pg_backup_start_time</function>
    and <function>pg_wal_lsn_diff</function>).
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-admin-backup-table"/>中展示的函数可以辅助制作在线备份。
    这些函数不能在恢复期间执行（非排他性的<function>pg_start_backup</function>，非排他性的<function>pg_stop_backup</function>，<function>pg_is_in_backup</function>、<function>pg_backup_start_time</function>和<function>pg_wal_lsn_diff</function>除外）。
   </para>

<!--==========================orignal english content==========================
   <para>
    For details about proper usage of these functions, see
    <xref linkend="continuous-archiving"/>.
   </para>
____________________________________________________________________________-->
   <para>
    有关正确使用这些函数的详细信息，参见<xref linkend="continuous-archiving"/>。
   </para>

   <table id="functions-admin-backup-table">
<!--==========================orignal english content==========================
    <title>Backup Control Functions</title>
____________________________________________________________________________-->
    <title>备份控制函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_create_restore_point</primary>
        </indexterm>
        <function>pg_create_restore_point</function> ( <parameter>name</parameter> <type>text</type> )
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        Creates a named marker record in the write-ahead log that can later be
        used as a recovery target, and returns the corresponding write-ahead
        log location.  The given name can then be used with
        <xref linkend="guc-recovery-target-name"/> to specify the point up to
        which recovery will proceed.  Avoid creating multiple restore points
        with the same name, since recovery will stop at the first one whose
        name matches the recovery target.
       </para>
       <para>
        This function is restricted to superusers by default, but other users
        can be granted EXECUTE to run the function.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_create_restore_point</primary>
        </indexterm>
        <function>pg_create_restore_point</function> ( <parameter>name</parameter> <type>text</type> )
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        在预写式日志中创建一个命名标记记录，稍后可以将其用作恢复目标，并返回相应的预写日志位置。
        然后可以将给定的名称与 <xref linkend="guc-recovery-target-name"/>一起使用，以指定进行恢复的点。
        要避免创建多个名称相同的恢复点，因为恢复将在第一个名称与恢复目标匹配的恢复点停止。
       </para>
       <para>
        默认情况下，该函数仅限超级用户使用，但可以授权给其他用户执行该函数。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_current_wal_flush_lsn</primary>
        </indexterm>
        <function>pg_current_wal_flush_lsn</function> ()
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        Returns the current write-ahead log flush location (see notes below).
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_current_wal_flush_lsn</primary>
        </indexterm>
        <function>pg_current_wal_flush_lsn</function> ()
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        返回当前预写式日志刷新位置(参见下面的说明)。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_current_wal_insert_lsn</primary>
        </indexterm>
        <function>pg_current_wal_insert_lsn</function> ()
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        Returns the current write-ahead log insert location (see notes below).
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_current_wal_insert_lsn</primary>
        </indexterm>
        <function>pg_current_wal_insert_lsn</function> ()
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        返回当前预式日志插入位置(参见下面的说明)。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_current_wal_lsn</primary>
        </indexterm>
        <function>pg_current_wal_lsn</function> ()
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        Returns the current write-ahead log write location (see notes below).
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_current_wal_lsn</primary>
        </indexterm>
        <function>pg_current_wal_lsn</function> ()
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        返回当前预写式日志写位置(参见下面的说明)。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_start_backup</primary>
        </indexterm>
        <function>pg_start_backup</function> (
          <parameter>label</parameter> <type>text</type>
          <optional>, <parameter>fast</parameter> <type>boolean</type>
          <optional>, <parameter>exclusive</parameter> <type>boolean</type>
          </optional></optional> )
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        Prepares the server to begin an on-line backup.  The only required
        parameter is an arbitrary user-defined label for the backup.
        (Typically this would be the name under which the backup dump file
        will be stored.)
        If the optional second parameter is given as <literal>true</literal>,
        it specifies executing <function>pg_start_backup</function> as quickly
        as possible.  This forces an immediate checkpoint which will cause a
        spike in I/O operations, slowing any concurrently executing queries.
        The optional third parameter specifies whether to perform an exclusive
        or non-exclusive backup (default is exclusive).
       </para>
       <para>
        When used in exclusive mode, this function writes a backup label file
        (<filename>backup_label</filename>) and, if there are any links in
        the <filename>pg_tblspc/</filename> directory, a tablespace map file
        (<filename>tablespace_map</filename>) into the database cluster's data
        directory, then performs a checkpoint, and then returns the backup's
        starting write-ahead log location.  (The user can ignore this
        result value, but it is provided in case it is useful.)  When used in
        non-exclusive mode, the contents of these files are instead returned
        by the <function>pg_stop_backup</function> function, and should be
        copied to the backup area by the user.
       </para>
       <para>
        This function is restricted to superusers by default, but other users
        can be granted EXECUTE to run the function.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_start_backup</primary>
        </indexterm>
        <function>pg_start_backup</function> (
          <parameter>label</parameter> <type>text</type>
          <optional>, <parameter>fast</parameter> <type>boolean</type>
          <optional>, <parameter>exclusive</parameter> <type>boolean</type>
          </optional></optional> )
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        准备服务器开始在线备份。唯一需要的参数是用于备份的任意用户定义的标签。(通常，备份转储文件将存储在这个名称下。)
        如果可选的第二个参数被指定为<literal>true</literal>，它将指定尽可能快地执行<function>pg_start_backup</function>。
        这将强制产生一个即时检查点，这将导致I/O操作突增，从而降低并发执行的查询的速度。
        第三个可选参数指定是执行排他或非排他备份(默认为排他备份)。
       </para>
       <para>
        在排他模式下使用时，该函数将写一个备份标签文件(<filename>backup_label</filename>)，如果<filename>pg_tblspc/</filename>目录中有任何链接，
        则将一个表空间映射文件(<filename>tablespace_map</filename>)写入数据库集群的数据目录，然后执行检查点，然后返回备份的开始写-提前日志位置。
        (用户可以忽略这个结果值，但在有用的情况下会提供它。)
        在非排他模式下使用时，这些文件的内容将由<function>pg_stop_backup</function>函数返回，并且应该由用户复制到备份区域。
       </para>
       <para>
        默认情况下，该函数仅限超级用户使用，但可以授权其他用户EXECUTE该函数。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stop_backup</primary>
        </indexterm>
        <function>pg_stop_backup</function> (
          <parameter>exclusive</parameter> <type>boolean</type>
          <optional>, <parameter>wait_for_archive</parameter> <type>boolean</type>
          </optional> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>lsn</parameter> <type>pg_lsn</type>,
        <parameter>labelfile</parameter> <type>text</type>,
        <parameter>spcmapfile</parameter> <type>text</type> )
       </para>
       <para>
        Finishes performing an exclusive or non-exclusive on-line backup.
        The <parameter>exclusive</parameter> parameter must match the
        previous <function>pg_start_backup</function> call.
        In an exclusive backup, <function>pg_stop_backup</function> removes
        the backup label file and, if it exists, the tablespace map file
        created by <function>pg_start_backup</function>.  In a non-exclusive
        backup, the desired contents of these files are returned as part of
        the result of the function, and should be written to files in the
        backup area (not in the data directory).
       </para>
       <para>
        There is an optional second parameter of type <type>boolean</type>.
        If false, the function will return immediately after the backup is
        completed, without waiting for WAL to be archived.  This behavior is
        only useful with backup software that independently monitors WAL
        archiving.  Otherwise, WAL required to make the backup consistent might
        be missing and make the backup useless.  By default or when this
        parameter is true, <function>pg_stop_backup</function> will wait for
        WAL to be archived when archiving is enabled.  (On a standby, this
        means that it will wait only when <varname>archive_mode</varname> =
        <literal>always</literal>.  If write activity on the primary is low,
        it may be useful to run <function>pg_switch_wal</function> on the
        primary in order to trigger an immediate segment switch.)
       </para>
       <para>
        When executed on a primary, this function also creates a backup
        history file in the write-ahead log archive area.  The history file
        includes the label given to <function>pg_start_backup</function>, the
        starting and ending write-ahead log locations for the backup, and the
        starting and ending times of the backup.  After recording the ending
        location, the current write-ahead log insertion point is automatically
        advanced to the next write-ahead log file, so that the ending
        write-ahead log file can be archived immediately to complete the
        backup.
       </para>
       <para>
        The result of the function is a single record.
        The <parameter>lsn</parameter> column holds the backup's ending
        write-ahead log location (which again can be ignored).  The second and
        third columns are <literal>NULL</literal> when ending an exclusive
        backup; after a non-exclusive backup they hold the desired contents of
        the label and tablespace map files.
       </para>
       <para>
        This function is restricted to superusers by default, but other users
        can be granted EXECUTE to run the function.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stop_backup</primary>
        </indexterm>
        <function>pg_stop_backup</function> (
          <parameter>exclusive</parameter> <type>boolean</type>
          <optional>, <parameter>wait_for_archive</parameter> <type>boolean</type>
          </optional> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>lsn</parameter> <type>pg_lsn</type>,
        <parameter>labelfile</parameter> <type>text</type>,
        <parameter>spcmapfile</parameter> <type>text</type> )
       </para>
       <para>
        完成排他或非排他联机备份。<parameter>exclusive</parameter>参数必须与前面的<function>pg_start_backup</function>调用相匹配。
        在排他备份中， <function>pg_stop_backup</function>删除备份标签文件，如果存在，则删除<function>pg_start_backup</function>创建的表空间映射文件。
        在非排他备份中，这些文件的所需内容将作为函数结果的一部分返回，并且应该写入备份区域(不在数据目录)中的文件。
       </para>
       <para>
        还有一个可选的<type>boolean</type>类型的第二个参数。如果为假，则该函数将在备份完成后立即返回，而无需等待WAL被归档。
        这种行为只有在独立监控WAL归档的备份软件中才有用。否则，使备份一致所需的WAL可能会丢失，从而使备份无效。
        默认情况下或当该参数为真时，<function>pg_stop_backup</function>将在启用归档时等待WAL被归档。
        (在备用状态下，这意味着只有当<varname>archive_mode</varname> = <literal>always</literal>时，它才会等待。
        如果主节点上的写活动很少，那么可以在主节点上运行<function>pg_switch_wal</function>来触发立即段切换。)
       </para>
       <para>
        当在主节点上执行时，这个函数还会在预写式日志归档区域中创建一个备份历史文件。
        历史文件包括给予<function>pg_start_backup</function>的标签，备份的开始和结束写前预写式日志的位置，以及备份的开始和结束时间。
        记录完结束位置后，当前的预写式日志插入点自动移到下一个预写式日志文件，以便结束的预写式日志文件可以立即归档，从而完成备份。
       </para>
       <para>
        该函数的结果是一条记录。<parameter>lsn</parameter>列保持备份的结束预写式日志位置(可以再忽略)。
        当结束排他备份时，第二和第三列为<literal>NULL</literal>;在非排他备份之后，它们保持标签和表空间映射文件所需的内容。
       </para>
       <para>
        默认情况下该函数仅限超级用户使用，但也可以授权其他用户执行该函数。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>pg_stop_backup</function> ()
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        Finishes performing an exclusive on-line backup.  This simplified
        version is equivalent to <literal>pg_stop_backup(true,
        true)</literal>, except that it only returns the <type>pg_lsn</type>
        result.
       </para>
       <para>
        This function is restricted to superusers by default, but other users
        can be granted EXECUTE to run the function.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>pg_stop_backup</function> ()
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        结束执行排他在线备份。这个简化版本等同于<literal>pg_stop_backup(true, true)</literal>，只是它只返回<type>pg_lsn</type>结果。
       </para>
       <para>
        默认情况下该函数仅限超级用户使用，但可以授权其他用户执行该函数。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_is_in_backup</primary>
        </indexterm>
        <function>pg_is_in_backup</function> ()
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Returns true if an on-line exclusive backup is in progress.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_is_in_backup</primary>
        </indexterm>
        <function>pg_is_in_backup</function> ()
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        如果正在进行联机排他备份则返回真。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_backup_start_time</primary>
        </indexterm>
        <function>pg_backup_start_time</function> ()
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
        Returns the start time of the current on-line exclusive backup if one
        is in progress, otherwise <literal>NULL</literal>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_backup_start_time</primary>
        </indexterm>
        <function>pg_backup_start_time</function> ()
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
        如果正在进行在线排他备份，则返回当前在线排他备份的开始时间，否则为<literal>NULL</literal>。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_switch_wal</primary>
        </indexterm>
        <function>pg_switch_wal</function> ()
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        Forces the server to switch to a new write-ahead log file, which
        allows the current file to be archived (assuming you are using
        continuous archiving).  The result is the ending write-ahead log
        location plus 1 within the just-completed write-ahead log file.  If
        there has been no write-ahead log activity since the last write-ahead
        log switch, <function>pg_switch_wal</function> does nothing and
        returns the start location of the write-ahead log file currently in
        use.
       </para>
       <para>
        This function is restricted to superusers by default, but other users
        can be granted EXECUTE to run the function.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_switch_wal</primary>
        </indexterm>
        <function>pg_switch_wal</function> ()
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        强制服务器切换到一个新的预写式日志文件，这允许对当前文件进行归档(假设你正在使用连续归档)。
        其结果是在刚刚完成的预写式日志文件中结束预写式日志位置加1。
        如果自从上次预写式日志切换以来没有提前写日志活动，<function>pg_switch_wal</function>将不做任何操作，并返回当前正在使用的提前写日志文件的起始位置。
       </para>
       <para>
        默认情况下该函数仅限超级用户使用，但可以授权其他用户执行该函数。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_walfile_name</primary>
        </indexterm>
        <function>pg_walfile_name</function> ( <parameter>lsn</parameter> <type>pg_lsn</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts a write-ahead log location to the name of the WAL file
        holding that location.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_walfile_name</primary>
        </indexterm>
        <function>pg_walfile_name</function> ( <parameter>lsn</parameter> <type>pg_lsn</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将预写式日志位置转换为保持该位置的WAL文件的名称。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_walfile_name_offset</primary>
        </indexterm>
        <function>pg_walfile_name_offset</function> ( <parameter>lsn</parameter> <type>pg_lsn</type> )
        <returnvalue>record</returnvalue>
        ( <parameter>file_name</parameter> <type>text</type>,
        <parameter>file_offset</parameter> <type>integer</type> )
       </para>
       <para>
        Converts a write-ahead log location to a WAL file name and byte offset
        within that file.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_walfile_name_offset</primary>
        </indexterm>
        <function>pg_walfile_name_offset</function> ( <parameter>lsn</parameter> <type>pg_lsn</type> )
        <returnvalue>record</returnvalue>
        ( <parameter>file_name</parameter> <type>text</type>,
        <parameter>file_offset</parameter> <type>integer</type> )
       </para>
       <para>
        将预写式日志位置转换为WAL文件名和该文件中的字节偏移量。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_wal_lsn_diff</primary>
        </indexterm>
        <function>pg_wal_lsn_diff</function> ( <parameter>lsn</parameter> <type>pg_lsn</type>, <parameter>lsn</parameter> <type>pg_lsn</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        Calculates the difference in bytes between two write-ahead log
        locations.  This can be used
        with <structname>pg_stat_replication</structname> or some of the
        functions shown in <xref linkend="functions-admin-backup-table"/> to
        get the replication lag.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_wal_lsn_diff</primary>
        </indexterm>
        <function>pg_wal_lsn_diff</function> ( <parameter>lsn</parameter> <type>pg_lsn</type>, <parameter>lsn</parameter> <type>pg_lsn</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
        计算两个预写式日志位置之间的字节差。
        这可以与<structname>pg_stat_replication</structname>或<xref linkend="functions-admin-backup-table"/>中所示的一些函数一起使用，以获得复制延迟。
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    <function>pg_current_wal_lsn</function> displays the current write-ahead
    log write location in the same format used by the above functions.
    Similarly, <function>pg_current_wal_insert_lsn</function> displays the
    current write-ahead log insertion location
    and <function>pg_current_wal_flush_lsn</function> displays the current
    write-ahead log flush location. The insertion location is
    the <quote>logical</quote> end of the write-ahead log at any instant,
    while the write location is the end of what has actually been written out
    from the server's internal buffers, and the flush location is the last
    location known to be written to durable storage. The write location is the
    end of what can be examined from outside the server, and is usually what
    you want if you are interested in archiving partially-complete write-ahead
    log files.  The insertion and flush locations are made available primarily
    for server debugging purposes.  These are all read-only operations and do
    not require superuser permissions.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_current_wal_lsn</function> 显示当前预写式日志写位置，与上述函数所用的格式相同。
    类似地，<function>pg_current_wal_insert_lsn</function>显示当前预写式日志插入位置，<function>pg_current_wal_flush_lsn</function>显示当前预写式日志刷新位置。
    插入位置是预写式日志在任何时刻的<quote>逻辑(logical)</quote> 结束，而写位置是已经从服务器内部缓冲区实际写入的内容的结束，而刷新位置是已知的要写入持久化存储的最后一个位置。
    写位置是可以从服务器外部检查的最后位置，如果你对归档部分完成的预写式日志文件感兴趣，那么它通常就是你想要的位置。
    插入和刷新位置主要用于服务器调试目的。这些都是只读操作，不需要超级用户权限。
   </para>

<!--==========================orignal english content==========================
   <para>
    You can use <function>pg_walfile_name_offset</function> to extract the
    corresponding write-ahead log file name and byte offset from
    a <type>pg_lsn</type> value.  For example:
<programlisting>
postgres=# SELECT * FROM pg_walfile_name_offset(pg_stop_backup());
        file_name         | file_offset
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 00000001000000000000000D |     4039624
(1 row)
</programlisting>
    Similarly, <function>pg_walfile_name</function> extracts just the write-ahead log file name.
    When the given write-ahead log location is exactly at a write-ahead log file boundary, both
    these functions return the name of the preceding write-ahead log file.
    This is usually the desired behavior for managing write-ahead log archiving
    behavior, since the preceding file is the last one that currently
    needs to be archived.
   </para>
____________________________________________________________________________-->
   <para>
    你可以使用<function>pg_walfile_name_offset</function>从<type>pg_lsn</type>值中提取相应的预写式日志文件名称和字节偏移量。例如:
<programlisting>
postgres=# SELECT * FROM pg_walfile_name_offset(pg_stop_backup());
        file_name         | file_offset
--------------------------+-------------
 00000001000000000000000D |     4039624
(1 row)
</programlisting>
    类似地，<function>pg_walfile_name</function>只提取预写式日志文件名称。
    当给定的预写式日志位置恰好位于预写式日志文件的边界时，这两个函数都会返回前一个预写式日志文件的名称。
    这通常是管理预写式日志归档行为所需的行为，因为前面的文件是当前需要归档的最后一个文件。
   </para>

  </sect2>

  <sect2 id="functions-recovery-control">
<!--==========================orignal english content==========================
   <title>Recovery Control Functions</title>
____________________________________________________________________________-->
   <title>恢复控制函数</title>

<!--==========================orignal english content==========================
   <para>
    The functions shown in <xref
    linkend="functions-recovery-info-table"/> provide information
    about the current status of a standby server.
    These functions may be executed both during recovery and in normal running.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-recovery-info-table"/>中展示的函数提供有关后备服务器当前状态的信息。
    这些函数可以在恢复或普通运行过程中被执行。
   </para>

   <table id="functions-recovery-info-table">
<!--==========================orignal english content==========================
    <title>Recovery Information Functions</title>
____________________________________________________________________________-->
    <title>恢复信息函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_is_in_recovery</primary>
        </indexterm>
        <function>pg_is_in_recovery</function> ()
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Returns true if recovery is still in progress.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_is_in_recovery</primary>
        </indexterm>
        <function>pg_is_in_recovery</function> ()
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        如果恢复仍在进行则返回真。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_last_wal_receive_lsn</primary>
        </indexterm>
        <function>pg_last_wal_receive_lsn</function> ()
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        Returns the last write-ahead log location that has been received and
        synced to disk by streaming replication. While streaming replication
        is in progress this will increase monotonically. If recovery has
        completed then this will remain static at the location of the last WAL
        record received and synced to disk during recovery. If streaming
        replication is disabled, or if it has not yet started, the function
        returns <literal>NULL</literal>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_last_wal_receive_lsn</primary>
        </indexterm>
        <function>pg_last_wal_receive_lsn</function> ()
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        返回已接收并通过流复制同步到磁盘的最后一个预写式日志位置。
        当流复制正在进行时这将单调地增加。如果恢复已经完成，那么在恢复期间，接收到的最后一条WAL记录的位置将保持静态，并同步到磁盘。
        如果流复制已禁用，或者尚未启动，函数将返回<literal>NULL</literal>。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_last_wal_replay_lsn</primary>
        </indexterm>
        <function>pg_last_wal_replay_lsn</function> ()
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        Returns the last write-ahead log location that has been replayed
        during recovery.  If recovery is still in progress this will increase
        monotonically.  If recovery has completed then this will remain
        static at the location of the last WAL record applied during recovery.
        When the server has been started normally without recovery, the
        function returns <literal>NULL</literal>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_last_wal_replay_lsn</primary>
        </indexterm>
        <function>pg_last_wal_replay_lsn</function> ()
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        返回恢复期间重新播放的最后一个预写式日志位置。如果恢复仍在进行中这将会单调地增加。
        如果恢复已经完成，那么恢复期间应用的最后WAL记录的位置将保持静态。当服务器正常启动且没有恢复时，函数返回<literal>NULL</literal>。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_last_xact_replay_timestamp</primary>
        </indexterm>
        <function>pg_last_xact_replay_timestamp</function> ()
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
        Returns the time stamp of the last transaction replayed during
        recovery.  This is the time at which the commit or abort WAL record
        for that transaction was generated on the primary.  If no transactions
        have been replayed during recovery, the function
        returns <literal>NULL</literal>.  Otherwise, if recovery is still in
        progress this will increase monotonically.  If recovery has completed
        then this will remain static at the time of the last transaction
        applied during recovery.  When the server has been started normally
        without recovery, the function returns <literal>NULL</literal>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_last_xact_replay_timestamp</primary>
        </indexterm>
        <function>pg_last_xact_replay_timestamp</function> ()
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
        返回恢复期间重放的最后一个事务的时间戳。这是在主服务器上为该事务生成提交或中止 WAL记录的时间。
        如果在恢复期间没有重放任何事务，该函数将返回<literal>NULL</literal>。否则，如果恢复仍在进行中，这将单调地增加。
        如果恢复已经完成，那么在恢复期间应用最后一个事务时，这将会保持静态。
        当服务器正常启动且没有恢复时，函数返回<literal>NULL</literal>。
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    The functions shown in <xref
    linkend="functions-recovery-control-table"/> control the progress of recovery.
    These functions may be executed only during recovery.
   </para>
____________________________________________________________________________-->
   <para>
    控制恢复进度的功能如 <xref linkend="functions-recovery-control-table"/>所示。这些函数只能在恢复过程中执行。
   </para>

   <table id="functions-recovery-control-table">
<!--==========================orignal english content==========================
    <title>Recovery Control Functions</title>
____________________________________________________________________________-->
    <title>恢复控制函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_is_wal_replay_paused</primary>
        </indexterm>
        <function>pg_is_wal_replay_paused</function> ()
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Returns true if recovery is paused.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_is_wal_replay_paused</primary>
        </indexterm>
        <function>pg_is_wal_replay_paused</function> ()
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        如果恢复暂停了则返回真。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_promote</primary>
        </indexterm>
        <function>pg_promote</function> ( <parameter>wait</parameter> <type>boolean</type> <literal>DEFAULT</literal> <literal>true</literal>, <parameter>wait_seconds</parameter> <type>integer</type> <literal>DEFAULT</literal> <literal>60</literal> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Promotes a standby server to primary status.
        With <parameter>wait</parameter> set to <literal>true</literal> (the
        default), the function waits until promotion is completed
        or <parameter>wait_seconds</parameter> seconds have passed, and
        returns <literal>true</literal> if promotion is successful
        and <literal>false</literal> otherwise.
        If <parameter>wait</parameter> is set to <literal>false</literal>, the
        function returns <literal>true</literal> immediately after sending a
        <literal>SIGUSR1</literal> signal to the postmaster to trigger
        promotion.
       </para>
       <para>
        This function is restricted to superusers by default, but other users
        can be granted EXECUTE to run the function.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_promote</primary>
        </indexterm>
        <function>pg_promote</function> ( <parameter>wait</parameter> <type>boolean</type> <literal>DEFAULT</literal> <literal>true</literal>, <parameter>wait_seconds</parameter> <type>integer</type> <literal>DEFAULT</literal> <literal>60</literal> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        将备用服务器提升为主服务器状态。
        当<parameter>wait</parameter>设置为<literal>true</literal>(默认值)时，函数将等待直到升级完成或<parameter>wait_seconds</parameter>秒数已过，如果升级成功则返回<literal>true</literal>，否则返回<literal>false</literal>。
        如果<parameter>wait</parameter>设置为<literal>false</literal>，则该函数在向postmaster发送<literal>SIGUSR1</literal>信号以触发升级后立即返回<literal>true</literal>。
       </para>
       <para>
        默认情况下这个函数仅限超级用户使用，但可以授权给其他用户执行该函数。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_wal_replay_pause</primary>
        </indexterm>
        <function>pg_wal_replay_pause</function> ()
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Pauses recovery.  While recovery is paused, no further database
        changes are applied.  If hot standby is active, all new queries will
        see the same consistent snapshot of the database, and no further query
        conflicts will be generated until recovery is resumed.
       </para>
       <para>
        This function is restricted to superusers by default, but other users
        can be granted EXECUTE to run the function.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_wal_replay_pause</primary>
        </indexterm>
        <function>pg_wal_replay_pause</function> ()
        <returnvalue>void</returnvalue>
       </para>
       <para>
        暂停恢复。在恢复暂停时，不会应用进一步的数据库更改。
        如果热备是激活的，所有新查询将看到相同的一致的数据库快照，并且在恢复继续之前不会生成进一步的查询冲突。
       </para>
       <para>
        默认情况下该函数仅限超级用户使用，但可以授权其他用户执行该函数。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_wal_replay_resume</primary>
        </indexterm>
        <function>pg_wal_replay_resume</function> ()
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Restarts recovery if it was paused.
       </para>
       <para>
        This function is restricted to superusers by default, but other users
        can be granted EXECUTE to run the function.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_wal_replay_resume</primary>
        </indexterm>
        <function>pg_wal_replay_resume</function> ()
        <returnvalue>void</returnvalue>
       </para>
       <para>
        如果暂停了，则重新启动恢复。
       </para>
       <para>
        默认情况下该函数仅限超级用户使用，但可以授权其他用户执行该函数。
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    <function>pg_wal_replay_pause</function> and
    <function>pg_wal_replay_resume</function> cannot be executed while
    a promotion is ongoing. If a promotion is triggered while recovery
    is paused, the paused state ends and promotion continues.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_wal_replay_pause</function>和<function>pg_wal_replay_resume</function>不能在提升(promotion)进行时执行。
    如果在恢复暂停时触发了提升(promotion)，则暂停状态结束，升级继续进行。
   </para>

<!--==========================orignal english content==========================
   <para>
    If streaming replication is disabled, the paused state may continue
    indefinitely without a problem. If streaming replication is in
    progress then WAL records will continue to be received, which will
    eventually fill available disk space, depending upon the duration of
    the pause, the rate of WAL generation and available disk space.
   </para>
____________________________________________________________________________-->
   <para>
    如果禁用了流复制，则暂停状态可能会无限期地持续下去，不会出现问题。
    如果正在进行流复制，那么将继续接收WAL记录，这将最终填满可用磁盘空间，这取决于暂停持续时间、WAL生成速度和可用磁盘空间。
   </para>

  </sect2>

  <sect2 id="functions-snapshot-synchronization">
<!--==========================orignal english content==========================
   <title>Snapshot Synchronization Functions</title>
____________________________________________________________________________-->
   <title>快照同步函数</title>

<!--==========================orignal english content==========================
   <para>
    <productname>PostgreSQL</productname> allows database sessions to synchronize their
    snapshots. A <firstterm>snapshot</firstterm> determines which data is visible to the
    transaction that is using the snapshot. Synchronized snapshots are
    necessary when two or more sessions need to see identical content in the
    database. If two sessions just start their transactions independently,
    there is always a possibility that some third transaction commits
    between the executions of the two <command>START TRANSACTION</command> commands,
    so that one session sees the effects of that transaction and the other
    does not.
   </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>允许数据库会话同步它们的快照。一个<firstterm>快照</firstterm>决定对于正在使用该快照的事务哪些数据是可见的。当两个或者更多个会话需要看到数据库中的相同内容时，就需要同步快照。如果两个会话独立开始其事务，就总是有可能有某个第三事务在两个<command>START TRANSACTION</command>命令的执行之间提交，这样其中一个会话就可以看到该事务的效果而另一个则看不到。
   </para>

<!--==========================orignal english content==========================
   <para>
    To solve this problem, <productname>PostgreSQL</productname> allows a transaction to
    <firstterm>export</firstterm> the snapshot it is using.  As long as the exporting
    transaction remains open, other transactions can <firstterm>import</firstterm> its
    snapshot, and thereby be guaranteed that they see exactly the same view
    of the database that the first transaction sees.  But note that any
    database changes made by any one of these transactions remain invisible
    to the other transactions, as is usual for changes made by uncommitted
    transactions.  So the transactions are synchronized with respect to
    pre-existing data, but act normally for changes they make themselves.
   </para>
____________________________________________________________________________-->
   <para>
    为了解决这个问题，<productname>PostgreSQL</productname>允许一个事务<firstterm>导出</firstterm>它正在使用的快照。只要导出的事务仍然保持打开，其他事务可以<firstterm>导入</firstterm>它的快照，并且因此可以保证它们可以看到和第一个事务看到的完全一样的数据库视图。但是注意这些事务中的任何一个对数据库所作的更改对其他事务仍然保持不可见，和未提交事务所作的修改一样。因此这些事务是针对以前存在的数据同步，而对由它们自己所作的更改则采取正常的动作。
   </para>

<!--==========================orignal english content==========================
   <para>
    Snapshots are exported with the <function>pg_export_snapshot</function> function,
    shown in <xref linkend="functions-snapshot-synchronization-table"/>, and
    imported with the <xref linkend="sql-set-transaction"/> command.
   </para>
____________________________________________________________________________-->
   <para>
    如<xref linkend="functions-snapshot-synchronization-table"/>中所示，快照通过<function>pg_export_snapshot</function>函数导出，并且通过<xref linkend="sql-set-transaction"/>命令导入。
   </para>

   <table id="functions-snapshot-synchronization-table">
<!--==========================orignal english content==========================
    <title>Snapshot Synchronization Functions</title>
____________________________________________________________________________-->
    <title>快照同步函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_export_snapshot</primary>
        </indexterm>
        <function>pg_export_snapshot</function> ()
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Saves the transaction's current snapshot and returns
        a <type>text</type> string identifying the snapshot.  This string must
        be passed (outside the database) to clients that want to import the
        snapshot.  The snapshot is available for import only until the end of
        the transaction that exported it.
       </para>
       <para>
        A transaction can export more than one snapshot, if needed.  Note that
        doing so is only useful in <literal>READ COMMITTED</literal>
        transactions, since in <literal>REPEATABLE READ</literal> and higher
        isolation levels, transactions use the same snapshot throughout their
        lifetime.  Once a transaction has exported any snapshots, it cannot be
        prepared with <xref linkend="sql-prepare-transaction"/>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_export_snapshot</primary>
        </indexterm>
        <function>pg_export_snapshot</function> ()
        <returnvalue>text</returnvalue>
       </para>
       <para>
        保存事务的当前快照并返回<type>text</type>字符串以标识该快照。
        必须将此字符串传递(在数据库之外)给希望导入快照的客户端。快照仅在导出它的事务结束之前才可用于导入。
       </para>
       <para>
        如果需要的话，一个事务可以导出多个快照。
        请注意，这样做仅在<literal>READ COMMITTED</literal>事务中有用，因为在<literal>REPEATABLE READ</literal>和更高的隔离级别中，事务在它们的生命周期中使用相同的快照。
        一旦事务导出了快照，它就不能用 <xref linkend="sql-prepare-transaction"/>进行准备。
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  </sect2>

  <sect2 id="functions-replication">
<!--==========================orignal english content==========================
   <title>Replication Management Functions</title>
____________________________________________________________________________-->
   <title>复制管理函数</title>

<!--==========================orignal english content==========================
   <para>
    The functions shown
    in <xref linkend="functions-replication-table"/> are for
    controlling and interacting with replication features.
    See <xref linkend="streaming-replication"/>,
    <xref linkend="streaming-replication-slots"/>, and
    <xref linkend="replication-origins"/>
    for information about the underlying features.
    Use of functions for replication origin is restricted to superusers.
    Use of functions for replication slots is restricted to superusers
    and users having <literal>REPLICATION</literal> privilege.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-replication-table"/>中展示的函数
    用于控制以及与复制特性交互。有关底层特性的信息请见
    <xref linkend="streaming-replication"/>、
    <xref linkend="streaming-replication-slots"/>以及
    <xref linkend="replication-origins"/>。复制原点函数的使用仅限于超级用户。 复制槽的函数只限于超级用户和拥有<literal>REPLICATION</literal>权限的用户。
   </para>

<!--==========================orignal english content==========================
   <para>
    Many of these functions have equivalent commands in the replication
    protocol; see <xref linkend="protocol-replication"/>.
   </para>
____________________________________________________________________________-->
   <para>
    很多这些函数在复制协议中都有等价的命令，见
    <xref linkend="protocol-replication"/>。
   </para>

<!--==========================orignal english content==========================
   <para>
    The functions described in
    <xref linkend="functions-admin-backup"/>,
    <xref linkend="functions-recovery-control"/>, and
    <xref linkend="functions-snapshot-synchronization"/>
    are also relevant for replication.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-admin-backup"/>、
    <xref linkend="functions-recovery-control"/>和
    <xref linkend="functions-snapshot-synchronization"/>
    中描述的函数也与复制相关。
   </para>

   <table id="functions-replication-table">
<!--==========================orignal english content==========================
    <title>Replication Management Functions</title>
____________________________________________________________________________-->
    <title>复制管理函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_create_physical_replication_slot</primary>
        </indexterm>
        <function>pg_create_physical_replication_slot</function> ( <parameter>slot_name</parameter> <type>name</type> <optional>, <parameter>immediately_reserve</parameter> <type>boolean</type>, <parameter>temporary</parameter> <type>boolean</type> </optional> )
        <returnvalue>record</returnvalue>
        ( <parameter>slot_name</parameter> <type>name</type>,
        <parameter>lsn</parameter> <type>pg_lsn</type> )
       </para>
       <para>
        Creates a new physical replication slot named
        <parameter>slot_name</parameter>. The optional second parameter,
        when <literal>true</literal>, specifies that the <acronym>LSN</acronym> for this
        replication slot be reserved immediately; otherwise
        the <acronym>LSN</acronym> is reserved on first connection from a streaming
        replication client. Streaming changes from a physical slot is only
        possible with the streaming-replication protocol &mdash;
        see <xref linkend="protocol-replication"/>. The optional third
        parameter, <parameter>temporary</parameter>, when set to true, specifies that
        the slot should not be permanently stored to disk and is only meant
        for use by the current session. Temporary slots are also
        released upon any error. This function corresponds
        to the replication protocol command <literal>CREATE_REPLICATION_SLOT
        ... PHYSICAL</literal>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_create_physical_replication_slot</primary>
        </indexterm>
        <function>pg_create_physical_replication_slot</function> ( <parameter>slot_name</parameter> <type>name</type> <optional>, <parameter>immediately_reserve</parameter> <type>boolean</type>, <parameter>temporary</parameter> <type>boolean</type> </optional> )
        <returnvalue>record</returnvalue>
        ( <parameter>slot_name</parameter> <type>name</type>,
        <parameter>lsn</parameter> <type>pg_lsn</type> )
       </para>
       <para>
        创建一个新的名为<parameter>slot_name</parameter>的物理复制槽。
        第二个参数是可选的，当它为<literal>true</literal>时，立即为这个物理槽指定要被保留的<acronym>LSN</acronym>。
        否则该<acronym>LSN</acronym>会被保留在来自一个流复制客户端的第一个连接上。
        来自一个物理槽的流改变只可能出现在使用流复制协议时 &mdash; 见<xref linkend="protocol-replication"/>。
        当可选的第三参数<parameter>temporary</parameter>被设置为真时，指定那个槽不会被持久地存储在磁盘上并且仅对当前会话的使用有意义。
        临时槽也会在发生任何错误时被释放。这个函数对应于复制协议命令<literal>CREATE_REPLICATION_SLOT ... PHYSICAL</literal>。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_drop_replication_slot</primary>
        </indexterm>
        <function>pg_drop_replication_slot</function> ( <parameter>slot_name</parameter> <type>name</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Drops the physical or logical replication slot
        named <parameter>slot_name</parameter>. Same as replication protocol
        command <literal>DROP_REPLICATION_SLOT</literal>. For logical slots, this must
        be called while connected to the same database the slot was created on.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_drop_replication_slot</primary>
        </indexterm>
        <function>pg_drop_replication_slot</function> ( <parameter>slot_name</parameter> <type>name</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        丢弃名为<parameter>slot_name</parameter>的物理或逻辑复制槽。
        和复制协议命令<literal>DROP_REPLICATION_SLOT</literal>相同。对于逻辑槽，
        在连接到在其中创建该槽的同一个数据库时，必须调用这个函数。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_create_logical_replication_slot</primary>
        </indexterm>
        <function>pg_create_logical_replication_slot</function> ( <parameter>slot_name</parameter> <type>name</type>, <parameter>plugin</parameter> <type>name</type> <optional>, <parameter>temporary</parameter> <type>boolean</type> </optional> )
        <returnvalue>record</returnvalue>
        ( <parameter>slot_name</parameter> <type>name</type>,
        <parameter>lsn</parameter> <type>pg_lsn</type> )
       </para>
       <para>
        Creates a new logical (decoding) replication slot named
        <parameter>slot_name</parameter> using the output plugin
        <parameter>plugin</parameter>. The optional third
        parameter, <parameter>temporary</parameter>, when set to true, specifies that
        the slot should not be permanently stored to disk and is only meant
        for use by the current session. Temporary slots are also
        released upon any error. A call to this function has the same
        effect as the replication protocol command
        <literal>CREATE_REPLICATION_SLOT ... LOGICAL</literal>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_create_logical_replication_slot</primary>
        </indexterm>
        <function>pg_create_logical_replication_slot</function> ( <parameter>slot_name</parameter> <type>name</type>, <parameter>plugin</parameter> <type>name</type> <optional>, <parameter>temporary</parameter> <type>boolean</type> </optional> )
        <returnvalue>record</returnvalue>
        ( <parameter>slot_name</parameter> <type>name</type>,
        <parameter>lsn</parameter> <type>pg_lsn</type> )
       </para>
       <para>
        使用输出插件<parameter>plugin</parameter>创建一个名字为<parameter>slot_name</parameter>的新逻辑（解码）复制槽。
        当可选的第三参数<parameter>temporary</parameter>被设置为真时，指定那个槽不会被持久地存储在磁盘上并且仅对当前会话的使用有意义。
        临时槽也会在发生任何错误时被释放。对这个函数的调用与复制协议命令<literal>CREATE_REPLICATION_SLOT ... LOGICAL</literal>。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_copy_physical_replication_slot</primary>
        </indexterm>
        <function>pg_copy_physical_replication_slot</function> ( <parameter>src_slot_name</parameter> <type>name</type>, <parameter>dst_slot_name</parameter> <type>name</type> <optional>, <parameter>temporary</parameter> <type>boolean</type> </optional> )
        <returnvalue>record</returnvalue>
        ( <parameter>slot_name</parameter> <type>name</type>,
        <parameter>lsn</parameter> <type>pg_lsn</type> )
       </para>
       <para>
        Copies an existing physical replication slot named <parameter>src_slot_name</parameter>
        to a physical replication slot named <parameter>dst_slot_name</parameter>.
        The copied physical slot starts to reserve WAL from the same <acronym>LSN</acronym> as the
        source slot.
        <parameter>temporary</parameter> is optional. If <parameter>temporary</parameter>
        is omitted, the same value as the source slot is used.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_copy_physical_replication_slot</primary>
        </indexterm>
        <function>pg_copy_physical_replication_slot</function> ( <parameter>src_slot_name</parameter> <type>name</type>, <parameter>dst_slot_name</parameter> <type>name</type> <optional>, <parameter>temporary</parameter> <type>boolean</type> </optional> )
        <returnvalue>record</returnvalue>
        ( <parameter>slot_name</parameter> <type>name</type>,
        <parameter>lsn</parameter> <type>pg_lsn</type> )
       </para>
       <para>
        将一个名为<parameter>src_slot_name</parameter>的现有物理复制槽复制到一个名为<parameter>dst_slot_name</parameter>的物理复制槽。
        被复制的物理槽开始从与源槽相同的<acronym>LSN</acronym>开始保留WAL。<parameter>temporary</parameter>是可选的。
        如果省略了<parameter>temporary</parameter>，则使用与源槽相同的值。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_copy_logical_replication_slot</primary>
        </indexterm>
        <function>pg_copy_logical_replication_slot</function> ( <parameter>src_slot_name</parameter> <type>name</type>, <parameter>dst_slot_name</parameter> <type>name</type> <optional>, <parameter>temporary</parameter> <type>boolean</type> <optional>, <parameter>plugin</parameter> <type>name</type> </optional></optional> )
        <returnvalue>record</returnvalue>
        ( <parameter>slot_name</parameter> <type>name</type>,
        <parameter>lsn</parameter> <type>pg_lsn</type> )
       </para>
       <para>
        Copies an existing logical replication slot
        named <parameter>src_slot_name</parameter> to a logical replication
        slot named <parameter>dst_slot_name</parameter>, optionally changing
        the output plugin and persistence.  The copied logical slot starts
        from the same <acronym>LSN</acronym> as the source logical slot.  Both
        <parameter>temporary</parameter> and <parameter>plugin</parameter> are
        optional; if they are omitted, the values of the source slot are used.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_copy_logical_replication_slot</primary>
        </indexterm>
        <function>pg_copy_logical_replication_slot</function> ( <parameter>src_slot_name</parameter> <type>name</type>, <parameter>dst_slot_name</parameter> <type>name</type> <optional>, <parameter>temporary</parameter> <type>boolean</type> <optional>, <parameter>plugin</parameter> <type>name</type> </optional></optional> )
        <returnvalue>record</returnvalue>
        ( <parameter>slot_name</parameter> <type>name</type>,
        <parameter>lsn</parameter> <type>pg_lsn</type> )
       </para>
       <para>
        复制一个名为<parameter>src_slot_name</parameter>的现有逻辑复制槽到一个名为<parameter>dst_slot_name</parameter>的逻辑复制槽，选择性的改变输出插件和持久性。
        被复制的逻辑槽从与源逻辑槽相同的<acronym>LSN</acronym>开始。<parameter>temporary</parameter>和<parameter>plugin</parameter>都是可选的。
        如果它们被省略了，使用与源逻辑槽相同的值。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_logical_slot_get_changes</primary>
        </indexterm>
        <function>pg_logical_slot_get_changes</function> ( <parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>integer</type>, <literal>VARIADIC</literal> <parameter>options</parameter> <type>text[]</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>lsn</parameter> <type>pg_lsn</type>,
        <parameter>xid</parameter> <type>xid</type>,
        <parameter>data</parameter> <type>text</type> )
       </para>
       <para>
        Returns changes in the slot <parameter>slot_name</parameter>, starting
        from the point from which changes have been consumed last.  If
        <parameter>upto_lsn</parameter>
        and <parameter>upto_nchanges</parameter> are NULL,
        logical decoding will continue until end of WAL.  If
        <parameter>upto_lsn</parameter> is non-NULL, decoding will include only
        those transactions which commit prior to the specified LSN.  If
        <parameter>upto_nchanges</parameter> is non-NULL, decoding will
        stop when the number of rows produced by decoding exceeds
        the specified value.  Note, however, that the actual number of
        rows returned may be larger, since this limit is only checked after
        adding the rows produced when decoding each new transaction commit.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_logical_slot_get_changes</primary>
        </indexterm>
        <function>pg_logical_slot_get_changes</function> ( <parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>integer</type>, <literal>VARIADIC</literal> <parameter>options</parameter> <type>text[]</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>lsn</parameter> <type>pg_lsn</type>,
        <parameter>xid</parameter> <type>xid</type>,
        <parameter>data</parameter> <type>text</type> )
       </para>
       <para>
        返回槽<parameter>slot_name</parameter>中的改变，从最后一次使用更改的点开始。
        如果<parameter>upto_lsn</parameter>和<parameter>upto_nchanges</parameter>为 NULL，逻辑解码将一直继续到 WAL 的末尾。
        如果<parameter>upto_lsn</parameter>为非 NULL，解码将只包括那些在指定 LSN 之前提交的事务。
        如果<parameter>upto_nchanges</parameter>为非 NULL，解码将在其产生的行数超过指定值后停止。
        不过要注意，被返回的实际行数可能更大，因为对这个限制的检查只会在增加了解码每个新的提交事务产生的行之后进行。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_logical_slot_peek_changes</primary>
        </indexterm>
        <function>pg_logical_slot_peek_changes</function> ( <parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>integer</type>, <literal>VARIADIC</literal> <parameter>options</parameter> <type>text[]</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>lsn</parameter> <type>pg_lsn</type>,
        <parameter>xid</parameter> <type>xid</type>,
         <parameter>data</parameter> <type>text</type> )
       </para>
       <para>
        Behaves just like
        the <function>pg_logical_slot_get_changes()</function> function,
        except that changes are not consumed; that is, they will be returned
        again on future calls.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_logical_slot_peek_changes</primary>
        </indexterm>
        <function>pg_logical_slot_peek_changes</function> ( <parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>integer</type>, <literal>VARIADIC</literal> <parameter>options</parameter> <type>text[]</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>lsn</parameter> <type>pg_lsn</type>,
        <parameter>xid</parameter> <type>xid</type>,
         <parameter>data</parameter> <type>text</type> )
       </para>
       <para>
        行为就像<function>pg_logical_slot_get_changes()</function>函数，
        不过改变不会被消费， 即在未来的调用中还会返回这些改变。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_logical_slot_get_binary_changes</primary>
        </indexterm>
        <function>pg_logical_slot_get_binary_changes</function> ( <parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>integer</type>, <literal>VARIADIC</literal> <parameter>options</parameter> <type>text[]</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>lsn</parameter> <type>pg_lsn</type>,
        <parameter>xid</parameter> <type>xid</type>,
        <parameter>data</parameter> <type>bytea</type> )
       </para>
       <para>
        Behaves just like
        the <function>pg_logical_slot_get_changes()</function> function,
        except that changes are returned as <type>bytea</type>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_logical_slot_get_binary_changes</primary>
        </indexterm>
        <function>pg_logical_slot_get_binary_changes</function> ( <parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>integer</type>, <literal>VARIADIC</literal> <parameter>options</parameter> <type>text[]</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>lsn</parameter> <type>pg_lsn</type>,
        <parameter>xid</parameter> <type>xid</type>,
        <parameter>data</parameter> <type>bytea</type> )
       </para>
       <para>
        行为就像<function>pg_logical_slot_get_changes()</function>函数，
        不过改变会以<type>bytea</type>返回。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_logical_slot_peek_binary_changes</primary>
        </indexterm>
        <function>pg_logical_slot_peek_binary_changes</function> ( <parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>integer</type>, <literal>VARIADIC</literal> <parameter>options</parameter> <type>text[]</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>lsn</parameter> <type>pg_lsn</type>,
        <parameter>xid</parameter> <type>xid</type>,
        <parameter>data</parameter> <type>bytea</type> )
       </para>
       <para>
        Behaves just like
        the <function>pg_logical_slot_peek_changes()</function> function,
        except that changes are returned as <type>bytea</type>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_logical_slot_peek_binary_changes</primary>
        </indexterm>
        <function>pg_logical_slot_peek_binary_changes</function> ( <parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>integer</type>, <literal>VARIADIC</literal> <parameter>options</parameter> <type>text[]</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>lsn</parameter> <type>pg_lsn</type>,
        <parameter>xid</parameter> <type>xid</type>,
        <parameter>data</parameter> <type>bytea</type> )
       </para>
       <para>
        行为就像<function>pg_logical_slot_peek_changes()</function>函数，不过改变会以<type>bytea</type>返回。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_slot_advance</primary>
        </indexterm>
        <function>pg_replication_slot_advance</function> ( <parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type> )
        <returnvalue>record</returnvalue>
        ( <parameter>slot_name</parameter> <type>name</type>,
        <parameter>end_lsn</parameter> <type>pg_lsn</type> )
       </para>
       <para>
        Advances the current confirmed position of a replication slot named
        <parameter>slot_name</parameter>. The slot will not be moved backwards,
        and it will not be moved beyond the current insert location. Returns
        the name of the slot and the actual position that it was advanced to.
        The updated slot position information is written out at the next
        checkpoint if any advancing is done. So in the event of a crash, the
        slot may return to an earlier position.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_slot_advance</primary>
        </indexterm>
        <function>pg_replication_slot_advance</function> ( <parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type> )
        <returnvalue>record</returnvalue>
        ( <parameter>slot_name</parameter> <type>name</type>,
        <parameter>end_lsn</parameter> <type>pg_lsn</type> )
       </para>
       <para>
        将复制槽的当前确认的位置提前到名为<parameter>slot_name</parameter>的复制槽的当前确认位置。
        该槽不会向后移动，也不会移动到当前插入位置之外。返回该槽的名称和它被推进到的真实位置。
        如果有任何进展，则在下一个检查点中写出更新后的槽位置信息。所以如果发生崩溃，该槽位可能会返回到之前的位置。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry id="pg-replication-origin-create" role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_origin_create</primary>
        </indexterm>
        <function>pg_replication_origin_create</function> ( <parameter>node_name</parameter> <type>text</type> )
        <returnvalue>oid</returnvalue>
       </para>
       <para>
        Creates a replication origin with the given external
        name, and returns the internal ID assigned to it.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry id="pg-replication-origin-create" role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_origin_create</primary>
        </indexterm>
        <function>pg_replication_origin_create</function> ( <parameter>node_name</parameter> <type>text</type> )
        <returnvalue>oid</returnvalue>
       </para>
       <para>
        用给定的外部名称创建一个复制源，并且返回分配给它的内部 ID。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry id="pg-replication-origin-drop" role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_origin_drop</primary>
        </indexterm>
        <function>pg_replication_origin_drop</function> ( <parameter>node_name</parameter> <type>text</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Deletes a previously-created replication origin, including any
        associated replay progress.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry id="pg-replication-origin-drop" role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_origin_drop</primary>
        </indexterm>
        <function>pg_replication_origin_drop</function> ( <parameter>node_name</parameter> <type>text</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        删除一个以前创建的复制源，包括任何相关的重放进度。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_origin_oid</primary>
        </indexterm>
        <function>pg_replication_origin_oid</function> ( <parameter>node_name</parameter> <type>text</type> )
        <returnvalue>oid</returnvalue>
       </para>
       <para>
        Looks up a replication origin by name and returns the internal ID. If
        no such replication origin is found an error is thrown.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_origin_oid</primary>
        </indexterm>
        <function>pg_replication_origin_oid</function> ( <parameter>node_name</parameter> <type>text</type> )
        <returnvalue>oid</returnvalue>
       </para>
       <para>
        根据名称查找复制源并返回内部ID。如果没有发现这样的复制源，则抛出错误。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry id="pg-replication-origin-session-setup" role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_origin_session_setup</primary>
        </indexterm>
        <function>pg_replication_origin_session_setup</function> ( <parameter>node_name</parameter> <type>text</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Marks the current session as replaying from the given
        origin, allowing replay progress to be tracked.
        Can only be used if no origin is currently selected.
        Use <function>pg_replication_origin_session_reset</function> to undo.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry id="pg-replication-origin-session-setup" role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_origin_session_setup</primary>
        </indexterm>
        <function>pg_replication_origin_session_setup</function> ( <parameter>node_name</parameter> <type>text</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        将当前会话标记为从给定的原点回放，从而允许跟踪回放进度。
        只能在当前没有选择原点时使用。使用<function>pg_replication_origin_session_reset</function> 命令来撤销。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_origin_session_reset</primary>
        </indexterm>
        <function>pg_replication_origin_session_reset</function> ()
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Cancels the effects
        of <function>pg_replication_origin_session_setup()</function>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_origin_session_reset</primary>
        </indexterm>
        <function>pg_replication_origin_session_reset</function> ()
        <returnvalue>void</returnvalue>
       </para>
       <para>
        取消<function>pg_replication_origin_session_setup()</function>的效果。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_origin_session_is_setup</primary>
        </indexterm>
        <function>pg_replication_origin_session_is_setup</function> ()
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Returns true if a replication origin has been selected in the
        current session.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_origin_session_is_setup</primary>
        </indexterm>
        <function>pg_replication_origin_session_is_setup</function> ()
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        如果在当前会话中选择了复制源则返回真。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry id="pg-replication-origin-session-progress" role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_origin_session_progress</primary>
        </indexterm>
        <function>pg_replication_origin_session_progress</function> ( <parameter>flush</parameter> <type>boolean</type> )
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        Returns the replay location for the replication origin selected in
        the current session. The parameter <parameter>flush</parameter>
        determines whether the corresponding local transaction will be
        guaranteed to have been flushed to disk or not.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry id="pg-replication-origin-session-progress" role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_origin_session_progress</primary>
        </indexterm>
        <function>pg_replication_origin_session_progress</function> ( <parameter>flush</parameter> <type>boolean</type> )
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        返回当前会话中选择的复制源的重放位置。参数<parameter>flush</parameter>决定对应的本地事务是否被确保已经刷入磁盘。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry id="pg-replication-origin-xact-setup" role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_origin_xact_setup</primary>
        </indexterm>
        <function>pg_replication_origin_xact_setup</function> ( <parameter>origin_lsn</parameter> <type>pg_lsn</type>, <parameter>origin_timestamp</parameter> <type>timestamp with time zone</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Marks the current transaction as replaying a transaction that has
        committed at the given <acronym>LSN</acronym> and timestamp. Can
        only be called when a replication origin has been selected
        using <function>pg_replication_origin_session_setup</function>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry id="pg-replication-origin-xact-setup" role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_origin_xact_setup</primary>
        </indexterm>
        <function>pg_replication_origin_xact_setup</function> ( <parameter>origin_lsn</parameter> <type>pg_lsn</type>, <parameter>origin_timestamp</parameter> <type>timestamp with time zone</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        将当前事务标记为重放在给定<acronym>LSN</acronym>和时间戳上提交的事务。
        只能在使用<function>pg_replication_origin_session_setup</function>选择复制源时调用。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry id="pg-replication-origin-xact-reset" role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_origin_xact_reset</primary>
        </indexterm>
        <function>pg_replication_origin_xact_reset</function> ()
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Cancels the effects of
        <function>pg_replication_origin_xact_setup()</function>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry id="pg-replication-origin-xact-reset" role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_origin_xact_reset</primary>
        </indexterm>
        <function>pg_replication_origin_xact_reset</function> ()
        <returnvalue>void</returnvalue>
       </para>
       <para>
        取消<function>pg_replication_origin_xact_setup()</function>的效果。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry id="pg-replication-origin-advance" role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_origin_advance</primary>
        </indexterm>
        <function>pg_replication_origin_advance</function> ( <parameter>node_name</parameter> <type>text</type>, <parameter>lsn</parameter> <type>pg_lsn</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Sets replication progress for the given node to the given
        location. This is primarily useful for setting up the initial
        location, or setting a new location after configuration changes and
        similar. Be aware that careless use of this function can lead to
        inconsistently replicated data.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry id="pg-replication-origin-advance" role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_origin_advance</primary>
        </indexterm>
        <function>pg_replication_origin_advance</function> ( <parameter>node_name</parameter> <type>text</type>, <parameter>lsn</parameter> <type>pg_lsn</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        将给定节点的复制进度设置为给定的位置。这主要用于设置初始位置，或在配置更改或类似的变更后设置新位置。
        请注意这个函数的不当使用可能会导致不一致的复制数据。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry id="pg-replication-origin-progress" role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_origin_progress</primary>
        </indexterm>
        <function>pg_replication_origin_progress</function> ( <parameter>node_name</parameter> <type>text</type>, <parameter>flush</parameter> <type>boolean</type> )
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        Returns the replay location for the given replication origin. The
        parameter <parameter>flush</parameter> determines whether the
        corresponding local transaction will be guaranteed to have been
        flushed to disk or not.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry id="pg-replication-origin-progress" role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_replication_origin_progress</primary>
        </indexterm>
        <function>pg_replication_origin_progress</function> ( <parameter>node_name</parameter> <type>text</type>, <parameter>flush</parameter> <type>boolean</type> )
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        返回给定复制元的重放位置。参数<parameter>flush</parameter>决定对应的本地事务是否被确保已经刷入磁盘。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_logical_emit_message</primary>
        </indexterm>
        <function>pg_logical_emit_message</function> ( <parameter>transactional</parameter> <type>boolean</type>, <parameter>prefix</parameter> <type>text</type>, <parameter>content</parameter> <type>text</type> )
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_logical_emit_message</function> ( <parameter>transactional</parameter> <type>boolean</type>, <parameter>prefix</parameter> <type>text</type>, <parameter>content</parameter> <type>bytea</type> )
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        Emits a logical decoding message. This can be used to pass generic
        messages to logical decoding plugins through
        WAL. The <parameter>transactional</parameter> parameter specifies if
        the message should be part of the current transaction, or if it should
        be written immediately and decoded as soon as the logical decoder
        reads the record. The <parameter>prefix</parameter> parameter is a
        textual prefix that can be used by logical decoding plugins to easily
        recognize messages that are interesting for them.
        The <parameter>content</parameter> parameter is the content of the
        message, given either in text or binary form.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_logical_emit_message</primary>
        </indexterm>
        <function>pg_logical_emit_message</function> ( <parameter>transactional</parameter> <type>boolean</type>, <parameter>prefix</parameter> <type>text</type>, <parameter>content</parameter> <type>text</type> )
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_logical_emit_message</function> ( <parameter>transactional</parameter> <type>boolean</type>, <parameter>prefix</parameter> <type>text</type>, <parameter>content</parameter> <type>bytea</type> )
        <returnvalue>pg_lsn</returnvalue>
       </para>
       <para>
        发出逻辑解码消息。这可以被用来通过 WAL 向逻辑解码插件传递一般消息。
        <parameter>transactional</parameter>参数指定该消息是否应该是当前事务的一部分或者当逻辑解码读到该记录时该消息是否应该被立刻写入并且解码。
        <parameter>prefix</parameter>参数是逻辑解码插件可以用来识别它们感兴趣的消息的文本前缀。
        <parameter>content</parameter>是消息的文本，以文本或二进制形式给出。
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  </sect2>

  <sect2 id="functions-admin-dbobject">
<!--==========================orignal english content==========================
   <title>Database Object Management Functions</title>
____________________________________________________________________________-->
   <title>数据库对象管理函数</title>

<!--==========================orignal english content==========================
   <para>
    The functions shown in <xref linkend="functions-admin-dbsize"/> calculate
    the disk space usage of database objects, or assist in presentation
    of usage results.
    All these functions return sizes measured in bytes.  If an OID that does
    not represent an existing object is passed to one of these
    functions, <literal>NULL</literal> is returned.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-admin-dbsize"/>中所示的函数计算数据库对象的磁盘空间使用情况，或帮助表示使用结果。
    所有这些函数都返回以字节为单位的大小。如果将不代表已有对象的OID传递给这些函数之一，则返回<literal>NULL</literal>。
   </para>

   <table id="functions-admin-dbsize">
<!--==========================orignal english content==========================
    <title>Database Object Size Functions</title>
____________________________________________________________________________-->
    <title>数据库对象尺寸函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_column_size</primary>
        </indexterm>
        <function>pg_column_size</function> ( <type>"any"</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Shows the number of bytes used to store any individual data value.  If
        applied directly to a table column value, this reflects any
        compression that was done.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_column_size</primary>
        </indexterm>
        <function>pg_column_size</function> ( <type>"any"</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        显示用于存储任何单个数据值的字节数。如果直接应用于表的列值，则反映所做的任何压缩。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_database_size</primary>
        </indexterm>
        <function>pg_database_size</function> ( <type>name</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_database_size</function> ( <type>oid</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Computes the total disk space used by the database with the specified
        name or OID.  To use this function, you must
        have <literal>CONNECT</literal> privilege on the specified database
        (which is granted by default) or be a member of
        the <literal>pg_read_all_stats</literal> role.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_database_size</primary>
        </indexterm>
        <function>pg_database_size</function> ( <type>name</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_database_size</function> ( <type>oid</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        计算指定名称或OID的数据库所使用的总磁盘空间。
        要使用这个函数，你必须拥有<literal>CONNECT</literal>特权(默认授予)在指定的数据库上，或者是<literal>pg_read_all_stats</literal>角色的成员。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_indexes_size</primary>
        </indexterm>
        <function>pg_indexes_size</function> ( <type>regclass</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Computes the total disk space used by indexes attached to the
        specified table.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_indexes_size</primary>
        </indexterm>
        <function>pg_indexes_size</function> ( <type>regclass</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        计算附加到指定表的索引所使用的总磁盘空间。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_relation_size</primary>
        </indexterm>
        <function>pg_relation_size</function> ( <parameter>relation</parameter> <type>regclass</type> <optional>, <parameter>fork</parameter> <type>text</type> </optional> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Computes the disk space used by one <quote>fork</quote> of the
        specified relation.  (Note that for most purposes it is more
        convenient to use the higher-level
        functions <function>pg_total_relation_size</function>
        or <function>pg_table_size</function>, which sum the sizes of all
        forks.)  With one argument, this returns the size of the main data
        fork of the relation.  The second argument can be provided to specify
        which fork to examine:
        <itemizedlist spacing="compact">
         <listitem>
          <para>
           <literal>main</literal> returns the size of the main
           data fork of the relation.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>fsm</literal> returns the size of the Free Space Map
           (see <xref linkend="storage-fsm"/>) associated with the relation.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>vm</literal> returns the size of the Visibility Map
           (see <xref linkend="storage-vm"/>) associated with the relation.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>init</literal> returns the size of the initialization
           fork, if any, associated with the relation.
          </para>
         </listitem>
        </itemizedlist>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_relation_size</primary>
        </indexterm>
        <function>pg_relation_size</function> ( <parameter>relation</parameter> <type>regclass</type> <optional>, <parameter>fork</parameter> <type>text</type> </optional> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        计算指定关系的一个<quote>fork</quote>所使用的磁盘空间。
        (注意在大多数情况下，使用更高级的函数 <function>pg_total_relation_size</function>或<function>pg_table_size</function>更方便，它们将所有分叉(forks)的大小相加。)
        使用一个参数，这将返回关系的主数据分叉的大小。第二个参数可以用来指定要检查哪个分叉:
        <itemizedlist spacing="compact">
         <listitem>
          <para>
           <literal>main</literal>返回关系的主数据分叉的大小。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>fsm</literal> 返回与该关系关联的空闲空间映射(参见<xref linkend="storage-fsm"/>)的大小。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>vm</literal> 返回与该关系相关联的可见性映射(参见<xref linkend="storage-vm"/>)的大小。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>init</literal> 返回初始化分叉的大小，如果有的话，与关系相关。
          </para>
         </listitem>
        </itemizedlist>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_size_bytes</primary>
        </indexterm>
        <function>pg_size_bytes</function> ( <type>text</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Converts a size in human-readable format (as returned
        by <function>pg_size_pretty</function>) into bytes.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_size_bytes</primary>
        </indexterm>
        <function>pg_size_bytes</function> ( <type>text</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        将人可阅读的格式的大小(由<function>pg_size_pretty</function>返回)转换为字节。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_size_pretty</primary>
        </indexterm>
        <function>pg_size_pretty</function> ( <type>bigint</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_size_pretty</function> ( <type>numeric</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts a size in bytes into a more easily human-readable format with
        size units (bytes, kB, MB, GB or TB as appropriate).  Note that the
        units are powers of 2 rather than powers of 10, so 1kB is 1024 bytes,
        1MB is 1024<superscript>2</superscript> = 1048576 bytes, and so on.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_size_pretty</primary>
        </indexterm>
        <function>pg_size_pretty</function> ( <type>bigint</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_size_pretty</function> ( <type>numeric</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        将以字节为单位的大小转换为更容易被人阅读的格式，使用大小单位(酌情采用字节、kB、MB、GB或TB等等)。
        注意，单位是2的幂，而不是10的幂，所以1kB是1024字节，1MB是1024<superscript>2</superscript> = 1048576字节，依此类推。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_table_size</primary>
        </indexterm>
        <function>pg_table_size</function> ( <type>regclass</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Computes the disk space used by the specified table, excluding indexes
        (but including its TOAST table if any, free space map, and visibility
        map).
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_table_size</primary>
        </indexterm>
        <function>pg_table_size</function> ( <type>regclass</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        计算指定表所使用的磁盘空间，不包括索引(但包括它的TOAST表，如果有的话，空闲空间映射，以及可见性映射)。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_tablespace_size</primary>
        </indexterm>
        <function>pg_tablespace_size</function> ( <type>name</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_tablespace_size</function> ( <type>oid</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Computes the total disk space used in the tablespace with the
        specified name or OID. To use this function, you must
        have <literal>CREATE</literal> privilege on the specified tablespace
        or be a member of the <literal>pg_read_all_stats</literal> role,
        unless it is the default tablespace for the current database.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_tablespace_size</primary>
        </indexterm>
        <function>pg_tablespace_size</function> ( <type>name</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_tablespace_size</function> ( <type>oid</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        使用指定的名称或OID计算表空间中使用的总磁盘空间。
        要使用这个函数，必须在指定的表空间上拥有<literal>CREATE</literal>特权，或者是<literal>pg_read_all_stats</literal>角色的成员，除非它是当前数据库的默认表空间。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_total_relation_size</primary>
        </indexterm>
        <function>pg_total_relation_size</function> ( <type>regclass</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Computes the total disk space used by the specified table, including
        all indexes and <acronym>TOAST</acronym> data.  The result is
        equivalent to <function>pg_table_size</function>
        <literal>+</literal> <function>pg_indexes_size</function>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_total_relation_size</primary>
        </indexterm>
        <function>pg_total_relation_size</function> ( <type>regclass</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        计算指定表所使用的总磁盘空间，包括所有索引和<acronym>TOAST</acronym>数据。
        结果等价<function>pg_table_size</function> <literal>+</literal> <function>pg_indexes_size</function>。
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    The functions above that operate on tables or indexes accept a
    <type>regclass</type> argument, which is simply the OID of the table or index
    in the <structname>pg_class</structname> system catalog.  You do not have to look up
    the OID by hand, however, since the <type>regclass</type> data type's input
    converter will do the work for you.  Just write the table name enclosed in
    single quotes so that it looks like a literal constant.  For compatibility
    with the handling of ordinary <acronym>SQL</acronym> names, the string
    will be converted to lower case unless it contains double quotes around
    the table name.
   </para>
____________________________________________________________________________-->
   <para>
    上述操作表和索引的函数接受一个<type>regclass</type>参数，它是该表或索引在<structname>pg_class</structname>系统目录中的 OID。你不必手工去查找该 OID，因为<type>regclass</type>数据类型的输入转换器会为你代劳。只写包围在单引号内的表名，这样它看起来像一个文字常量。为了与普通<acronym>SQL</acronym>名称的处理相兼容，该字符串将被转换为小写形式，除非其中在表名周围包含双引号。
   </para>

<!--==========================orignal english content==========================
   <para>
    The functions shown in <xref linkend="functions-admin-dblocation"/> assist
    in identifying the specific disk files associated with database objects.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-admin-dblocation"/>中展示的函数帮助标识数据库对象相关的磁盘文件。
   </para>

   <table id="functions-admin-dblocation">
<!--==========================orignal english content==========================
    <title>Database Object Location Functions</title>
____________________________________________________________________________-->
    <title>数据库对象位置函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_relation_filenode</primary>
        </indexterm>
        <function>pg_relation_filenode</function> ( <parameter>relation</parameter> <type>regclass</type> )
        <returnvalue>oid</returnvalue>
       </para>
       <para>
        Returns the <quote>filenode</quote> number currently assigned to the
        specified relation.  The filenode is the base component of the file
        name(s) used for the relation (see
        <xref linkend="storage-file-layout"/> for more information).
        For most relations the result is the same as
        <structname>pg_class</structname>.<structfield>relfilenode</structfield>,
        but for certain system catalogs <structfield>relfilenode</structfield>
        is zero and this function must be used to get the correct value.  The
        function returns NULL if passed a relation that does not have storage,
        such as a view.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_relation_filenode</primary>
        </indexterm>
        <function>pg_relation_filenode</function> ( <parameter>relation</parameter> <type>regclass</type> )
        <returnvalue>oid</returnvalue>
       </para>
       <para>
        返回当前分配给指定关系的<quote>filenode</quote>数字。文件节点是用于该关系的文件名称的基本组件(更多信息请参阅<xref linkend="storage-file-layout"/> )。
        对于大多数关系，其结果与<structname>pg_class</structname>.<structfield>relfilenode</structfield>相同，但对于某些系统目录，<structfield>relfilenode</structfield>为0，并且必须使用这个函数来获得正确的值。
        如果传递的是一个没有存储的关系，例如一个视图，那么函数将返回NULL。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_relation_filepath</primary>
        </indexterm>
        <function>pg_relation_filepath</function> ( <parameter>relation</parameter> <type>regclass</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the entire file path name (relative to the database cluster's
        data directory, <varname>PGDATA</varname>) of the relation.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_relation_filepath</primary>
        </indexterm>
        <function>pg_relation_filepath</function> ( <parameter>relation</parameter> <type>regclass</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回关系的完整文件路径名称(相对于数据库集群的数据目录，关系的<varname>PGDATA</varname>)。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_filenode_relation</primary>
        </indexterm>
        <function>pg_filenode_relation</function> ( <parameter>tablespace</parameter> <type>oid</type>, <parameter>filenode</parameter> <type>oid</type> )
        <returnvalue>regclass</returnvalue>
       </para>
       <para>
        Returns a relation's OID given the tablespace OID and filenode it is
        stored under.  This is essentially the inverse mapping of
        <function>pg_relation_filepath</function>.  For a relation in the
        database's default tablespace, the tablespace can be specified as zero.
        Returns <literal>NULL</literal> if no relation in the current database
        is associated with the given values.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_filenode_relation</primary>
        </indexterm>
        <function>pg_filenode_relation</function> ( <parameter>tablespace</parameter> <type>oid</type>, <parameter>filenode</parameter> <type>oid</type> )
        <returnvalue>regclass</returnvalue>
       </para>
       <para>
        返回一个给定表空间OID和存储它的文件节点的关系的OID。这本质上是<function>pg_relation_filepath</function>的反向映射。
        对于数据库默认表空间中的关系，表空间可以指定为0。如果当前数据库中没有与给定值相关联的关系，则返回 <literal>NULL</literal>。
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    <xref linkend="functions-admin-collation"/> lists functions used to manage
    collations.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-admin-collation"/> 列出用于管理排序规则的函数。
   </para>

   <table id="functions-admin-collation">
<!--==========================orignal english content==========================
    <title>Collation Management Functions</title>
____________________________________________________________________________-->
    <title>排序规则管理函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_collation_actual_version</primary>
        </indexterm>
        <function>pg_collation_actual_version</function> ( <type>oid</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the actual version of the collation object as it is currently
        installed in the operating system.  If this is different from the
        value in
        <structname>pg_collation</structname>.<structfield>collversion</structfield>,
        then objects depending on the collation might need to be rebuilt.  See
        also <xref linkend="sql-altercollation"/>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_collation_actual_version</primary>
        </indexterm>
        <function>pg_collation_actual_version</function> ( <type>oid</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回当前安装在操作系统中的该排序规则对象的实际版本。
        如果这个版本与<structname>pg_collation</structname>.<structfield>collversion</structfield>中的值不同，则依赖于该排序规则的对象可能需要被重建。
        还可以参考<xref linkend="sql-altercollation"/>。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_import_system_collations</primary>
        </indexterm>
        <function>pg_import_system_collations</function> ( <parameter>schema</parameter> <type>regnamespace</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Adds collations to the system
        catalog <structname>pg_collation</structname> based on all the locales
        it finds in the operating system.  This is
        what <command>initdb</command> uses; see
        <xref linkend="collation-managing"/> for more details.  If additional
        locales are installed into the operating system later on, this
        function can be run again to add collations for the new locales.
        Locales that match existing entries
        in <structname>pg_collation</structname> will be skipped.  (But
        collation objects based on locales that are no longer present in the
        operating system are not removed by this function.)
        The <parameter>schema</parameter> parameter would typically
        be <literal>pg_catalog</literal>, but that is not a requirement; the
        collations could be installed into some other schema as well.  The
        function returns the number of new collation objects it created.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_import_system_collations</primary>
        </indexterm>
        <function>pg_import_system_collations</function> ( <parameter>schema</parameter> <type>regnamespace</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        基于在操作系统中找到的所有区域环境(locales)，加入排序规则到系统目录<literal>pg_collation</literal>中。
        这是 <command>initdb</command> 会用到的的，更多细节请参考<xref linkend="collation-managing"/>。
        如果后来在操作系统上安装了额外的区域环境，可以再次运行这个函数加入新区域环境的排序规则。
        匹配<structname>pg_collation</structname>中现有条目的区域环境将被跳过（但是这个函数不会移除以在操作系统中不再存在的区域环境为基础的排序规则对象）。
        <parameter>schema</parameter>参数通常是<literal>pg_catalog</literal>，但这不是一种要求，排序规则也可以被安装到其他的方案中。
        该函数返回其创建的新排序规则对象的数量。
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    <xref linkend="functions-info-partition"/> lists functions that provide
    information about the structure of partitioned tables.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-info-partition"/> 列出提供有关分区表结构信息的函数。
   </para>

   <table id="functions-info-partition">
<!--==========================orignal english content==========================
    <title>Partitioning Information Functions</title>
____________________________________________________________________________-->
    <title>分区信息函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_partition_tree</primary>
        </indexterm>
        <function>pg_partition_tree</function> ( <type>regclass</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>relid</parameter> <type>regclass</type>,
        <parameter>parentrelid</parameter> <type>regclass</type>,
        <parameter>isleaf</parameter> <type>boolean</type>,
        <parameter>level</parameter> <type>integer</type> )
       </para>
       <para>
        Lists the tables or indexes in the partition tree of the
        given partitioned table or partitioned index, with one row for each
        partition.  Information provided includes the OID of the partition,
        the OID of its immediate parent, a boolean value telling if the
        partition is a leaf, and an integer telling its level in the hierarchy.
        The level value is 0 for the input table or index, 1 for its
        immediate child partitions, 2 for their partitions, and so on.
        Returns no rows if the relation does not exist or is not a partition
        or partitioned table.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_partition_tree</primary>
        </indexterm>
        <function>pg_partition_tree</function> ( <type>regclass</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>relid</parameter> <type>regclass</type>,
        <parameter>parentrelid</parameter> <type>regclass</type>,
        <parameter>isleaf</parameter> <type>boolean</type>,
        <parameter>level</parameter> <type>integer</type> )
       </para>
       <para>
        列出给定分区表或分区索引的分区树中的表或索引，每行对应一个分区。 
        提供的信息包括分区的OID、其直接父的OID、一个布尔值以告知分区是否是叶子，以及一个整数用来告诉分区在层次结构中的级别。
        对于输入表或索引，级别值为0，其直接子分区的为1，它们的分区为2，以此类推。
        如果关系不存在，或者不是分区或分区表，则不返回行。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_partition_ancestors</primary>
        </indexterm>
        <function>pg_partition_ancestors</function> ( <type>regclass</type> )
        <returnvalue>setof regclass</returnvalue>
       </para>
       <para>
        Lists the ancestor relations of the given partition,
        including the relation itself.  Returns no rows if the relation
        does not exist or is not a partition or partitioned table.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_partition_ancestors</primary>
        </indexterm>
        <function>pg_partition_ancestors</function> ( <type>regclass</type> )
        <returnvalue>setof regclass</returnvalue>
       </para>
       <para>
        列出给定分区的祖先关系，包括关系本身。如果关系不存在，或者不是分区或分区表，则不返回行。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_partition_root</primary>
        </indexterm>
        <function>pg_partition_root</function> ( <type>regclass</type> )
        <returnvalue>regclass</returnvalue>
       </para>
       <para>
        Returns the top-most parent of the partition tree to which the given
        relation belongs.  Returns <literal>NULL</literal> if the relation
        does not exist or is not a partition or partitioned table.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_partition_root</primary>
        </indexterm>
        <function>pg_partition_root</function> ( <type>regclass</type> )
        <returnvalue>regclass</returnvalue>
       </para>
       <para>
        返回给定关系所属的分区树的最顶级父节点。如果关系不存在，或者不是分区或分区表，则返回<literal>NULL</literal>。
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    For example, to check the total size of the data contained in a
    partitioned table <structname>measurement</structname>, one could use the
    following query:
<programlisting>
SELECT pg_size_pretty(sum(pg_relation_size(relid))) AS total_size
  FROM pg_partition_tree('measurement');
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    例如，要检查分区表<structname>measurement</structname>中包含的数据的总大小，可以使用以下查询:
<programlisting>
SELECT pg_size_pretty(sum(pg_relation_size(relid))) AS total_size
  FROM pg_partition_tree('measurement');
</programlisting>
   </para>

  </sect2>

  <sect2 id="functions-admin-index">
<!--==========================orignal english content==========================
   <title>Index Maintenance Functions</title>
____________________________________________________________________________-->
   <title>索引维护函数</title>

<!--==========================orignal english content==========================
   <para>
    <xref linkend="functions-admin-index-table"/> shows the functions
    available for index maintenance tasks.  (Note that these maintenance
    tasks are normally done automatically by autovacuum; use of these
    functions is only required in special cases.)
    These functions cannot be executed during recovery.
    Use of these functions is restricted to superusers and the owner
    of the given index.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-admin-index-table"/> 显示了索引维护任务可以使用的函数。
    (注意，这些维护任务通常由自动清理(autovacuum)自动完成;只有在特殊情况下才需要使用这些函数。)
    这些函数在恢复过程中无法执行。这些函数的使用局限于超级用户和给定索引的所有者。
   </para>

   <table id="functions-admin-index-table">
<!--==========================orignal english content==========================
    <title>Index Maintenance Functions</title>
____________________________________________________________________________-->
    <title>索引维护函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>brin_summarize_new_values</primary>
        </indexterm>
        <function>brin_summarize_new_values</function> ( <parameter>index</parameter> <type>regclass</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Scans the specified BRIN index to find page ranges in the base table
        that are not currently summarized by the index; for any such range it
        creates a new summary index tuple by scanning those table pages.
        Returns the number of new page range summaries that were inserted
        into the index.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>brin_summarize_new_values</primary>
        </indexterm>
        <function>brin_summarize_new_values</function> ( <parameter>index</parameter> <type>regclass</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        扫描指定的BRIN索引以查找基表中当前没有被索引归纳的页面范围;
        对于任何这样的范围，它都通过扫描这些表页来创建一个新的摘要索引元组。
        返回插入到索引中的新页面范围摘要的数量。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>brin_summarize_range</primary>
        </indexterm>
        <function>brin_summarize_range</function> ( <parameter>index</parameter> <type>regclass</type>, <parameter>blockNumber</parameter> <type>bigint</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Summarizes the page range covering the given block, if not already
        summarized.  This is
        like <function>brin_summarize_new_values</function> except that it
        only processes the page range that covers the given table block number.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>brin_summarize_range</primary>
        </indexterm>
        <function>brin_summarize_range</function> ( <parameter>index</parameter> <type>regclass</type>, <parameter>blockNumber</parameter> <type>bigint</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        归纳(Summarizes)覆盖给定块的页面范围(如果还没有归纳的话)。
        这类似于<function>brin_summarize_new_values</function>，只是它只处理覆盖给定表块数的页范围。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>brin_desummarize_range</primary>
        </indexterm>
        <function>brin_desummarize_range</function> ( <parameter>index</parameter> <type>regclass</type>, <parameter>blockNumber</parameter> <type>bigint</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Removes the BRIN index tuple that summarizes the page range covering
        the given table block, if there is one.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>brin_desummarize_range</primary>
        </indexterm>
        <function>brin_desummarize_range</function> ( <parameter>index</parameter> <type>regclass</type>, <parameter>blockNumber</parameter> <type>bigint</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        删除归纳了覆盖给定表块的页面范围的BRIN索引元组，如果有的话。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>gin_clean_pending_list</primary>
        </indexterm>
        <function>gin_clean_pending_list</function> ( <parameter>index</parameter> <type>regclass</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Cleans up the <quote>pending</quote> list of the specified GIN index
        by moving entries in it, in bulk, to the main GIN data structure.
        Returns the number of pages removed from the pending list.
        If the argument is a GIN index built with
        the <literal>fastupdate</literal> option disabled, no cleanup happens
        and the result is zero, because the index doesn't have a pending list.
        See <xref linkend="gin-fast-update"/> and <xref linkend="gin-tips"/>
        for details about the pending list and <literal>fastupdate</literal>
        option.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>gin_clean_pending_list</primary>
        </indexterm>
        <function>gin_clean_pending_list</function> ( <parameter>index</parameter> <type>regclass</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        清理指定GIN索引的<quote>pending</quote>列表，通过移除里面的条目，以大批的方式，到主要的GIN数据结构。
        返回从挂起列表中删除的页数。如果参数是使用禁用<literal>fastupdate</literal>选项构建的GIN索引，则不会发生清理，结果为零，因为索引没有挂起的列表。
        关于挂起列表和<literal>fastupdate</literal>选项的详细信息，请参见<xref linkend="gin-fast-update"/> 和 <xref linkend="gin-tips"/>。
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  </sect2>

  <sect2 id="functions-admin-genfile">
<!--==========================orignal english content==========================
   <title>Generic File Access Functions</title>
____________________________________________________________________________-->
   <title>通用文件访问函数</title>

<!--==========================orignal english content==========================
   <para>
    The functions shown in <xref
    linkend="functions-admin-genfile-table"/> provide native access to
    files on the machine hosting the server. Only files within the
    database cluster directory and the <varname>log_directory</varname> can be
    accessed, unless the user is a superuser or is granted the role
    <literal>pg_read_server_files</literal>.  Use a relative path for files in
    the cluster directory, and a path matching the <varname>log_directory</varname>
    configuration setting for log files.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-admin-genfile-table"/>中展示的函数提供了对数据库服务器所在机器上的文件的本地访问。
    只能访问数据库集簇目录以及<varname>log_directory</varname>中的文件，除非用户是超级用户或者被授予了角色<literal>pg_read_server_files</literal>。 
    使用相对路径访问集簇目录里面的文件，以及匹配 <varname>log_directory</varname>配置设置的路径访问日志文件。
   </para>

<!--==========================orignal english content==========================
   <para>
    Note that granting users the EXECUTE privilege on
    <function>pg_read_file()</function>, or related functions, allows them the
    ability to read any file on the server that the database server process can
    read; these functions bypass all in-database privilege checks.  This means
    that, for example, a user with such access is able to read the contents of
    the <structname>pg_authid</structname> table where authentication
    information is stored, as well as read any table data in the database.
    Therefore, granting access to these functions should be carefully
    considered.
   </para>
____________________________________________________________________________-->
   <para>
    注意在<function>pg_read_file()</function>或者相关函数上，向用户授予EXECUTE特权，
    以允许他们有能力读取服务器上该数据库服务器进程能读取的任何文件；这些函数会绕过所有的数据库内特权检查。
    这意味着，例如，具有这种访问的用户能够读取<structname>pg_authid</structname>表中存储着认证信息的内容，也能读取数据库中的任何表数据。
    因此，授予对这些函数的访问应该要很仔细地考虑。
   </para>

<!--==========================orignal english content==========================
   <para>
    Some of these functions take an optional <parameter>missing_ok</parameter>
    parameter, which specifies the behavior when the file or directory does
    not exist.  If <literal>true</literal>, the function
    returns <literal>NULL</literal> or an empty result set, as appropriate.
    If <literal>false</literal>, an error is raised.  The default
    is <literal>false</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    这些函数中的一些函数有可选的<parameter>missing_ok</parameter>参数，可以指定当文件或目录不存在时的行为。
    如果为<literal>true</literal>，函数返回<literal>NULL</literal>或着空结果集，根据适合情况。
    如果为<literal>false</literal>，会产生一个错误。默认为<literal>false</literal>。
   </para>

   <table id="functions-admin-genfile-table">
<!--==========================orignal english content==========================
    <title>Generic File Access Functions</title>
____________________________________________________________________________-->
    <title>通用文件访问函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_ls_dir</primary>
        </indexterm>
        <function>pg_ls_dir</function> ( <parameter>dirname</parameter> <type>text</type> <optional>, <parameter>missing_ok</parameter> <type>boolean</type>, <parameter>include_dot_dirs</parameter> <type>boolean</type> </optional> )
        <returnvalue>setof text</returnvalue>
       </para>
       <para>
        Returns the names of all files (and directories and other special
        files) in the specified
        directory. The <parameter>include_dot_dirs</parameter> parameter
        indicates whether <quote>.</quote> and <quote>..</quote> are to be
        included in the result set; the default is to exclude them.  Including
        them can be useful when <parameter>missing_ok</parameter>
        is <literal>true</literal>, to distinguish an empty directory from a
        non-existent directory.
       </para>
       <para>
        This function is restricted to superusers by default, but other users
        can be granted EXECUTE to run the function.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_ls_dir</primary>
        </indexterm>
        <function>pg_ls_dir</function> ( <parameter>dirname</parameter> <type>text</type> <optional>, <parameter>missing_ok</parameter> <type>boolean</type>, <parameter>include_dot_dirs</parameter> <type>boolean</type> </optional> )
        <returnvalue>setof text</returnvalue>
       </para>
       <para>
        返回指定目录总所有文件(和目录以及其他指定文件)的名称。
        <parameter>include_dot_dirs</parameter>参数标示在结果集中是否包括<quote>.</quote> 和 <quote>..</quote>；默认为不包括它们。
        要包括它们在<parameter>missing_ok</parameter>为 <literal>true</literal>时能够有用，以从不存在的目录中辨别一个空目录。
       </para>
       <para>
        这个函数默认限制为超级用户，但是其他用户可以被授予EXECUTE以运行此函数。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_ls_logdir</primary>
        </indexterm>
        <function>pg_ls_logdir</function> ()
        <returnvalue>setof record</returnvalue>
        ( <parameter>name</parameter> <type>text</type>,
        <parameter>size</parameter> <type>bigint</type>,
        <parameter>modification</parameter> <type>timestamp with time zone</type> )
       </para>
       <para>
        Returns the name, size, and last modification time (mtime) of each
        ordinary file in the server's log directory.  Filenames beginning with
        a dot, directories, and other special files are excluded.
       </para>
       <para>
        This function is restricted to superusers and members of
        the <literal>pg_monitor</literal> role by default, but other users can
        be granted EXECUTE to run the function.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_ls_logdir</primary>
        </indexterm>
        <function>pg_ls_logdir</function> ()
        <returnvalue>setof record</returnvalue>
        ( <parameter>name</parameter> <type>text</type>,
        <parameter>size</parameter> <type>bigint</type>,
        <parameter>modification</parameter> <type>timestamp with time zone</type> )
       </para>
       <para>
        返回服务器的日志目录中的每个普通文件的名称、大小、和最后修改时间(mtime)。
        文件名以一个点(dot)开始，目录和其他指定的文件不包括。
       </para>
       <para>
        这个函数默认限制在超级用户和<literal>pg_monitor</literal>角色的成员，但是其他用户可以被授予EXECUTE以运行此函数。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_ls_waldir</primary>
        </indexterm>
        <function>pg_ls_waldir</function> ()
        <returnvalue>setof record</returnvalue>
        ( <parameter>name</parameter> <type>text</type>,
        <parameter>size</parameter> <type>bigint</type>,
        <parameter>modification</parameter> <type>timestamp with time zone</type> )
       </para>
       <para>
        Returns the name, size, and last modification time (mtime) of each
        ordinary file in the server's write-ahead log (WAL) directory.
        Filenames beginning with a dot, directories, and other special files
        are excluded.
       </para>
       <para>
        This function is restricted to superusers and members of
        the <literal>pg_monitor</literal> role by default, but other users can
        be granted EXECUTE to run the function.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_ls_waldir</primary>
        </indexterm>
        <function>pg_ls_waldir</function> ()
        <returnvalue>setof record</returnvalue>
        ( <parameter>name</parameter> <type>text</type>,
        <parameter>size</parameter> <type>bigint</type>,
        <parameter>modification</parameter> <type>timestamp with time zone</type> )
       </para>
       <para>
        返回服务器的预写式日志(WAL)目录中的每个普通文件的名称、大小、和最后修改时间(mtime)。
        文件名以一个点(dot)开始，目录和其他指定的文件不包括。
       </para>
       <para>
        这个函数默认限制在超级用户和<literal>pg_monitor</literal>角色的成员，但是其他用户可以被授予EXECUTE以运行此函数。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_ls_archive_statusdir</primary>
        </indexterm>
        <function>pg_ls_archive_statusdir</function> ()
        <returnvalue>setof record</returnvalue>
        ( <parameter>name</parameter> <type>text</type>,
        <parameter>size</parameter> <type>bigint</type>,
        <parameter>modification</parameter> <type>timestamp with time zone</type> )
       </para>
       <para>
        Returns the name, size, and last modification time (mtime) of each
        ordinary file in the server's WAL archive status directory
        (<filename>pg_wal/archive_status</filename>).  Filenames beginning
        with a dot, directories, and other special files are excluded.
       </para>
       <para>
        This function is restricted to superusers and members of
        the <literal>pg_monitor</literal> role by default, but other users can
        be granted EXECUTE to run the function.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_ls_archive_statusdir</primary>
        </indexterm>
        <function>pg_ls_archive_statusdir</function> ()
        <returnvalue>setof record</returnvalue>
        ( <parameter>name</parameter> <type>text</type>,
        <parameter>size</parameter> <type>bigint</type>,
        <parameter>modification</parameter> <type>timestamp with time zone</type> )
       </para>
       <para>
        返回服务器的WAL归档状态目录(<filename>pg_wal/archive_status</filename>)中的每个普通文件的名称、大小、和最后修改时间(mtime)。
        文件名以一个点(dot)开始，目录和其他指定的文件不包括。
       </para>
       <para>
        这个函数默认限制在超级用户和<literal>pg_monitor</literal>角色的成员，但是其他用户可以被授予EXECUTE以运行此函数。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">

        <indexterm>
         <primary>pg_ls_tmpdir</primary>
        </indexterm>
        <function>pg_ls_tmpdir</function> ( <optional> <parameter>tablespace</parameter> <type>oid</type> </optional> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>name</parameter> <type>text</type>,
        <parameter>size</parameter> <type>bigint</type>,
        <parameter>modification</parameter> <type>timestamp with time zone</type> )
       </para>
       <para>
        Returns the name, size, and last modification time (mtime) of each
        ordinary file in the temporary file directory for the
        specified <parameter>tablespace</parameter>.
        If <parameter>tablespace</parameter> is not provided,
        the <literal>pg_default</literal> tablespace is examined.  Filenames
        beginning with a dot, directories, and other special files are
        excluded.
       </para>
       <para>
        This function is restricted to superusers and members of
        the <literal>pg_monitor</literal> role by default, but other users can
        be granted EXECUTE to run the function.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">

        <indexterm>
         <primary>pg_ls_tmpdir</primary>
        </indexterm>
        <function>pg_ls_tmpdir</function> ( <optional> <parameter>tablespace</parameter> <type>oid</type> </optional> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>name</parameter> <type>text</type>,
        <parameter>size</parameter> <type>bigint</type>,
        <parameter>modification</parameter> <type>timestamp with time zone</type> )
       </para>
       <para>
        返回针对指定<parameter>tablespace</parameter>的临时文件目录中的每个普通文件的名称、大小、和最后修改时间(mtime)。
        如果<parameter>tablespace</parameter>没有提供，<literal>pg_default</literal> 表空间为被检验的。
        文件名以一个点(dot)开始，目录和其他指定的文件不包括。
       </para>
       <para>
        这个函数默认限制在超级用户和<literal>pg_monitor</literal>角色的成员，但是其他用户可以被授予EXECUTE以运行此函数。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_read_file</primary>
        </indexterm>
        <function>pg_read_file</function> ( <parameter>filename</parameter> <type>text</type> <optional>, <parameter>offset</parameter> <type>bigint</type>, <parameter>length</parameter> <type>bigint</type> <optional>, <parameter>missing_ok</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns all or part of a text file, starting at the
        given byte <parameter>offset</parameter>, returning at
        most <parameter>length</parameter> bytes (less if the end of file is
        reached first).  If <parameter>offset</parameter> is negative, it is
        relative to the end of the file.  If <parameter>offset</parameter>
        and <parameter>length</parameter> are omitted, the entire file is
        returned.  The bytes read from the file are interpreted as a string in
        the database's encoding; an error is thrown if they are not valid in
        that encoding.
       </para>
       <para>
        This function is restricted to superusers by default, but other users
        can be granted EXECUTE to run the function.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_read_file</primary>
        </indexterm>
        <function>pg_read_file</function> ( <parameter>filename</parameter> <type>text</type> <optional>, <parameter>offset</parameter> <type>bigint</type>, <parameter>length</parameter> <type>bigint</type> <optional>, <parameter>missing_ok</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回一个文本文件的全部或部分，开始于给定的字节<parameter>offset</parameter>，在最大的<parameter>length</parameter>字节返回（如果文件的结尾先达到了则减少）。
        如果<parameter>offset</parameter>为负，他于文件的结尾有关。如果<parameter>offset</parameter>和<parameter>length</parameter> 被省略，整个文件被返回。
        从文件中读的字节在服务器的编码中解释为字符串；如果它们在哪些编码中不是有效的则抛出错误。
       </para>
       <para>
        这个函数默认限制在超级用户，但是其他用户可以被授予EXECUTE以运行此函数。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_read_binary_file</primary>
        </indexterm>
        <function>pg_read_binary_file</function> ( <parameter>filename</parameter> <type>text</type> <optional>, <parameter>offset</parameter> <type>bigint</type>, <parameter>length</parameter> <type>bigint</type> <optional>, <parameter>missing_ok</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        Returns all or part of a file.  This function is identical to
        <function>pg_read_file</function> except that it can read arbitrary
        binary data, returning the result as <type>bytea</type>
        not <type>text</type>; accordingly, no encoding checks are performed.
       </para>
       <para>
        This function is restricted to superusers by default, but other users
        can be granted EXECUTE to run the function.
       </para>
       <para>
        In combination with the <function>convert_from</function> function,
        this function can be used to read a text file in a specified encoding
        and convert to the database's encoding:
<programlisting>
SELECT convert_from(pg_read_binary_file('file_in_utf8.txt'), 'UTF8');
</programlisting>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_read_binary_file</primary>
        </indexterm>
        <function>pg_read_binary_file</function> ( <parameter>filename</parameter> <type>text</type> <optional>, <parameter>offset</parameter> <type>bigint</type>, <parameter>length</parameter> <type>bigint</type> <optional>, <parameter>missing_ok</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        返回文件的全部或部分。这个函数与<function>pg_read_file</function> 是完全相同的，除了它可以读任意的二进制数据，返回结果为<type>bytea</type>而不是<type>text</type>；
        因此，没有编码检查会被执行。
       </para>
       <para>
        这个函数默认限制在超级用户，但是其他用户可以被授予EXECUTE以运行此函数。
       </para>
       <para>
        与 <function>convert_from</function>函数组合，这个函数能被用于以指定的编码读文本文件并转换到数据库的编码：
<programlisting>
SELECT convert_from(pg_read_binary_file('file_in_utf8.txt'), 'UTF8');
</programlisting>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_file</primary>
        </indexterm>
        <function>pg_stat_file</function> ( <parameter>filename</parameter> <type>text</type> <optional>, <parameter>missing_ok</parameter> <type>boolean</type> </optional> )
        <returnvalue>record</returnvalue>
        ( <parameter>size</parameter> <type>bigint</type>,
        <parameter>access</parameter> <type>timestamp with time zone</type>,
        <parameter>modification</parameter> <type>timestamp with time zone</type>,
        <parameter>change</parameter> <type>timestamp with time zone</type>,
        <parameter>creation</parameter> <type>timestamp with time zone</type>,
        <parameter>isdir</parameter> <type>boolean</type> )
       </para>
       <para>
        Returns a record containing the file's size, last access time stamp,
        last modification time stamp, last file status change time stamp (Unix
        platforms only), file creation time stamp (Windows only), and a flag
        indicating if it is a directory.
       </para>
       <para>
        This function is restricted to superusers by default, but other users
        can be granted EXECUTE to run the function.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_file</primary>
        </indexterm>
        <function>pg_stat_file</function> ( <parameter>filename</parameter> <type>text</type> <optional>, <parameter>missing_ok</parameter> <type>boolean</type> </optional> )
        <returnvalue>record</returnvalue>
        ( <parameter>size</parameter> <type>bigint</type>,
        <parameter>access</parameter> <type>timestamp with time zone</type>,
        <parameter>modification</parameter> <type>timestamp with time zone</type>,
        <parameter>change</parameter> <type>timestamp with time zone</type>,
        <parameter>creation</parameter> <type>timestamp with time zone</type>,
        <parameter>isdir</parameter> <type>boolean</type> )
       </para>
       <para>
        返回一个记录，包含文件的大小、最后访问时间戳、最后修改时间戳，最后文件状态变更时间戳(仅在UNIX平台)、文件建立时间戳(仅Windows)，和一个标志旗如果它是一个目录。
       </para>
       <para>
        这个函数默认限制在超级用户，但是其他用户可以被授予EXECUTE以运行此函数。
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  </sect2>

  <sect2 id="functions-advisory-locks">
<!--==========================orignal english content==========================
   <title>Advisory Lock Functions</title>
____________________________________________________________________________-->
   <title>咨询锁函数</title>

<!--==========================orignal english content==========================
   <para>
    The functions shown in <xref linkend="functions-advisory-locks-table"/>
    manage advisory locks.  For details about proper use of these functions,
    see <xref linkend="advisory-locks"/>.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-advisory-locks-table"/>中展示的函数管理咨询锁。
    有关正确使用这些函数的细节请参考<xref linkend="advisory-locks"/>。
   </para>

<!--==========================orignal english content==========================
   <para>
    All these functions are intended to be used to lock application-defined
    resources, which can be identified either by a single 64-bit key value or
    two 32-bit key values (note that these two key spaces do not overlap).
    If another session already holds a conflicting lock on the same resource
    identifier, the functions will either wait until the resource becomes
    available, or return a <literal>false</literal> result, as appropriate for
    the function.
    Locks can be either shared or exclusive: a shared lock does not conflict
    with other shared locks on the same resource, only with exclusive locks.
    Locks can be taken at session level (so that they are held until released
    or the session ends) or at transaction level (so that they are held until
    the current transaction ends; there is no provision for manual release).
    Multiple session-level lock requests stack, so that if the same resource
    identifier is locked three times there must then be three unlock requests
    to release the resource in advance of session end.
   </para>
____________________________________________________________________________-->
   <para>
    所有这些函数都打算用于锁定应用程序定义的资源，可以通过一个64位键值或两个32位键值来标识(注意这两个键空间不能重叠)。
    如果另一个会话已经在相同的资源标识符上持有一个冲突的锁，函数将等待直到资源变成可用，或者返回一个<literal>false</literal>结果，合适于函数的。
    锁可以是共享或排他的:共享锁不会与同一资源上的其他共享锁发生冲突，只会与排他锁发生冲突。
    锁可以在会话级(这样它们被保持直到释放或会话结束)或在事务级(这样它们被保持直到当前事务结束;没有手动释放的供应)。
    多个会话级锁请求堆栈，因此如果同一个资源标识符被锁定三次，那么必须有三个解锁请求来释放资源，在会话结束之前。
   </para>

   <table id="functions-advisory-locks-table">
<!--==========================orignal english content==========================
    <title>Advisory Lock Functions</title>
____________________________________________________________________________-->
    <title>咨询锁函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_advisory_lock</primary>
        </indexterm>
        <function>pg_advisory_lock</function> ( <parameter>key</parameter> <type>bigint</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_advisory_lock</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Obtains an exclusive session-level advisory lock, waiting if necessary.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_advisory_lock</primary>
        </indexterm>
        <function>pg_advisory_lock</function> ( <parameter>key</parameter> <type>bigint</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_advisory_lock</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        获取一个排他的会话级咨询锁，如有必要则等待。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_advisory_lock_shared</primary>
        </indexterm>
        <function>pg_advisory_lock_shared</function> ( <parameter>key</parameter> <type>bigint</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_advisory_lock_shared</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Obtains a shared session-level advisory lock, waiting if necessary.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_advisory_lock_shared</primary>
        </indexterm>
        <function>pg_advisory_lock_shared</function> ( <parameter>key</parameter> <type>bigint</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_advisory_lock_shared</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        获取一个共享的会话级咨询锁，如有必要则等待。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_advisory_unlock</primary>
        </indexterm>
        <function>pg_advisory_unlock</function> ( <parameter>key</parameter> <type>bigint</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_advisory_unlock</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Releases a previously-acquired exclusive session-level advisory lock.
        Returns <literal>true</literal> if the lock is successfully released.
        If the lock was not held, <literal>false</literal> is returned, and in
        addition, an SQL warning will be reported by the server.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_advisory_unlock</primary>
        </indexterm>
        <function>pg_advisory_unlock</function> ( <parameter>key</parameter> <type>bigint</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_advisory_unlock</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        释放以前获取的排他会话级咨询锁。如果锁成功释放则返回<literal>true</literal>。
        如果锁没有被持有，则返回<literal>false</literal>，此外，服务器将报告一个SQL警告。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_advisory_unlock_all</primary>
        </indexterm>
        <function>pg_advisory_unlock_all</function> ()
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Releases all session-level advisory locks held by the current session.
        (This function is implicitly invoked at session end, even if the
        client disconnects ungracefully.)
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_advisory_unlock_all</primary>
        </indexterm>
        <function>pg_advisory_unlock_all</function> ()
        <returnvalue>void</returnvalue>
       </para>
       <para>
        释放当前会话所持有的所有会话级咨询锁。(即使客户端异常断开连接，这个函数也会在会话结束时被隐式调用。)
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_advisory_unlock_shared</primary>
        </indexterm>
        <function>pg_advisory_unlock_shared</function> ( <parameter>key</parameter> <type>bigint</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_advisory_unlock_shared</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Releases a previously-acquired shared session-level advisory lock.
        Returns <literal>true</literal> if the lock is successfully released.
        If the lock was not held, <literal>false</literal> is returned, and in
        addition, an SQL warning will be reported by the server.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_advisory_unlock_shared</primary>
        </indexterm>
        <function>pg_advisory_unlock_shared</function> ( <parameter>key</parameter> <type>bigint</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_advisory_unlock_shared</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        释放以前获取的共享会话级咨询锁。如果锁成功释放则返回<literal>true</literal>。
        如果锁没有被持有，则返回<literal>false</literal>，此外，服务器将报告一个SQL警告。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_advisory_xact_lock</primary>
        </indexterm>
        <function>pg_advisory_xact_lock</function> ( <parameter>key</parameter> <type>bigint</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_advisory_xact_lock</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Obtains an exclusive transaction-level advisory lock, waiting if
        necessary.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_advisory_xact_lock</primary>
        </indexterm>
        <function>pg_advisory_xact_lock</function> ( <parameter>key</parameter> <type>bigint</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_advisory_xact_lock</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        获取一个排他的事务级咨询锁，如有必要则等待。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_advisory_xact_lock_shared</primary>
        </indexterm>
        <function>pg_advisory_xact_lock_shared</function> ( <parameter>key</parameter> <type>bigint</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_advisory_xact_lock_shared</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Obtains a shared transaction-level advisory lock, waiting if
        necessary.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_advisory_xact_lock_shared</primary>
        </indexterm>
        <function>pg_advisory_xact_lock_shared</function> ( <parameter>key</parameter> <type>bigint</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_advisory_xact_lock_shared</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        获取一个共享的事务级咨询锁，如有必要则等待。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_try_advisory_lock</primary>
        </indexterm>
        <function>pg_try_advisory_lock</function> ( <parameter>key</parameter> <type>bigint</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_try_advisory_lock</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Obtains an exclusive session-level advisory lock if available.
        This will either obtain the lock immediately and
        return <literal>true</literal>, or return <literal>false</literal>
        without waiting if the lock cannot be acquired immediately.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_try_advisory_lock</primary>
        </indexterm>
        <function>pg_try_advisory_lock</function> ( <parameter>key</parameter> <type>bigint</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_try_advisory_lock</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        获取一个排他的会话级咨询锁，如果适用。
        这将立即获得锁并返回<literal>true</literal>，或者如果不能立即获取锁则立即返回 <literal>false</literal>而无需等待。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_try_advisory_lock_shared</primary>
        </indexterm>
        <function>pg_try_advisory_lock_shared</function> ( <parameter>key</parameter> <type>bigint</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_try_advisory_lock_shared</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Obtains a shared session-level advisory lock if available.
        This will either obtain the lock immediately and
        return <literal>true</literal>, or return <literal>false</literal>
        without waiting if the lock cannot be acquired immediately.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_try_advisory_lock_shared</primary>
        </indexterm>
        <function>pg_try_advisory_lock_shared</function> ( <parameter>key</parameter> <type>bigint</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_try_advisory_lock_shared</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        获取一个共享的会话级咨询锁，如果适用。
        这将立即获得锁并返回<literal>true</literal>，或者如果不能立即获取锁则立即返回 <literal>false</literal>而无需等待。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_try_advisory_xact_lock</primary>
        </indexterm>
        <function>pg_try_advisory_xact_lock</function> ( <parameter>key</parameter> <type>bigint</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_try_advisory_xact_lock</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Obtains an exclusive transaction-level advisory lock if available.
        This will either obtain the lock immediately and
        return <literal>true</literal>, or return <literal>false</literal>
        without waiting if the lock cannot be acquired immediately.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_try_advisory_xact_lock</primary>
        </indexterm>
        <function>pg_try_advisory_xact_lock</function> ( <parameter>key</parameter> <type>bigint</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_try_advisory_xact_lock</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        获取一个排他的事务级咨询锁，如果适用。
        这将立即获得锁并返回<literal>true</literal>，或者如果不能立即获取锁则立即返回 <literal>false</literal>而无需等待。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_try_advisory_xact_lock_shared</primary>
        </indexterm>
        <function>pg_try_advisory_xact_lock_shared</function> ( <parameter>key</parameter> <type>bigint</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_try_advisory_xact_lock_shared</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Obtains a shared transaction-level advisory lock if available.
        This will either obtain the lock immediately and
        return <literal>true</literal>, or return <literal>false</literal>
        without waiting if the lock cannot be acquired immediately.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_try_advisory_xact_lock_shared</primary>
        </indexterm>
        <function>pg_try_advisory_xact_lock_shared</function> ( <parameter>key</parameter> <type>bigint</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <function>pg_try_advisory_xact_lock_shared</function> ( <parameter>key1</parameter> <type>integer</type>, <parameter>key2</parameter> <type>integer</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        获取一个共享的事务级咨询锁，如果适用。
        这将立即获得锁并返回<literal>true</literal>，或者如果不能立即获取锁则立即返回 <literal>false</literal>而无需等待。
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  </sect2>

  </sect1>

  <sect1 id="functions-trigger">
<!--==========================orignal english content==========================
   <title>Trigger Functions</title>
____________________________________________________________________________-->
   <title>触发器函数</title>

<!--==========================orignal english content==========================
  <para>
   While many uses of triggers involve user-written trigger functions,
   <productname>PostgreSQL</productname> provides a few built-in trigger
   functions that can be used directly in user-defined triggers.  These
   are summarized in <xref linkend="builtin-triggers-table"/>.
   (Additional built-in trigger functions exist, which implement foreign
   key constraints and deferred index constraints.  Those are not documented
   here since users need not use them directly.)
  </para>
____________________________________________________________________________-->
  <para>
   虽然很多触发器的使用都涉及到用户编写的触发器函数，但<productname>PostgreSQL</productname>提供了一些可以直接在用户定义触发器中使用的内置触发器函数。
   这些总结在了<xref linkend="builtin-triggers-table"/>中。
   (另外还有一些内置的触发器函数存在，它们实现了外键约束和延期索引约束。因为用户不需要直接使用它们，所以这里就不做论述了。)
  </para>

<!--==========================orignal english content==========================
  <para>
   For more information about creating triggers, see
   <xref linkend="sql-createtrigger"/>.
  </para>
____________________________________________________________________________-->
  <para>
   有关创建触发器的更多信息，请参考<xref linkend="sql-createtrigger"/>。
  </para>

   <table id="builtin-triggers-table">
<!--==========================orignal english content==========================
    <title>Built-In Trigger Functions</title>
____________________________________________________________________________-->
    <title>内置触发器函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example Usage
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        Example Usage
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
       <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>suppress_redundant_updates_trigger</primary>
        </indexterm>
        <function>suppress_redundant_updates_trigger</function> ( )
        <returnvalue>trigger</returnvalue>
       </para>
       <para>
        Suppresses do-nothing update operations.  See below for details.
       </para>
       <para>
        <literal>CREATE TRIGGER ... suppress_redundant_updates_trigger()</literal>
       </para></entry>
      </row>
____________________________________________________________________________-->
       <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>suppress_redundant_updates_trigger</primary>
        </indexterm>
        <function>suppress_redundant_updates_trigger</function> ( )
        <returnvalue>trigger</returnvalue>
       </para>
       <para>
        阻止不做事的更新操作。详见下文。
       </para>
       <para>
        <literal>CREATE TRIGGER ... suppress_redundant_updates_trigger()</literal>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>tsvector_update_trigger</primary>
        </indexterm>
        <function>tsvector_update_trigger</function> ( )
        <returnvalue>trigger</returnvalue>
       </para>
       <para>
        Automatically updates a <type>tsvector</type> column from associated
        plain-text document column(s).  The text search configuration to use
        is specified by name as a trigger argument.  See
        <xref linkend="textsearch-update-triggers"/> for details.
       </para>
       <para>
        <literal>CREATE TRIGGER ... tsvector_update_trigger(tsvcol, 'pg_catalog.swedish', title, body)</literal>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>tsvector_update_trigger</primary>
        </indexterm>
        <function>tsvector_update_trigger</function> ( )
        <returnvalue>trigger</returnvalue>
       </para>
       <para>
        自动从相关的纯文本文档列更新<type>tsvector</type>列。
        要使用的文本搜索配置是以名称指定为触发器参数。详情请参见<xref linkend="textsearch-update-triggers"/>。
       </para>
       <para>
        <literal>CREATE TRIGGER ... tsvector_update_trigger(tsvcol, 'pg_catalog.swedish', title, body)</literal>
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>tsvector_update_trigger_column</primary>
        </indexterm>
        <function>tsvector_update_trigger_column</function> ( )
        <returnvalue>trigger</returnvalue>
       </para>
       <para>
        Automatically updates a <type>tsvector</type> column from associated
        plain-text document column(s).  The text search configuration to use
        is taken from a <type>regconfig</type> column of the table.  See
        <xref linkend="textsearch-update-triggers"/> for details.
       </para>
       <para>
        <literal>CREATE TRIGGER ... tsvector_update_trigger_column(tsvcol, tsconfigcol, title, body)</literal>
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>tsvector_update_trigger_column</primary>
        </indexterm>
        <function>tsvector_update_trigger_column</function> ( )
        <returnvalue>trigger</returnvalue>
       </para>
       <para>
        自动从相关的纯文本文档列更新<type>tsvector</type>列。
        要使用的文本搜索配置取自表的<type>regconfig</type>列。详情请参见<xref linkend="textsearch-update-triggers"/>。        
       </para>
       <para>
        <literal>CREATE TRIGGER ... tsvector_update_trigger_column(tsvcol, tsconfigcol, title, body)</literal>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
      The <function>suppress_redundant_updates_trigger</function> function,
      when applied as a row-level <literal>BEFORE UPDATE</literal> trigger,
      will prevent any update that does not actually change the data in the
      row from taking place.  This overrides the normal behavior which always
      performs a physical row update
      regardless of whether or not the data has changed. (This normal behavior
      makes updates run faster, since no checking is required, and is also
      useful in certain cases.)
    </para>
____________________________________________________________________________-->
   <para>
      <function>suppress_redundant_updates_trigger</function>函数，在作为行级<literal>BEFORE UPDATE</literal>触发器应用时，将阻止任何没有实际更改行中数据的更新发生。
      这会覆盖那种始终执行物理行更新而无论数据是否已更改的常规行为。
      (这种常规的行为使更新运行得更快，因为不需要检查，而且在某些情况下也很有用。)
    </para>

<!--==========================orignal english content==========================
    <para>
      Ideally, you should avoid running updates that don't actually
      change the data in the record. Redundant updates can cost considerable
      unnecessary time, especially if there are lots of indexes to alter,
      and space in dead rows that will eventually have to be vacuumed.
      However, detecting such situations in client code is not
      always easy, or even possible, and writing expressions to detect
      them can be error-prone. An alternative is to use
      <function>suppress_redundant_updates_trigger</function>, which will skip
      updates that don't change the data. You should use this with care,
      however. The trigger takes a small but non-trivial time for each record,
      so if most of the records affected by updates do actually change,
      use of this trigger will make updates run slower on average.
    </para>
____________________________________________________________________________-->
    <para>
      理想的情况下，你应该避免运行实际上并没有改变记录中数据的更新。 
      冗余更新会花费大量不必要的时间，尤其是如果有大量索引要改变， 并将最终不得不清理被死亡行占用的空间。
      但是，在客户端代码中检测这种情况并不总是容易的，甚至不可能做到。 而写表达式来检测它们容易产生错误。
      作为替代，使用<function>suppress_redundant_updates_trigger</function>可以跳过不改变数据的更新。 但是，你需要小心使用它。
      触发器需要很短但不能忽略的时间来处理每条记录，所以如果受更新影响的大多数记录确实变化了，此触发器的使用将使更新比平均水平运行得更慢。
    </para>

<!--==========================orignal english content==========================
    <para>
      The <function>suppress_redundant_updates_trigger</function> function can be
      added to a table like this:
<programlisting>
CREATE TRIGGER z_min_update
BEFORE UPDATE ON tablename
FOR EACH ROW EXECUTE FUNCTION suppress_redundant_updates_trigger();
</programlisting>
      In most cases, you need to fire this trigger last for each row, so that
      it does not override other triggers that might wish to alter the row.
      Bearing in mind that triggers fire in name order, you would therefore
      choose a trigger name that comes after the name of any other trigger
      you might have on the table.  (Hence the <quote>z</quote> prefix in the
      example.)
    </para>
____________________________________________________________________________-->
    <para>
      <function>suppress_redundant_updates_trigger</function>函数可以像这样添加到表中:
<programlisting>
CREATE TRIGGER z_min_update
BEFORE UPDATE ON tablename
FOR EACH ROW EXECUTE FUNCTION suppress_redundant_updates_trigger();
</programlisting>
      在大多数情况下，你需要为每一行最后触发这个触发器，这样它就不会覆盖可能希望更改该行的其他触发器。
      请记住，触发器是按照名称顺序触发的，你将为此选择一个触发器名称，该名称位于表中可能存在的任何其他触发器的名称之后。
      (因此在示例中使用了<quote>z</quote>前缀。)
    </para>
  </sect1>

  <sect1 id="functions-event-triggers">
<!--==========================orignal english content==========================
   <title>Event Trigger Functions</title>
____________________________________________________________________________-->
   <title>事件触发器函数</title>

<!--==========================orignal english content==========================
   <para>
    <productname>PostgreSQL</productname> provides these helper functions
    to retrieve information from event triggers.
   </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>提供了这些助手函数来从
    事件触发器检索信息。
   </para>

<!--==========================orignal english content==========================
   <para>
    For more information about event triggers,
    see <xref linkend="event-triggers"/>.
   </para>
____________________________________________________________________________-->
   <para>
    更多有关事件触发器的信息请见<xref linkend="event-triggers"/>。
   </para>

  <sect2 id="pg-event-trigger-ddl-command-end-functions">
<!--==========================orignal english content==========================
   <title>Capturing Changes at Command End</title>
____________________________________________________________________________-->
   <title>在命令结束处捕捉更改</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_event_trigger_ddl_commands</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_event_trigger_ddl_commands</primary>
   </indexterm>

<!--==========================orignal english content==========================
<synopsis>
<function>pg_event_trigger_ddl_commands</function> () <returnvalue>setof record</returnvalue>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<function>pg_event_trigger_ddl_commands</function> () <returnvalue>setof record</returnvalue>
</synopsis>

<!--==========================orignal english content==========================
   <para>
    <function>pg_event_trigger_ddl_commands</function> returns a list of
    <acronym>DDL</acronym> commands executed by each user action,
    when invoked in a function attached to a
    <literal>ddl_command_end</literal> event trigger.  If called in any other
    context, an error is raised.
    <function>pg_event_trigger_ddl_commands</function> returns one row for each
    base command executed; some commands that are a single SQL sentence
    may return more than one row.  This function returns the following
    columns:

    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Name</entry>
        <entry>Type</entry>
        <entry>Description</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><literal>classid</literal></entry>
        <entry><type>oid</type></entry>
        <entry>OID of catalog the object belongs in</entry>
       </row>
       <row>
        <entry><literal>objid</literal></entry>
        <entry><type>oid</type></entry>
        <entry>OID of the object itself</entry>
       </row>
       <row>
        <entry><literal>objsubid</literal></entry>
        <entry><type>integer</type></entry>
        <entry>Sub-object ID (e.g., attribute number for a column)</entry>
       </row>
       <row>
        <entry><literal>command_tag</literal></entry>
        <entry><type>text</type></entry>
        <entry>Command tag</entry>
       </row>
       <row>
        <entry><literal>object_type</literal></entry>
        <entry><type>text</type></entry>
        <entry>Type of the object</entry>
       </row>
       <row>
        <entry><literal>schema_name</literal></entry>
        <entry><type>text</type></entry>
        <entry>
         Name of the schema the object belongs in, if any; otherwise <literal>NULL</literal>.
         No quoting is applied.
        </entry>
       </row>
       <row>
        <entry><literal>object_identity</literal></entry>
        <entry><type>text</type></entry>
        <entry>
         Text rendering of the object identity, schema-qualified. Each
         identifier included in the identity is quoted if necessary.
        </entry>
       </row>
       <row>
        <entry><literal>in_extension</literal></entry>
        <entry><type>boolean</type></entry>
        <entry>True if the command is part of an extension script</entry>
       </row>
       <row>
        <entry><literal>command</literal></entry>
        <entry><type>pg_ddl_command</type></entry>
        <entry>
         A complete representation of the command, in internal format.
         This cannot be output directly, but it can be passed to other
         functions to obtain different pieces of information about the
         command.
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>
____________________________________________________________________________-->
   <para>
    当在一个<literal>ddl_command_end</literal>事件触发器的函数中调用时，
    <function>pg_event_trigger_ddl_commands</function>返回被每一个用户动作
    执行的<acronym>DDL</acronym>命令的列表。如果在其他任何环境中
    调用这个函数，会发生错误。
    <function>pg_event_trigger_ddl_commands</function>为每一个被执行的基本
    命令返回一行，某些只有一个单一 SQL 句子的命令可能会返回多于一行。
    这个函数返回下面的列：

    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>名称</entry>
        <entry>类型</entry>
        <entry>描述</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><literal>classid</literal></entry>
        <entry><type>oid</type></entry>
        <entry>对象所属的目录的 OID</entry>
       </row>
       <row>
        <entry><literal>objid</literal></entry>
        <entry><type>oid</type></entry>
        <entry>对象本身的 OID</entry>
       </row>
       <row>
        <entry><literal>objsubid</literal></entry>
        <entry><type>integer</type></entry>
        <entry>对象的子-id（例如列的属性号）</entry>
       </row>
       <row>
        <entry><literal>command_tag</literal></entry>
        <entry><type>text</type></entry>
        <entry>命令标签</entry>
       </row>
       <row>
        <entry><literal>object_type</literal></entry>
        <entry><type>text</type></entry>
        <entry>对象的类型</entry>
       </row>
       <row>
        <entry><literal>schema_name</literal></entry>
        <entry><type>text</type></entry>
        <entry>
         该对象所属的模式的名称（如果有），如果没有则为<literal>NULL</literal>。
         没有引号。
        </entry>
       </row>
       <row>
        <entry><literal>object_identity</literal></entry>
        <entry><type>text</type></entry>
        <entry>
         对象标识的文本表现形式，用模式限定。如果必要，出现在
         该标识中的每一个标识符都会被引用。
        </entry>
       </row>
       <row>
        <entry><literal>in_extension</literal></entry>
        <entry><type>boolean</type></entry>
        <entry>如果该命令是一个扩展脚本的一部分则为真</entry>
       </row>
       <row>
        <entry><literal>command</literal></entry>
        <entry><type>pg_ddl_command</type></entry>
        <entry>
         以内部格式表达的该命令的一个完整表现形式。这不能被直接输出，
         但是可以把它传递给其他函数来得到有关于该命令不同部分的信息。
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>
  </sect2>

  <sect2 id="pg-event-trigger-sql-drop-functions">
<!--==========================orignal english content==========================
   <title>Processing Objects Dropped by a DDL Command</title>
____________________________________________________________________________-->
   <title>处理被 DDL 命令删除的对象</title>

<!--==========================orignal english content==========================
   <indexterm>
     <primary>pg_event_trigger_dropped_objects</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
     <primary>pg_event_trigger_dropped_objects</primary>
   </indexterm>

<!--==========================orignal english content==========================
<synopsis>
<function>pg_event_trigger_dropped_objects</function> () <returnvalue>setof record</returnvalue>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<function>pg_event_trigger_dropped_objects</function> () <returnvalue>setof record</returnvalue>
</synopsis>

<!--==========================orignal english content==========================
   <para>
    <function>pg_event_trigger_dropped_objects</function> returns a list of all objects
    dropped by the command in whose <literal>sql_drop</literal> event it is called.
    If called in any other context, an error is raised.
    This function returns the following columns:

    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Name</entry>
        <entry>Type</entry>
        <entry>Description</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><literal>classid</literal></entry>
        <entry><type>oid</type></entry>
        <entry>OID of catalog the object belonged in</entry>
       </row>
       <row>
        <entry><literal>objid</literal></entry>
        <entry><type>oid</type></entry>
        <entry>OID of the object itself</entry>
       </row>
       <row>
        <entry><literal>objsubid</literal></entry>
        <entry><type>integer</type></entry>
        <entry>Sub-object ID (e.g., attribute number for a column)</entry>
       </row>
       <row>
        <entry><literal>original</literal></entry>
        <entry><type>boolean</type></entry>
        <entry>True if this was one of the root object(s) of the deletion</entry>
       </row>
       <row>
        <entry><literal>normal</literal></entry>
        <entry><type>boolean</type></entry>
        <entry>
         True if there was a normal dependency relationship
         in the dependency graph leading to this object
        </entry>
       </row>
       <row>
        <entry><literal>is_temporary</literal></entry>
        <entry><type>boolean</type></entry>
        <entry>
         True if this was a temporary object
        </entry>
       </row>
       <row>
        <entry><literal>object_type</literal></entry>
        <entry><type>text</type></entry>
        <entry>Type of the object</entry>
       </row>
       <row>
        <entry><literal>schema_name</literal></entry>
        <entry><type>text</type></entry>
        <entry>
         Name of the schema the object belonged in, if any; otherwise <literal>NULL</literal>.
         No quoting is applied.
        </entry>
       </row>
       <row>
        <entry><literal>object_name</literal></entry>
        <entry><type>text</type></entry>
        <entry>
         Name of the object, if the combination of schema and name can be
         used as a unique identifier for the object; otherwise <literal>NULL</literal>.
         No quoting is applied, and name is never schema-qualified.
        </entry>
       </row>
       <row>
        <entry><literal>object_identity</literal></entry>
        <entry><type>text</type></entry>
        <entry>
         Text rendering of the object identity, schema-qualified. Each
         identifier included in the identity is quoted if necessary.
        </entry>
       </row>
       <row>
        <entry><literal>address_names</literal></entry>
        <entry><type>text[]</type></entry>
        <entry>
         An array that, together with <literal>object_type</literal> and
         <literal>address_args</literal>, can be used by
         the <function>pg_get_object_address</function> function to
         recreate the object address in a remote server containing an
         identically named object of the same kind.
        </entry>
       </row>
       <row>
        <entry><literal>address_args</literal></entry>
        <entry><type>text[]</type></entry>
        <entry>
         Complement for <literal>address_names</literal>
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_event_trigger_dropped_objects</function>返回被调用<literal>sql_drop</literal>事件的命令删除的所有对象的列表。
    如果调用在任何其他上下文中，会引发一个错误。这个函数返回以下列:

    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>名称</entry>
        <entry>类型</entry>
        <entry>描述</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><literal>classid</literal></entry>
        <entry><type>oid</type></entry>
        <entry>对象所属的目录的 OID</entry>
       </row>
       <row>
        <entry><literal>objid</literal></entry>
        <entry><type>oid</type></entry>
        <entry>对象本身的 OID</entry>
       </row>
       <row>
        <entry><literal>objsubid</literal></entry>
        <entry><type>integer</type></entry>
        <entry>子对象ID（如列的属性号）</entry>
       </row>
       <row>
        <entry><literal>original</literal></entry>
        <entry><type>boolean</type></entry>
        <entry>如果这是删除中的一个根对象则为真</entry>
       </row>
       <row>
        <entry><literal>normal</literal></entry>
        <entry><type>boolean</type></entry>
        <entry>
         指示在依赖图中有一个普通依赖关系指向该对象的标志
        </entry>
       </row>
       <row>
        <entry><literal>is_temporary</literal></entry>
        <entry><type>boolean</type></entry>
        <entry>
         如果该对象是一个临时对象则为真
        </entry>
       </row>
       <row>
        <entry><literal>object_type</literal></entry>
        <entry><type>text</type></entry>
        <entry>对象的类型</entry>
       </row>
       <row>
        <entry><literal>schema_name</literal></entry>
        <entry><type>text</type></entry>
        <entry>
         对象所属模式的名称（如果存在）；否则为<literal>NULL</literal>。不应用引用。
        </entry>
       </row>
       <row>
        <entry><literal>object_name</literal></entry>
        <entry><type>text</type></entry>
        <entry>
         如果模式和名称的组合能被用于对象的一个唯一标识符，则是对象的名称；否则是<literal>NULL</literal>。不应用引用，并且名称不是模式限定的。
        </entry>
       </row>
       <row>
        <entry><literal>object_identity</literal></entry>
        <entry><type>text</type></entry>
        <entry>
         对象身份的文本表现，模式限定的。每一个以及所有身份中出现的标识符在必要时加引号。
        </entry>
       </row>
       <row>
        <entry><literal>address_names</literal></entry>
        <entry><type>text[]</type></entry>
        <entry>
         一个数组，它可以和<literal>object_type</literal>及<literal>address_args</literal>，
         一起通过<function>pg_get_object_address</function>函数在一台包含有同类相同名称对象的远程服务器上重建该对象地址。
        </entry>
       </row>
       <row>
        <entry><literal>address_args</literal></entry>
        <entry><type>text[]</type></entry>
        <entry>
         上述<literal>address_names</literal>的补充。
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>

<!--==========================orignal english content==========================
   <para>
    The <function>pg_event_trigger_dropped_objects</function> function can be used
    in an event trigger like this:
<programlisting>
CREATE FUNCTION test_event_trigger_for_drops()
        RETURNS event_trigger LANGUAGE plpgsql AS $$
DECLARE
    obj record;
BEGIN
    FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()
    LOOP
        RAISE NOTICE '% dropped object: % %.% %',
                     tg_tag,
                     obj.object_type,
                     obj.schema_name,
                     obj.object_name,
                     obj.object_identity;
    END LOOP;
END;
$$;
CREATE EVENT TRIGGER test_event_trigger_for_drops
   ON sql_drop
   EXECUTE FUNCTION test_event_trigger_for_drops();
</programlisting>
    </para>
____________________________________________________________________________-->
   <para>
    <function>pg_event_trigger_dropped_objects</function>可以被这样用在一个事件触发器中：
<programlisting>
CREATE FUNCTION test_event_trigger_for_drops()
        RETURNS event_trigger LANGUAGE plpgsql AS $$
DECLARE
    obj record;
BEGIN
    FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()
    LOOP
        RAISE NOTICE '% dropped object: % %.% %',
                     tg_tag,
                     obj.object_type,
                     obj.schema_name,
                     obj.object_name,
                     obj.object_identity;
    END LOOP;
END;
$$;
CREATE EVENT TRIGGER test_event_trigger_for_drops
   ON sql_drop
   EXECUTE FUNCTION test_event_trigger_for_drops();
</programlisting>
    </para>
  </sect2>

  <sect2 id="pg-event-trigger-table-rewrite-functions">
<!--==========================orignal english content==========================
   <title>Handling a Table Rewrite Event</title>
____________________________________________________________________________-->
   <title>处理表重写事件</title>

<!--==========================orignal english content==========================
   <para>
    The functions shown in
    <xref linkend="functions-event-trigger-table-rewrite"/>
    provide information about a table for which a
    <literal>table_rewrite</literal> event has just been called.
    If called in any other context, an error is raised.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="functions-event-trigger-table-rewrite"/>
    中所示的函数提供刚刚被调用过<literal>table_rewrite</literal>
    事件的表的信息。如果在任何其他环境中调用，会发生错误。
   </para>

   <table id="functions-event-trigger-table-rewrite">
<!--==========================orignal english content==========================
    <title>Table Rewrite Information Functions</title>
____________________________________________________________________________-->
    <title>表重写信息函数</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_event_trigger_table_rewrite_oid</primary>
        </indexterm>
        <function>pg_event_trigger_table_rewrite_oid</function> ()
        <returnvalue>oid</returnvalue>
       </para>
       <para>
        Returns the OID of the table about to be rewritten.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_event_trigger_table_rewrite_oid</primary>
        </indexterm>
        <function>pg_event_trigger_table_rewrite_oid</function> ()
        <returnvalue>oid</returnvalue>
       </para>
       <para>
        返回将要重写的表的OID。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_event_trigger_table_rewrite_reason</primary>
        </indexterm>
        <function>pg_event_trigger_table_rewrite_reason</function> ()
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns a code explaining the reason(s) for rewriting.  The exact
        meaning of the codes is release dependent.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_event_trigger_table_rewrite_reason</primary>
        </indexterm>
        <function>pg_event_trigger_table_rewrite_reason</function> ()
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回解释重写原因的代码。代码的确切含义取决于版本。
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    These functions can be used in an event trigger like this:
<programlisting>
CREATE FUNCTION test_event_trigger_table_rewrite_oid()
 RETURNS event_trigger
 LANGUAGE plpgsql AS
$$
BEGIN
  RAISE NOTICE 'rewriting table % for reason %',
                pg_event_trigger_table_rewrite_oid()::regclass,
                pg_event_trigger_table_rewrite_reason();
END;
$$;

CREATE EVENT TRIGGER test_table_rewrite_oid
                  ON table_rewrite
   EXECUTE FUNCTION test_event_trigger_table_rewrite_oid();
</programlisting>
    </para>
____________________________________________________________________________-->
   <para>
    这些函数可以在事件触发器中使用，就像这样:
<programlisting>
CREATE FUNCTION test_event_trigger_table_rewrite_oid()
 RETURNS event_trigger
 LANGUAGE plpgsql AS
$$
BEGIN
  RAISE NOTICE 'rewriting table % for reason %',
                pg_event_trigger_table_rewrite_oid()::regclass,
                pg_event_trigger_table_rewrite_reason();
END;
$$;

CREATE EVENT TRIGGER test_table_rewrite_oid
                  ON table_rewrite
   EXECUTE FUNCTION test_event_trigger_table_rewrite_oid();
</programlisting>
    </para>
  </sect2>
  </sect1>

  <sect1 id="functions-statistics">
<!--==========================orignal english content==========================
   <title>Statistics Information Functions</title>
____________________________________________________________________________-->
   <title>统计信息函数</title>

<!--==========================orignal english content==========================
   <indexterm zone="functions-statistics">
    <primary>function</primary>
    <secondary>statistics</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="functions-statistics">
    <primary>function</primary>
    <secondary>statistics</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    <productname>PostgreSQL</productname> provides a function to inspect complex
    statistics defined using the <command>CREATE STATISTICS</command> command.
   </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>提供了一个函数来检查使用<command>CREATE STATISTICS</command>命令定义的复杂统计。
   </para>

  <sect2 id="functions-statistics-mcv">
<!--==========================orignal english content==========================
   <title>Inspecting MCV Lists</title>
____________________________________________________________________________-->
   <title>检查MCV列表</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pg_mcv_list_items</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pg_mcv_list_items</primary>
   </indexterm>

<!--==========================orignal english content==========================
<synopsis>
<function>pg_mcv_list_items</function> ( <type>pg_mcv_list</type> ) <returnvalue>setof record</returnvalue>
</synopsis>
____________________________________________________________________________-->
<synopsis>
<function>pg_mcv_list_items</function> ( <type>pg_mcv_list</type> ) <returnvalue>setof record</returnvalue>
</synopsis>

<!--==========================orignal english content==========================
   <para>
    <function>pg_mcv_list_items</function> returns a set of records describing
    all items stored in a multi-column <acronym>MCV</acronym> list.  It
    returns the following columns:

    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Name</entry>
        <entry>Type</entry>
        <entry>Description</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><literal>index</literal></entry>
        <entry><type>integer</type></entry>
        <entry>index of the item in the <acronym>MCV</acronym> list</entry>
       </row>
       <row>
        <entry><literal>values</literal></entry>
        <entry><type>text[]</type></entry>
        <entry>values stored in the MCV item</entry>
       </row>
       <row>
        <entry><literal>nulls</literal></entry>
        <entry><type>boolean[]</type></entry>
        <entry>flags identifying <literal>NULL</literal> values</entry>
       </row>
       <row>
        <entry><literal>frequency</literal></entry>
        <entry><type>double precision</type></entry>
        <entry>frequency of this <acronym>MCV</acronym> item</entry>
       </row>
       <row>
        <entry><literal>base_frequency</literal></entry>
        <entry><type>double precision</type></entry>
        <entry>base frequency of this <acronym>MCV</acronym> item</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_mcv_list_items</function>返回一组记录，描述存储在多列<acronym>MCV</acronym>列表中的所有项目。它返回以下列:

    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>名称</entry>
        <entry>类型</entry>
        <entry>描述</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><literal>index</literal></entry>
        <entry><type>integer</type></entry>
        <entry> <acronym>MCV</acronym> 列表中的项目索引</entry>
       </row>
       <row>
        <entry><literal>values</literal></entry>
        <entry><type>text[]</type></entry>
        <entry>存储在MCV项目中的值</entry>
       </row>
       <row>
        <entry><literal>nulls</literal></entry>
        <entry><type>boolean[]</type></entry>
        <entry>标识<literal>NULL</literal>值的标志</entry>
       </row>
       <row>
        <entry><literal>frequency</literal></entry>
        <entry><type>double precision</type></entry>
        <entry><acronym>MCV</acronym>项目的频率</entry>
       </row>
       <row>
        <entry><literal>base_frequency</literal></entry>
        <entry><type>double precision</type></entry>
        <entry><acronym>MCV</acronym>项目的基本频率</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>

<!--==========================orignal english content==========================
   <para>
    The <function>pg_mcv_list_items</function> function can be used like this:

<programlisting>
SELECT m.* FROM pg_statistic_ext join pg_statistic_ext_data on (oid = stxoid),
                pg_mcv_list_items(stxdmcv) m WHERE stxname = 'stts';
</programlisting>

    Values of the <type>pg_mcv_list</type> type can be obtained only from the
    <structname>pg_statistic_ext_data</structname>.<structfield>stxdmcv</structfield>
    column.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pg_mcv_list_items</function>函数可以这样使用:

<programlisting>
SELECT m.* FROM pg_statistic_ext join pg_statistic_ext_data on (oid = stxoid),
                pg_mcv_list_items(stxdmcv) m WHERE stxname = 'stts';
</programlisting>

    <type>pg_mcv_list</type>类型的值只能从<structname>pg_statistic_ext_data</structname>.<structfield>stxdmcv</structfield>列中获取。
   </para>
  </sect2>

  </sect1>

</chapter>